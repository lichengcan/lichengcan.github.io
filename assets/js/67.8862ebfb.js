(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{485:function(n,t,e){"use strict";e.r(t);var a=e(2),r=Object(a.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("blockquote",[n("p",[n("a",{attrs:{href:"https://www.jb51.net/article/48304.htm",target:"_blank",rel:"noopener noreferrer"}},[this._v("JAVA8 十大新特性详解_java_脚本之家 (jb51.net)"),n("OutboundLink")],1)])]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('一、接口的默认方法\n\nJava 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：\n\n复制代码代码如下:\n\ninterface Formula {\n    double calculate(int a);\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n}\n\n\nFormula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。\n复制代码代码如下:\n\nFormula formula = new Formula() {\n    @Override\n    public double calculate(int a) {\n        return sqrt(a * 100);\n    }\n};\nformula.calculate(100);     // 100.0\nformula.sqrt(16);           // 4.0\n\n\n文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。\n译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。\n\n二、Lambda 表达式\n\n首先看看在老版本的Java中是如何排列字符串的：\n\n复制代码代码如下:\n\nList<String> names = Arrays.asList("peter", "anna", "mike", "xenia");\nCollections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n});\n\n\n只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。\n在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：\n\n复制代码代码如下:\n\nCollections.sort(names, (String a, String b) -> {\n    return b.compareTo(a);\n});\n\n看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：\n复制代码代码如下:\n\nCollections.sort(names, (String a, String b) -> b.compareTo(a));\n\n对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：\n复制代码代码如下:\n\nCollections.sort(names, (a, b) -> b.compareTo(a));\n\nJava编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：\n\n三、函数式接口\n\nLambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。\n我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。\n\n示例如下：\n\n复制代码代码如下:\n\n@FunctionalInterface\ninterface Converter<F, T> {\n    T convert(F from);\n}\nConverter<String, Integer> converter = (from) -> Integer.valueOf(from);\nInteger converted = converter.convert("123");\nSystem.out.println(converted);    // 123\n\n需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。\n译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。\n\n四、方法与构造函数引用\n\n前一节中的代码还可以通过静态方法引用来表示：\n\n复制代码代码如下:\n\nConverter<String, Integer> converter = Integer::valueOf;\nInteger converted = converter.convert("123");\nSystem.out.println(converted);   // 123\n\nJava 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：\n复制代码代码如下:\n\n converter = something::startsWith;\nString converted = converter.convert("Java");\nSystem.out.println(converted);    // "J"\n\n接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：\n复制代码代码如下:\n\nclass Person {\n    String firstName;\n    String lastName;\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n\n\n接下来我们指定一个用来创建Person对象的对象工厂接口：\n复制代码代码如下:\n\ninterface PersonFactory<P extends Person> {\n    P create(String firstName, String lastName);\n}\n\n这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：\n复制代码代码如下:\n\nPersonFactory<Person> personFactory = Person::new;\nPerson person = personFactory.create("Peter", "Parker");\n\n我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。\n五、Lambda 作用域\n\n在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。\n\n六、访问局部变量\n\n我们可以直接在lambda表达式中访问外层的局部变量：\n\n复制代码代码如下:\n\nfinal int num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\nstringConverter.convert(2);     // 3\n\n\n但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：\n复制代码代码如下:\n\nint num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\nstringConverter.convert(2);     // 3\n\n\n不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：\n复制代码代码如下:\n\nint num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\nnum = 3;\n\n在lambda表达式中试图修改num同样是不允许的。\n\n七、访问对象字段与静态变量\n和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：\n\n复制代码代码如下:\nclass Lambda4 {\n    static int outerStaticNum;\n    int outerNum;\n    void testScopes() {\n        Converter<Integer, String> stringConverter1 = (from) -> {\n            outerNum = 23;\n            return String.valueOf(from);\n        };\n\n        Converter<Integer, String> stringConverter2 = (from) -> {\n            outerStaticNum = 72;\n            return String.valueOf(from);\n        };\n    }\n}\n\n\n\n八、访问接口的默认方法\n\n还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。\nLambda表达式中是无法访问到默认方法的，以下代码将无法编译：\n复制代码代码如下:\n\nFormula formula = (a) -> sqrt( a * 100);\nBuilt-in Functional Interfaces\n\nJDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。\nJava 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。\n\nPredicate接口\nPredicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：\n\n复制代码代码如下:\n\nPredicate<String> predicate = (s) -> s.length() > 0;\npredicate.test("foo");              // true\npredicate.negate().test("foo");     // false\n\nPredicate<Boolean> nonNull = Objects::nonNull;\nPredicate<Boolean> isNull = Objects::isNull;\n\nPredicate<String> isEmpty = String::isEmpty;\nPredicate<String> isNotEmpty = isEmpty.negate();\n\n\n\nFunction 接口\nFunction 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：\n\n复制代码代码如下:\n\nFunction<String, Integer> toInteger = Integer::valueOf;\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\nbackToString.apply("123");     // "123"\n\n\n\nSupplier 接口\n\nSupplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数\n复制代码代码如下:\n\nSupplier<Person> personSupplier = Person::new;\npersonSupplier.get();   // new Person\n\n\nConsumer 接口\n\nConsumer 接口表示执行在单个参数上的操作。\n复制代码代码如下:\n\nConsumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);\ngreeter.accept(new Person("Luke", "Skywalker"));\n\n\nComparator 接口\n\nComparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：\n复制代码代码如下:\n\nComparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\nPerson p1 = new Person("John", "Doe");\nPerson p2 = new Person("Alice", "Wonderland");\n\ncomparator.compare(p1, p2);             // > 0\ncomparator.reversed().compare(p1, p2);  // < 0\n\n\n\nOptional 接口\nOptional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：\n\nOptional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。\n\n复制代码代码如下:\n\nOptional<String> optional = Optional.of("bam");\noptional.isPresent();           // true\noptional.get();                 // "bam"\noptional.orElse("fallback");    // "bam"\n\noptional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"\n\n\n\nStream 接口\njava.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。\n\n首先看看Stream是怎么用，首先创建实例代码的用到的数据List：\n\n复制代码代码如下:\n\nList<String> stringCollection = new ArrayList<>();\nstringCollection.add("ddd2");\nstringCollection.add("aaa2");\nstringCollection.add("bbb1");\nstringCollection.add("aaa1");\nstringCollection.add("bbb3");\nstringCollection.add("ccc");\nstringCollection.add("bbb2");\nstringCollection.add("ddd1");\n\nJava 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：\nFilter 过滤\n\n过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。\n\n复制代码代码如下:\n\nstringCollection\n    .stream()\n    .filter((s) -> s.startsWith("a"))\n    .forEach(System.out::println);\n// "aaa2", "aaa1"\n\n\n\nSort 排序\n排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。\n\n复制代码代码如下:\n\nstringCollection\n    .stream()\n    .sorted()\n    .filter((s) -> s.startsWith("a"))\n    .forEach(System.out::println);\n// "aaa1", "aaa2"\n\n\n需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：\n复制代码代码如下:\n\nSystem.out.println(stringCollection);\n// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1\n\n\nMap 映射\n\n中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。\n复制代码代码如下:\n\nstringCollection\n    .stream()\n    .map(String::toUpperCase)\n    .sorted((a, b) -> b.compareTo(a))\n    .forEach(System.out::println);\n// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"\n\n\n\nMatch 匹配\nStream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。\n\n复制代码代码如下:\n\nboolean anyStartsWithA =\n    stringCollection\n        .stream()\n        .anyMatch((s) -> s.startsWith("a"));\nSystem.out.println(anyStartsWithA);      // true\n\nboolean allStartsWithA =\n    stringCollection\n        .stream()\n        .allMatch((s) -> s.startsWith("a"));\n\nSystem.out.println(allStartsWithA);      // false\n\nboolean noneStartsWithZ =\n    stringCollection\n        .stream()\n        .noneMatch((s) -> s.startsWith("z"));\n\nSystem.out.println(noneStartsWithZ);      // true\n\nCount 计数\n\n计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。\n\n复制代码代码如下:\n\nlong startsWithB =\n    stringCollection\n        .stream()\n        .filter((s) -> s.startsWith("b"))\n        .count();\nSystem.out.println(startsWithB);    // 3\n\n\n\nReduce 规约\n这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：\n\n复制代码代码如下:\n\nOptional<String> reduced =\n    stringCollection\n        .stream()\n        .sorted()\n        .reduce((s1, s2) -> s1 + "#" + s2);\nreduced.ifPresent(System.out::println);\n// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"\n\n\n\n并行Streams\n前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。\n\n下面的例子展示了是如何通过并行Stream来提升性能：\n\n首先我们创建一个没有重复元素的大表：\n\n复制代码代码如下:\n\nint max = 1000000;\nList<String> values = new ArrayList<>(max);\nfor (int i = 0; i < max; i++) {\n    UUID uuid = UUID.randomUUID();\n    values.add(uuid.toString());\n}\n\n然后我们计算一下排序这个Stream要耗时多久，\n串行排序：\n复制代码代码如下:\n\nlong t0 = System.nanoTime();\nlong count = values.stream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("sequential sort took: %d ms", millis));\n\n// 串行耗时: 899 ms\n并行排序：\n\n复制代码代码如下:\n\nlong t0 = System.nanoTime();\nlong count = values.parallelStream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("parallel sort took: %d ms", millis));\n\n// 并行排序耗时: 472 ms\n上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。\n\nMap\n\n前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。\n\n复制代码代码如下:\n\nMap<Integer, String> map = new HashMap<>();\nfor (int i = 0; i < 10; i++) {\n    map.putIfAbsent(i, "val" + i);\n}\n\nmap.forEach((id, val) -> System.out.println(val));\n以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。\n\n下面的例子展示了map上的其他有用的函数：\n\n复制代码代码如下:\n\nmap.computeIfPresent(3, (num, val) -> val + num);\nmap.get(3);             // val33\nmap.computeIfPresent(9, (num, val) -> null);\nmap.containsKey(9);     // false\n\nmap.computeIfAbsent(23, num -> "val" + num);\nmap.containsKey(23);    // true\n\nmap.computeIfAbsent(3, num -> "bam");\nmap.get(3);             // val33\n\n\n接下来展示如何在Map里删除一个键值全都匹配的项：\n复制代码代码如下:\n\nmap.remove(3, "val3");\nmap.get(3);             // val33\nmap.remove(3, "val33");\nmap.get(3);             // null\n\n\n另外一个有用的方法：\n复制代码代码如下:\n\nmap.getOrDefault(42, "not found");  // not found\n\n对Map的元素做合并也变得很容易了：\n复制代码代码如下:\n\nmap.merge(9, "val9", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9\nmap.merge(9, "concat", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9concat\n\n\nMerge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。\n九、Date API\n\nJava 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：\n\nClock 时钟\n\nClock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。\n\n复制代码代码如下:\n\nClock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\nInstant instant = clock.instant();\nDate legacyDate = Date.from(instant);   // legacy java.util.Date\n\n\n\nTimezones 时区\n在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。\n\n复制代码代码如下:\n\nSystem.out.println(ZoneId.getAvailableZoneIds());\n// prints all available timezone ids\nZoneId zone1 = ZoneId.of("Europe/Berlin");\nZoneId zone2 = ZoneId.of("Brazil/East");\nSystem.out.println(zone1.getRules());\nSystem.out.println(zone2.getRules());\n\n// ZoneRules[currentStandardOffset=+01:00]\n// ZoneRules[currentStandardOffset=-03:00]\n\n\n\nLocalTime 本地时间\nLocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：\n\n复制代码代码如下:\n\nLocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\nSystem.out.println(now1.isBefore(now2));  // false\n\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n\n\nLocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。\n复制代码代码如下:\n\nLocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\n\nLocalTime leetTime = LocalTime.parse("13:37", germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n\n\nLocalDate 本地日期\n\nLocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。\n\n复制代码代码如下:\n\nLocalDate today = LocalDate.now();\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\nLocalDate yesterday = tomorrow.minusDays(2);\nLocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\n\n\nSystem.out.println(dayOfWeek);    // FRIDAY\n从字符串解析一个LocalDate类型和解析LocalTime一样简单：\n复制代码代码如下:\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedDate(FormatStyle.MEDIUM)\n        .withLocale(Locale.GERMAN);\nLocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);\nSystem.out.println(xmas);   // 2014-12-24\n\n\n\nLocalDateTime 本地日期时间\nLocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。\n\n复制代码代码如下:\n\nLocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // WEDNESDAY\n\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // DECEMBER\n\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n\n\n只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。\n复制代码代码如下:\n\nInstant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n\n\n格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：\n复制代码代码如下:\n\nDateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern("MMM dd, yyyy - HH:mm");\nLocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n\n\n和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。\n关于时间日期格式的详细信息：http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html\n十、Annotation 注解\n\n在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。\n首先定义一个包装类Hints注解用来放置一组具体的Hint注解：\n\n复制代码代码如下:\n\n@interface Hints {\n    Hint[] value();\n}\n@Repeatable(Hints.class)\n@interface Hint {\n    String value();\n}\n\n\nJava 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。\n例 1: 使用包装类当容器来存多个注解（老方法）\n\n复制代码代码如下:\n\n@Hints({@Hint("hint1"), @Hint("hint2")})\nclass Person {}\n\n例 2：使用多重注解（新方法）\n复制代码代码如下:\n\n@Hint("hint1")\n@Hint("hint2")\nclass Person {}\n\n第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：\n复制代码代码如下:\n\nHint hint = Person.class.getAnnotation(Hint.class);\nSystem.out.println(hint);                   // null\nHints hints1 = Person.class.getAnnotation(Hints.class);\nSystem.out.println(hints1.value().length);  // 2\n\nHint[] hints2 = Person.class.getAnnotationsByType(Hint.class);\nSystem.out.println(hints2.length);          // 2\n\n\n即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。\n另外Java 8的注解还增加到两种新的target上了：\n复制代码代码如下:\n\n@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n@interface MyAnnotation {}\n\n关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);