(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{431:function(a,t,v){"use strict";v.r(t);var n=v(2),s=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("blockquote",[t("p",[a._v("Java 的类加载机制是 Java 虚拟机（JVM）用来加载类文件到内存中的方法。它是 Java 实现动态加载代码的基础，也是 Java 运行时环境的一部分。以下是类加载机制的主要组成部分和过程，以及一个具体的示例。")])]),a._v(" "),t("h3",{attrs:{id:"类加载的时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载的时机"}},[a._v("#")]),a._v(" 类加载的时机")]),a._v(" "),t("p",[a._v("在 Java 中，并非所有的类都在 Java 程序启动时一次性加载，而是根据需要，采用动态加载的方式。类在首次主动使用时才会加载。主动使用包括以下几种情况：")]),a._v(" "),t("ol",[t("li",[a._v("创建类的实例。")]),a._v(" "),t("li",[a._v("访问类或接口的静态变量，或者对该静态变量赋值。")]),a._v(" "),t("li",[a._v("调用类的静态方法。")]),a._v(" "),t("li",[a._v("使用反射方式来强制创建某个类或接口对应的 java.lang.Class 对象。")]),a._v(" "),t("li",[a._v("初始化子类时，如果发现父类还没有进行过初始化，则需要先触发父类的初始化。")]),a._v(" "),t("li",[a._v("作为程序的入口起点类（即包含 main 方法的类）。")])]),a._v(" "),t("h3",{attrs:{id:"类加载的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载的过程"}},[a._v("#")]),a._v(" 类加载的过程")]),a._v(" "),t("p",[a._v("类加载过程主要分为加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）和初始化（Initialization）五个阶段。")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("加载（Loading）")]),a._v(": 在这个阶段，JVM 会查找 class 文件并创建一个代表这个类的 java.lang.Class 对象。加载是类加载过程的一个具体实现阶段，完成以下三件事情：\n"),t("ul",[t("li",[a._v("通过类的全限定名来获取此类的二进制字节流。")]),a._v(" "),t("li",[a._v("将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。")]),a._v(" "),t("li",[a._v("在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这些数据的访问入口。")])])]),a._v(" "),t("li",[t("strong",[a._v("验证（Verification）")]),a._v(": 这一步确保加载的类满足 JVM 的约束条件，是正确的字节码文件。这个过程包括对类文件的格式验证、元数据验证、字节码验证、符号引用验证等。")]),a._v(" "),t("li",[t("strong",[a._v("准备（Preparation）")]),a._v(": 在准备阶段，JVM 为类的静态变量分配内存，并设置默认初始值。")]),a._v(" "),t("li",[t("strong",[a._v("解析（Resolution）")]),a._v(": 这个阶段涉及将类、接口、字段和方法的符号引用替换为直接引用的过程。")]),a._v(" "),t("li",[t("strong",[a._v("初始化（Initialization）")]),a._v(": 这是类加载的最后阶段，在此阶段，JVM 执行类的初始化语句，这包括静态字段的赋值和静态代码块的执行。初始化阶段是执行类构造器 "),t("code",[a._v("<clinit>()")]),a._v(" 方法的过程。")])]),a._v(" "),t("h3",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),t("p",[a._v("在 JVM 中存在多种类加载器，主要有：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("Bootstrap 类加载器（启动类加载器）")]),a._v(": 它是虚拟机的一部分，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。")]),a._v(" "),t("li",[t("strong",[a._v("Extension 类加载器（扩展类加载器）")]),a._v(": 它由 sun.misc.Launcher$ExtClassLoader 实现。它负责加载 JAVA_HOME/lib/ext 目录中的，或者被 java.ext.dirs 系统变量指定的路径中的所有类库。")]),a._v(" "),t("li",[t("strong",[a._v("Application 类加载器（应用类加载器）")]),a._v(": 它由 sun.misc.Launcher$AppClassLoader 实现。它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用这个类加载器。")]),a._v(" "),t("li",[t("strong",[a._v("自定义类加载器")]),a._v(": Java 也允许开发者实现自己的类加载器，以满足某些特殊需求。")])]),a._v(" "),t("h3",{attrs:{id:"示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[a._v("#")]),a._v(" 示例")]),a._v(" "),t("p",[a._v('假设我们有一个简单的 Java 类，名为 "Example"，位于包 "com.demo" 中。当我们尝试创建这个类的一个实例时，类加载过程将会启动：')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('javaCopy codepackage com.demo;\n\npublic class Example {\n    static {\n        System.out.println("Static block of Example class.");\n    }\n\n    public Example() {\n        System.out.println("Creating an instance of Example class.");\n    }\n}\n\n// 在另一个类中，比如应用的 main 方法中：\npublic class Main {\n    public static void main(String[] args) {\n        Example example = new Example(); // 这里将触发 Example 类的加载、验证、准备、解析和初始化\n    }\n}\n')])])]),t("p",[a._v('在这个例子中，当 JVM 在 main 方法中遇到 "new Example()" 时，它会为 "com.demo.Example" 类执行加载过程。首先，它会尝试找到 "com.demo.Example" 类的字节码，然后进行验证，确保字节码文件的完整性和安全性。接着，在准备阶段，JVM 为类的静态变量分配内存。在解析阶段，它会处理类的各种符号引用，将这些引用替换为实际引用。最后，在初始化阶段，静态块中的代码将会被执行。')]),a._v(" "),t("p",[a._v("这个过程是由类加载器和 JVM 协同完成的，对于开发者来说，这个过程是透明的。")])])}),[],!1,null,null,null);t.default=s.exports}}]);