(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{493:function(n,t,s){"use strict";s.r(t);var a=s(2),l=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"一、java多态性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、java多态性"}},[n._v("#")]),n._v(" 一、Java多态性")]),n._v(" "),t("p",[n._v("面向对象的三大特性：封装、继承、多态。")]),n._v(" "),t("p",[t("strong",[n._v("多态的类型，分为以下两种")]),n._v("：")]),n._v(" "),t("ul",[t("li",[n._v("编译时多态： 指的是 方法重载。"),t("strong",[n._v("编译时多态是在编译时确定调用处选择那个重载方法，所以也叫 静态多态，算不上真正的多态")]),n._v("。所以，一般说的多态都是运行时的多态。")]),n._v(" "),t("li",[n._v("运行时多态： 由于 方法重写，所以想要确定引用变量所调用的方法的入口，必须根据运行时的引用变量所指向的实例对象来确定。从而使得同一个引用变量调用同一个方法，但不同的实例对象表现出不同的行为。再简单点来说，就是在运行时，可以通过指向基类的指针，来调用实现子类中的方法。")])]),n._v(" "),t("p",[n._v("下面讲的多态都是指 运行时的多态。")]),n._v(" "),t("p",[t("strong",[n._v("多态的定义")]),n._v("： 指允许不同类的对象对同一消息做出不同的响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）；")]),n._v(" "),t("p",[n._v("上面的定义参考了网上的说法，定义中的不同类，都是由同一个基类扩展而来。")]),n._v(" "),t("p",[t("strong",[n._v("多态的好处：")])]),n._v(" "),t("ul",[t("li",[t("strong",[n._v("可替换性")]),n._v("（substitutability）。多态对已存在代码具有可替换性。例如，draw函数对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。")]),n._v(" "),t("li",[t("strong",[n._v("可扩充性")]),n._v("（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。")]),n._v(" "),t("li",[t("strong",[n._v("接口性")]),n._v("（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。")]),n._v(" "),t("li",[t("strong",[n._v("灵活性")]),n._v("（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。")]),n._v(" "),t("li",[t("strong",[n._v("简化性")]),n._v("（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。")])]),n._v(" "),t("p",[t("strong",[n._v("java的多态性三要素：")])]),n._v(" "),t("ul",[t("li",[n._v("继承；")]),n._v(" "),t("li",[n._v("重写；")]),n._v(" "),t("li",[n._v("父类的引用指向子类的引用")])]),n._v(" "),t("p",[t("strong",[n._v("多态性的实现")]),n._v("： 依靠动态绑定；")]),n._v(" "),t("p",[t("strong",[n._v("绑定")]),n._v("： 将一个方法调用与方法主体关联起来。\n"),t("strong",[n._v("前期绑定")]),n._v("： 在程序执行前绑定，由编译器和链接程序完成，C语言的函数调用便是前期绑定。\n"),t("strong",[n._v("动态绑定")]),n._v("： 也称 "),t("strong",[n._v("后期绑定")]),n._v("。在运行时，根据具体的对象类型进行方法调用绑定。除了"),t("code",[n._v("static")]),n._v("方法、"),t("code",[n._v("final")]),n._v("方法（"),t("code",[n._v("private")]),n._v("方法也是final方法），其他方法都是动态绑定；")]),n._v(" "),t("h2",{attrs:{id:"二、方法重写-与-隐藏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、方法重写-与-隐藏"}},[n._v("#")]),n._v(" 二、方法重写 与 隐藏")]),n._v(" "),t("p",[t("strong",[n._v("方法重写")]),n._v("： 就是子类中覆盖了从父类继承下来的方法（不是所有的父类方法都可以覆盖），从而使得通过父类的引用来调用重写后的方法。也就是说，父类类型与子类类型只保留重写后的方法。")]),n._v(" "),t("p",[t("strong",[n._v("隐藏")]),n._v("： 覆盖是相对重写而言的。当子类中出现与父类相同的方法时，重写是子类与父类只保持一份，但方法隐藏则是子类与父类各自独立保持一份，也就两份。从父类继承下来的成员中，除了部分方法是可以重写外，其余成员都是隐藏，如变量、内部类、静态方法等。")]),n._v(" "),t("p",[t("strong",[n._v("注意")]),n._v("： final方法既不能重写，也不能隐藏。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class ParentClass{\n    public int a = 5;\n    protected final String name = "parentClass";\n    public final void finalMethod() {//final方法，子类既不能重写，也不能隐藏\n        System.out.println("final方法");\n    }\n    public static void monday() {//静态方法\n        System.out.println("父类ParentClass的monday()方法");\n    }\n    public void count() {//可继承的成员方法\n        System.out.println("父类ParentClass的count()方法");\n    }\n    class InnerClass{//内部类\n        public InnerClass() {\n            System.out.println("父类ParentClass的内部类");\n        }\n    }\n}\nclass ChildClass extends ParentClass{\n    public int a = 5;\n    protected final String name = "ChildClass";\n    /*//编译不通过\n     * public final void finalMethod() {\n        System.out.println("final方法");\n    }*/\n    public static void monday() {//静态方法\n        System.out.println("子类ChildClass的monday()方法");\n    }\n    public void count() {//可继承的成员方法\n        System.out.println("子类ChildClass的count()方法");\n    }\n    class InnerClass{//内部类\n        public InnerClass() {\n            System.out.println("子类ChildClass的内部类");\n        }\n    }   \n}\npublic class MyTest {\n    public static void main(String[] args) {\n        ChildClass child = new ChildClass2();\n        ParentClass parent = child; //类型上转\n        System.out.println("---------------变量的隐藏测试-----------------");\n        child.a = 10;\n        System.out.println("parent.a： "+parent.a);\n        System.out.println("child.a： "+child.a);\n        System.out.println("\\n---------------静态方法的隐藏测试-----------------");\n        parent.monday();\n        child.monday();\n        System.out.println("\\n---------------方法的重写测试-----------------");\n        parent.count();\n        child.count();\n        System.out.println("\\n---------------内部类的隐藏测试-----------------");\n        ParentClass.InnerClass pa = parent.new InnerClass();\n        ChildClass.InnerClass ch = child.new InnerClass();\n    }\n}\n')])])]),t("blockquote",[t("p",[n._v("---------------变量的隐藏测试-----------------\nparent.a： 5\nchild.a： 10\n---------------静态方法的隐藏测试-----------------\n父类ParentClass的monday()方法\n子类ChildClass的monday()方法\n---------------方法的重写测试-----------------\n子类ChildClass的count()方法\n子类ChildClass的count()方法\n--------------内部类的隐藏测试-----------------\n父类ParentClass的内部类\n子类ChildClass的内部类")])]),n._v(" "),t("p",[n._v("上面的例子中，只有"),t("code",[n._v("count()")]),n._v("方法是被重写了，父类类型与子类类型只保持重写后的方法，而其他成员都是隐藏，父类类型保持一份，子类类型也保持一份。\n"),t("strong",[n._v("方法重写的条件")])]),n._v(" "),t("ul",[t("li",[n._v("重写的方法是子类从父类继承下来的实例方法，不能是静态方法")]),n._v(" "),t("li",[n._v("子类重写后的方法的 返回类型 必须是 原父类方法的返回类型的可替换类型")]),n._v(" "),t("li",[n._v("子类重写后的方法的访问权限 不能比 原父类方法的访问权限低；")]),n._v(" "),t("li",[n._v("子类重写后的方不能比父类方法抛出更多的异常；")]),n._v(" "),t("li",[n._v("当重写泛型方法时，先进行类型擦除。再按照上面的4个小点，重写类型擦除后的方法;")])]),n._v(" "),t("p",[t("strong",[n._v("可替换类型补充：")])]),n._v(" "),t("ul",[t("li",[n._v("对于返回类型是基本类型、void，重写方法的返回类型必须是一样；")]),n._v(" "),t("li",[n._v("对于返回类型是引用类型，返回类型可替换成该类型的 子类型;")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class ParentClass{//父类\n    public int count() {//\n        return 0;\n    }\n    Object method() {\n        return "aa";\n    }\n    <T extends ParentClass> T getValue(T t) {//泛型方法\n        System.out.println();\n        return t;\n    }\n}\nclass ChildClass extends ParentClass{//子类\n    public int count() {//重写count()方法，由于返回类型是基本类型，不能变，必须是一致\n        return 0;\n    }\n    public String method() {//重写method()：访问权限增大，返回类型是Object的子类String\n        return "aa";\n    }\n    ChildClass getValue(ParentClass ch) {//重写泛型方法getValue()\n        return null;\n    }\n}\n')])])]),t("p",[n._v("解析一下此例子中的泛型方法重写，父类中的泛型方法"),t("code",[n._v("getValue()")]),n._v("进行类型擦除后，是：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("ParentClass getValue(ParentClass t){\n    return null;\n}\n")])])]),t("p",[n._v("所以，子类"),t("code",[n._v("ChildClass")]),n._v("的方法重写是合理的。")])])}),[],!1,null,null,null);t.default=l.exports}}]);