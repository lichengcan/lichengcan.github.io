(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{442:function(n,a,e){"use strict";e.r(a);var t=e(2),r=Object(t.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"concurrenthashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[n._v("#")]),n._v(" ConcurrentHashMap")]),n._v(" "),a("p",[a("code",[n._v("ConcurrentHashMap")]),n._v("是Java中的一种线程安全的哈希表实现，它允许多个线程同时读取其中的数据，而不需要进行显式的锁定。它是"),a("code",[n._v("HashMap")]),n._v("的线程安全版本，提供了高并发性能和可靠的操作。"),a("code",[n._v("ConcurrentHashMap")]),n._v("的主要特点包括：")]),n._v(" "),a("ol",[a("li",[a("strong",[n._v("线程安全")]),n._v("："),a("code",[n._v("ConcurrentHashMap")]),n._v("是线程安全的，多个线程可以同时对其进行读取操作，而不会发生冲突。")]),n._v(" "),a("li",[a("strong",[n._v("分段锁")]),n._v("：它将数据分成多个段（默认为16个），每个段内部都有自己的锁。这意味着不同的线程可以并行地访问不同的段，从而提高了并发性能。")]),n._v(" "),a("li",[a("strong",[n._v("支持高并发")]),n._v("：由于分段锁的使用，"),a("code",[n._v("ConcurrentHashMap")]),n._v("在高并发环境下表现出色，允许多个线程同时执行读取和写入操作。")]),n._v(" "),a("li",[a("strong",[n._v("扩展性")]),n._v("："),a("code",[n._v("ConcurrentHashMap")]),n._v("支持动态扩展，当需要增加段的数量时，它可以自动扩展以提供更多的并发性能。")]),n._v(" "),a("li",[a("strong",[n._v("不允许null键或值")]),n._v("："),a("code",[n._v("ConcurrentHashMap")]),n._v("不允许存储null键或值，因为这可能会引起不确定的行为。")])]),n._v(" "),a("h2",{attrs:{id:"特点举例体现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点举例体现"}},[n._v("#")]),n._v(" 特点举例体现")]),n._v(" "),a("h3",{attrs:{id:"线程不安全问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程不安全问题"}},[n._v("#")]),n._v(" 线程不安全问题")]),n._v(" "),a("p",[n._v("使用 "),a("code",[n._v("ConcurrentHashMap")]),n._v(" 可以避免多个线程同时写入或读取数据导致的线程不安全问题。")]),n._v(" "),a("h4",{attrs:{id:"hashmap不安全、concurrenthashmap安全的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap不安全、concurrenthashmap安全的情况"}},[n._v("#")]),n._v(" HashMap不安全、ConCurrentHashMap安全的情况")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('import java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class HashMapVsConcurrentHashMapExample {\n\n    public static void main(String[] args) {\n        // 使用HashMap\n        Map<String, Integer> hashMap = new HashMap<>();\n\n        Runnable hashMapTask = () -> {\n            for (int i = 0; i < 10000; i++) {\n                String key = "key";\n                if (hashMap.containsKey(key)) {\n                    hashMap.put(key, hashMap.get(key) + 1);\n                } else {\n                    hashMap.put(key, 1);\n                }\n            }\n        };\n\n        // 使用ConcurrentHashMap\n        Map<String, Integer> concurrentHashMap = new ConcurrentHashMap<>();\n\n        Runnable concurrentHashMapTask = () -> {\n            for (int i = 0; i < 10000; i++) {\n                String key = "key";\n                concurrentHashMap.merge(key, 1, Integer::sum);\n            }\n        };\n\n        Thread thread1 = new Thread(hashMapTask);\n        Thread thread2 = new Thread(hashMapTask);\n        Thread thread3 = new Thread(concurrentHashMapTask);\n        Thread thread4 = new Thread(concurrentHashMapTask);\n\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n\n        try {\n            thread1.join();\n            thread2.join();\n            thread3.join();\n            thread4.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println("HashMap result: " + hashMap.get("key"));\n        System.out.println("ConcurrentHashMap result: " + concurrentHashMap.get("key"));\n    }\n}\n\n')])])]),a("h4",{attrs:{id:"concurrenthashmap-不保证原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-不保证原子性"}},[n._v("#")]),n._v(" "),a("code",[n._v("ConcurrentHashMap")]),n._v(" 不保证原子性")]),n._v(" "),a("ol",[a("li",[a("strong",[n._v("线程安全的操作")]),n._v("："),a("code",[n._v("ConcurrentHashMap")]),n._v(" 提供了线程安全的操作，意味着多个线程可以同时对其进行读取和写入操作，而不会导致数据损坏或不一致。这是因为 "),a("code",[n._v("ConcurrentHashMap")]),n._v(" 内部采用了锁机制，分段锁，CAS 操作等，以确保多线程安全访问。")]),n._v(" "),a("li",[a("strong",[n._v("不保证原子性")]),n._v("：虽然 "),a("code",[n._v("ConcurrentHashMap")]),n._v(" 是线程安全的，但它并不保证多个线程同时操作相同键时的原子性。具体来说，"),a("code",[n._v("ConcurrentHashMap")]),n._v(" 的某些操作可能不是原子的。在多线程环境下，如果多个线程同时操作相同的键，例如递增一个键的值，由于该操作不是原子的，就有可能导致竞争条件，即多个线程之间相互竞争修改相同键的值，这可能导致结果不确定或不符合预期。")]),n._v(" "),a("li",[n._v("要保证多个线程同时操作相同键的原子性，需要使用额外的同步机制，例如 "),a("code",[n._v("synchronized")]),n._v(" 块或原子类（如 "),a("code",[n._v("AtomicInteger")]),n._v("）。这些机制可以确保对键的操作是原子的，不会发生竞争条件，从而获得正确的结果。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('public static void main(String[] args) {\n    final Map<String, Integer> map = new ConcurrentHashMap<>();\n\n    Runnable task = () -> {\n        for (int i = 0; i < 10000; i++) {\n            // 多个线程同时向ConcurrentHashMap添加元素\n            String key = "key";\n            //这里引入synchronized来解决竞争条件\n            //因为进行+1的操作是需要先取值、加一、赋值，ConcurrentHashMap提供了线程安全的操作，但是不能保证多个线程同时操作相同键时的原子性\n            map.put(key, map.getOrDefault(key, 0) + 1);\n        }\n    };\n\n    Thread thread1 = new Thread(task);\n    Thread thread2 = new Thread(task);\n\n    thread1.start();\n    thread2.start();\n\n    try {\n        thread1.join();\n        thread2.join();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    // 打印最终结果\n    System.out.println("Final value for \'key\': " + map.get("key"));\n}\n')])])]),a("h4",{attrs:{id:"如何解决concurrenthashmap不保证原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决concurrenthashmap不保证原子性"}},[n._v("#")]),n._v(" 如何解决ConcurrentHashMap不保证原子性")]),n._v(" "),a("h5",{attrs:{id:"使用synchronized"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用synchronized"}},[n._v("#")]),n._v(" 使用synchronized")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('String key = "key";\nsynchronized(key){\n\tmap.put(key, map.getOrDefault(key, 0) + 1);\n}\n')])])]),a("h5",{attrs:{id:"使用atomicinteger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用atomicinteger"}},[n._v("#")]),n._v(" 使用AtomicInteger")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('import java.util.concurrent.atomic.AtomicInteger;\n\npublic class SafeHashMapExample {\n\n    public static void main(String[] args) {\n        final AtomicInteger atomicValue = new AtomicInteger(0);\n\n        Runnable task = () -> {\n            for (int i = 0; i < 10000; i++) {\n                atomicValue.incrementAndGet();\n            }\n        };\n\n        Thread thread1 = new Thread(task);\n        Thread thread2 = new Thread(task);\n\n        thread1.start();\n        thread2.start();\n\n        try {\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // 打印最终结果\n        System.out.println("Final value: " + atomicValue.get());\n    }\n}\n')])])]),a("h5",{attrs:{id:"使用concurrenthashmap-merge-key-1-integer-sum-安全的原子操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用concurrenthashmap-merge-key-1-integer-sum-安全的原子操作"}},[n._v("#")]),n._v(" 使用concurrentHashMap.merge(key, 1, Integer::sum); 安全的原子操作")]),n._v(" "),a("h3",{attrs:{id:"并发修改异常问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发修改异常问题"}},[n._v("#")]),n._v(" 并发修改异常问题")]),n._v(" "),a("p",[n._v("ConcurrentHashMap"),a("code",[n._v("允许在遍历时修改映射，而不会引发")]),n._v("ConcurrentModificationException` 异常。")]),n._v(" "),a("h3",{attrs:{id:"数据不一致性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据不一致性问题"}},[n._v("#")]),n._v(" 数据不一致性问题")]),n._v(" "),a("p",[a("code",[n._v("ConcurrentHashMap")]),n._v(" 提供了同步机制，确保多线程同时修改时数据一致性。")]),n._v(" "),a("h3",{attrs:{id:"性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能问题"}},[n._v("#")]),n._v(" 性能问题")]),n._v(" "),a("p",[a("code",[n._v("ConcurrentHashMap")]),n._v(" 采用分段锁机制，可以在高并发情况下提供较好的性能。")]),n._v(" "),a("h3",{attrs:{id:"死锁可能性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁可能性问题"}},[n._v("#")]),n._v(" 死锁可能性问题")]),n._v(" "),a("p",[a("code",[n._v("ConcurrentHashMap")]),n._v(" 的分段锁机制可以减少死锁的可能性，因为每个段独立加锁，减小了锁的竞争范围。")]),n._v(" "),a("p",[n._v("此问题不容易直接演示，因为 "),a("code",[n._v("ConcurrentHashMap")]),n._v(" 的设计旨在降低死锁风险，但不保证绝对不会发生。在复杂应用中，需要注意死锁的可能性并谨慎设计。")]),n._v(" "),a("h3",{attrs:{id:"concurrenthashmap-put源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-put源码"}},[n._v("#")]),n._v(" ConCurrentHashMap-put源码")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                if (casTabAt(tab, i, null,\n                             new Node<K,V>(hash, key, value, null)))\n                    break;                   // no lock when adding to empty bin\n            }\n            else if ((fh = f.hash) == MOVED)\n                tab = helpTransfer(tab, f);\n            else {\n                V oldVal = null;\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key,\n                                                              value, null);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount);\n        return null;\n    }\n")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);