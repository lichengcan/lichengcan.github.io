(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{444:function(e,v,_){"use strict";_.r(v);var t=_(2),n=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"_1-简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1. 简介")]),e._v(" "),v("p",[e._v("CLH 同步队列是一个 FIFO "),v("strong",[e._v("双向")]),e._v("队列，AQS 依赖它来完成同步状态的管理：")]),e._v(" "),v("ul",[v("li",[e._v("当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程")]),e._v(" "),v("li",[e._v("当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。")])]),e._v(" "),v("h1",{attrs:{id:"_2-node"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-node"}},[e._v("#")]),e._v(" 2. Node")]),e._v(" "),v("p",[e._v("在 CLH 同步队列中，"),v("strong",[e._v("一个节点（Node），表示一个线程")]),e._v("，它保存着线程的引用（"),v("code",[e._v("thread")]),e._v("）、状态（"),v("code",[e._v("waitStatus")]),e._v("）、前驱节点（"),v("code",[e._v("prev")]),e._v("）、后继节点（"),v("code",[e._v("next")]),e._v("）。其定义如下：")]),e._v(" "),v("blockquote",[v("p",[e._v("Node 是 AbstractQueuedSynchronizer 的内部静态类。")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("static final class Node {\n\n    // 共享\n    static final Node SHARED = new Node();\n    // 独占\n    static final Node EXCLUSIVE = null;\n\n    /**\n     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态\n     */\n    static final int CANCELLED =  1;\n    /**\n     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行\n     */\n    static final int SIGNAL    = -1;\n    /**\n     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中\n     */\n    static final int CONDITION = -2;\n    /**\n     * 表示下一次共享式同步状态获取，将会无条件地传播下去\n     */\n    static final int PROPAGATE = -3;\n\n    /** 等待状态 */\n    volatile int waitStatus;\n\n    /** 前驱节点，当节点添加到同步队列时被设置（尾部添加） */\n    volatile Node prev;\n\n    /** 后继节点 */\n    volatile Node next;\n\n    /** 等待队列中的后续节点。如果当前节点是共享的，那么字段将是一个 SHARED 常量，也就是说节点类型（独占和共享）和等待队列中的后续节点共用同一个字段 */\n    Node nextWaiter;\n    \n    /** 获取同步状态的线程 */\n    volatile Thread thread;\n\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n\n    final Node predecessor() throws NullPointerException {\n        Node p = prev;\n        if (p == null)\n            throw new NullPointerException();\n        else\n            return p;\n    }\n\n    Node() { // Used to establish initial head or SHARED marker\n    }\n\n    Node(Thread thread, Node mode) { // Used by addWaiter\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n    \n}\n")])])]),v("ul",[v("li",[v("p",[v("code",[e._v("waitStatus")]),e._v(" 字段，等待状态，用来控制线程的阻塞和唤醒，并且可以避免不必要的调用LockSupport的 "),v("code",[e._v("#park(...)")]),e._v(" 和 "),v("code",[e._v("#unpark(...)")]),e._v(" 方法。。目前有 "),v("strong",[e._v("4")]),e._v(" 种："),v("code",[e._v("CANCELLED")]),e._v(" "),v("code",[e._v("SIGNAL")]),e._v(" "),v("code",[e._v("CONDITION")]),e._v(" "),v("code",[e._v("PROPAGATE")]),e._v(" 。")]),e._v(" "),v("ul",[v("li",[e._v("实际上，有第 "),v("strong",[e._v("5")]),e._v(" 种，"),v("code",[e._v("INITAL")]),e._v(" ，值为 0 ，初始状态。")]),e._v(" "),v("li",[e._v("🙂 胖友请认真看下每个等待状态代表的含义，它不仅仅指的是 Node "),v("strong",[e._v("自己")]),e._v("的线程的等待状态，也可以是"),v("strong",[e._v("下一个")]),e._v("节点的线程的等待状态。")])])]),e._v(" "),v("li",[v("p",[e._v("CLH 同步队列，结构图如下：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://s2.loli.net/2023/12/26/6JwGpC4dzMUiOl3.png",alt:""}})]),e._v(" "),v("ul",[v("li",[v("code",[e._v("prev")]),e._v(" 和 "),v("code",[e._v("next")]),e._v(" 字段，是 "),v("strong",[e._v("AbstractQueuedSynchronizer")]),e._v(" 的字段，分别指向同步队列的头和尾。")]),e._v(" "),v("li",[v("code",[e._v("head")]),e._v(" 和 "),v("code",[e._v("tail")]),e._v(" 字段，分别指向 Node 节点的"),v("strong",[e._v("前一个")]),e._v("和"),v("strong",[e._v("后一个")]),e._v(" Node 节点，从而实现"),v("strong",[e._v("链式双向队列")]),e._v("。再配合上 "),v("code",[e._v("prev")]),e._v(" 和 "),v("code",[e._v("next")]),e._v(" 字段，快速定位到同步队列的头尾。")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("thread")]),e._v(" 字段，Node 节点对应的"),v("strong",[e._v("线程 Thread")]),e._v(" 。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("nextWaiter")]),e._v(" 字段，Node 节点获取同步状态的"),v("strong",[e._v("模型( Mode )")]),e._v("。"),v("code",[e._v("#tryAcquire(int args)")]),e._v(" 和 "),v("code",[e._v("#tryAcquireShared(int args)")]),e._v(" 方法，分别是"),v("strong",[e._v("独占式")]),e._v("和"),v("strong",[e._v("共享式")]),e._v("获取同步状态。在获取失败时，它们"),v("strong",[e._v("都会")]),e._v("调用 "),v("code",[e._v("#addWaiter(Node mode)")]),e._v(" 方法"),v("strong",[e._v("入队")]),e._v("。而 "),v("code",[e._v("nextWaiter")]),e._v(" 就是用来表示是哪种模式：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("SHARED")]),e._v(" "),v("strong",[e._v("静态 + 不可变")]),e._v("字段，枚举"),v("strong",[e._v("共享")]),e._v("模式。")]),e._v(" "),v("li",[v("code",[e._v("EXCLUSIVE")]),e._v(" "),v("strong",[e._v("静态 + 不可变")]),e._v("字段，枚举"),v("strong",[e._v("独占")]),e._v("模式。")]),e._v(" "),v("li",[v("code",[e._v("#isShared()")]),e._v(" 方法，判断是否为共享式获取同步状态。")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("#predecessor()")]),e._v(" 方法，获得 Node 节点的"),v("strong",[e._v("前一个")]),e._v(" Node 节点。在方法的内部，"),v("code",[e._v("Node p = prev")]),e._v(" 的本地拷贝，是为了避免并发情况下，"),v("code",[e._v("prev")]),e._v(" 判断完 "),v("code",[e._v("== null")]),e._v(" 时，恰好被修改，从而保证线程安全。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("构造方法")]),e._v("有 "),v("strong",[e._v("3")]),e._v(" 个，分别是：")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("#Node()")]),e._v(" 方法：用于 "),v("code",[e._v("SHARED")]),e._v(" 的创建。")])]),e._v(" "),v("li",[v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("#Node(Thread thread, Node mode)\n")])])]),v("p",[e._v("方法：用于")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("#addWaiter(Node mode)\n")])])]),v("p",[e._v("方法。")]),e._v(" "),v("ul",[v("li",[e._v("从 "),v("code",[e._v("mode")]),e._v(" 方法参数中，我们也可以看出它代表获取同步状态的"),v("strong",[e._v("模式")]),e._v("。")]),e._v(" "),v("li",[e._v("在本文中，我们会看到这个构造方法的使用。")])])]),e._v(" "),v("li",[v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("#Node(Thread thread, int waitStatus)\n")])])]),v("p",[e._v("方法，用于")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("#addConditionWaiter()\n")])])]),v("p",[e._v("方法。")]),e._v(" "),v("ul",[v("li",[e._v("在本文中，不会使用，所以解释暂时省略。")])])])])])]),e._v(" "),v("h1",{attrs:{id:"_3-入列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-入列"}},[e._v("#")]),e._v(" 3. 入列")]),e._v(" "),v("p",[e._v("学了数据结构的我们，CLH 队列入列是再简单不过了：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("tail")]),e._v(" 指向新节点。")]),e._v(" "),v("li",[e._v("新节点的 "),v("code",[e._v("prev")]),e._v(" 指向当前最后的节点。")]),e._v(" "),v("li",[e._v("当前最后一个节点的 "),v("code",[e._v("next")]),e._v(" 指向当前节点。")])]),e._v(" "),v("p",[e._v("过程图如下：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://s2.loli.net/2023/12/26/n8QIioUfCR4SPBc.png",alt:""}})]),e._v(" "),v("p",[e._v("但是，实际上，入队逻辑实现的 "),v("code",[e._v("#addWaiter(Node)")]),e._v(" 方法，需要考虑"),v("strong",[e._v("并发")]),e._v("的情况。它通过 "),v("strong",[e._v("CAS")]),e._v(" 的方式，来保证正确的添加 Node 。代码如下：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v(" 1: private Node addWaiter(Node mode) {\n 2:     // 新建节点\n 3:     Node node = new Node(Thread.currentThread(), mode);\n 4:     // 记录原尾节点\n 5:     Node pred = tail;\n 6:     // 快速尝试，添加新节点为尾节点\n 7:     if (pred != null) {\n 8:         // 设置新 Node 节点的尾节点为原尾节点\n 9:         node.prev = pred;\n10:         // CAS 设置新的尾节点\n11:         if (compareAndSetTail(pred, node)) {\n12:             // 成功，原尾节点的下一个节点为新节点\n13:             pred.next = node;\n14:             return node;\n15:         }\n16:     }\n17:     // 失败，多次尝试，直到成功\n18:     enq(node);\n19:     return node;\n20: }\n")])])]),v("ul",[v("li",[v("p",[e._v("第 3 行：创建新节点 "),v("code",[e._v("node")]),e._v(" 。在创建的构造方法，"),v("code",[e._v("mode")]),e._v(" 方法参数，传递获取同步状态的模式。")])]),e._v(" "),v("li",[v("p",[e._v("第 5 行：记录"),v("strong",[e._v("原")]),e._v("尾节点 "),v("code",[e._v("tail")]),e._v(" 。")])]),e._v(" "),v("li",[v("p",[e._v("在下面的代码，会分成 "),v("strong",[e._v("2")]),e._v(" 部分：")]),e._v(" "),v("ul",[v("li",[e._v("第 6 至 16 行："),v("strong",[e._v("快速")]),e._v("尝试，添加新节点为尾节点。")]),e._v(" "),v("li",[e._v("第 18 行：添加失败，"),v("strong",[e._v("多次")]),e._v("尝试，直到成功添加。")])])]),e._v(" "),v("li",[v("p",[e._v("========== 第 "),v("strong",[e._v("1")]),e._v(" 部分 ==========")])]),e._v(" "),v("li",[v("p",[e._v("第 7 行：当"),v("strong",[e._v("原")]),e._v("尾节点非空，才执行"),v("strong",[e._v("快速")]),e._v("尝试的逻辑。在下面的 "),v("code",[e._v("#enq(Node node)")]),e._v(" 方法中，我们会看到，"),v("strong",[e._v("首")]),e._v("节点未初始化的时，"),v("code",[e._v("head")]),e._v(" 和 "),v("code",[e._v("tail")]),e._v(" 都为空。")])]),e._v(" "),v("li",[v("p",[e._v("第 9 行：设置"),v("strong",[e._v("新")]),e._v("节点的"),v("strong",[e._v("尾")]),e._v("节点为"),v("strong",[e._v("原")]),e._v("尾节点。")])]),e._v(" "),v("li",[v("p",[e._v("第 11 行：调用 "),v("code",[e._v("#compareAndSetTail(Node expect, Node update)")]),e._v(" 方法，使用 "),v("strong",[e._v("Unsafe")]),e._v(" 来 "),v("strong",[e._v("CAS")]),e._v(" 设置"),v("strong",[e._v("尾")]),e._v("节点 "),v("code",[e._v("tail")]),e._v(" 为"),v("strong",[e._v("新")]),e._v("节点。代码如下：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('private static final Unsafe unsafe = Unsafe.getUnsafe();\n\nprivate static final long tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("tail"));  // 这块代码，实际在 static 代码块，此处为了方便理解，做了简化。\n\nprivate final boolean compareAndSetTail(Node expect, Node update) {\n    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);\n}\n')])])])]),e._v(" "),v("li",[v("p",[e._v("第 13 行：添加"),v("strong",[e._v("成功")]),e._v("，最终，将"),v("strong",[e._v("原")]),e._v("尾节点的下一个节点为"),v("strong",[e._v("新")]),e._v("节点。")])]),e._v(" "),v("li",[v("p",[e._v("第 14 行：返回"),v("strong",[e._v("新")]),e._v("节点。")])]),e._v(" "),v("li",[v("p",[e._v("如果添加"),v("strong",[e._v("失败")]),e._v("，因为存在多线程并发的情况，此时需要执行【第 18 行】的代码。")])]),e._v(" "),v("li",[v("p",[e._v("========== 第 "),v("strong",[e._v("2")]),e._v(" 部分 ==========")])]),e._v(" "),v("li",[v("p",[e._v("调用 "),v("code",[e._v("#enq(Node node)")]),e._v(" 方法，"),v("strong",[e._v("多次")]),e._v("尝试，直到成功添加。代码如下：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v(" 1: private Node enq(final Node node) {\n 2:     // 多次尝试，直到成功为止\n 3:     for (;;) {\n 4:         // 记录原尾节点\n 5:         Node t = tail;\n 6:         // 原尾节点不存在，创建首尾节点都为 new Node()\n 7:         if (t == null) {\n 8:             if (compareAndSetHead(new Node()))\n 9:                 tail = head;\n10:         // 原尾节点存在，添加新节点为尾节点\n11:         } else {\n12:             //设置为尾节点\n13:             node.prev = t;\n14:             // CAS 设置新的尾节点\n15:             if (compareAndSetTail(t, node)) {\n16:                 // 成功，原尾节点的下一个节点为新节点\n17:                 t.next = node;\n18:                 return t;\n19:             }\n20:         }\n21:     }\n22: }\n")])])]),v("ul",[v("li",[v("p",[e._v("第 3 行：“"),v("strong",[e._v("死")]),e._v("”循环，多次尝试，直到成功添加"),v("strong",[e._v("为止")]),e._v("【第 18 行】。")])]),e._v(" "),v("li",[v("p",[e._v("第 5 行：记录原尾节点 "),v("code",[e._v("t")]),e._v(" 。🙂 和 "),v("code",[e._v("#addWaiter(Node node)")]),e._v(" 方法的【第 5 行】相同。")])]),e._v(" "),v("li",[v("p",[e._v("第 10 至 19 行：原尾节点存在，添加新节点为尾节点。🙂 和 "),v("code",[e._v("#addWaiter(Node node)")]),e._v(" 方法的【第 7 至 16 行】相同。")])]),e._v(" "),v("li",[v("p",[e._v("第 6 至 9 行：原尾节点不存在，创建"),v("strong",[e._v("首尾")]),e._v("节点都为 "),v("strong",[e._v("new Node()")]),e._v(" 。"),v("strong",[e._v("注意")]),e._v("，此时修改的"),v("strong",[e._v("首尾")]),e._v("节点是重新创建( "),v("code",[e._v("new Node()")]),e._v(" )的，而不是"),v("strong",[e._v("新节点")]),e._v("！")]),e._v(" "),v("ul",[v("li",[e._v("这里，笔者的理解是，通过这样的方式，初始化好同步队列的"),v("strong",[e._v("首尾")]),e._v("。另外，在 AbstractQueuedSynchronizer 的设计中，"),v("code",[e._v("head")]),e._v(" 字段，是一个“占位节点”(暂时没想到特别好的比喻)，代表"),v("strong",[e._v("最后一个")]),e._v("获得到同步状态的节点(线程)，实际它已经"),v("strong",[e._v("出列")]),e._v("，所以它的 "),v("code",[e._v("Node.next")]),e._v(" 才是"),v("strong",[e._v("真正")]),e._v("的队首。当然，同步队列的初始时，"),v("code",[e._v("new Node()")]),e._v(" 也是满足这个条件，因为有"),v("strong",[e._v("新的")]),e._v(" Node 进队列，"),v("strong",[e._v("目前就已经有线程获得到同步状态")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("#compareAndSetHead(Node update)")]),e._v(" 方法，使用 Unsafe 来 CAS 设置尾节点 "),v("code",[e._v("head")]),e._v(" 为新节点。代码如下：")])]),e._v(" "),v("p",[e._v("private static final Unsafe unsafe = Unsafe.getUnsafe();")]),e._v(" "),v("p",[e._v('private static final long headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField("head"));  // 这块代码，实际在 static 代码块，此处为了方便理解，做了简化。')]),e._v(" "),v("p",[e._v("private final boolean compareAndSetHead(Node update) {\nreturn unsafe.compareAndSwapObject(this, headOffset, null, update);\n}")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("注意")]),e._v("，第三个方法参数为 "),v("code",[e._v("null")]),e._v(" ，代表需要原 "),v("code",[e._v("head")]),e._v(" 为空才可以设置。🙂 和 "),v("code",[e._v("#compareAndSetTail(Node expect, Node update)")]),e._v(" 方法，类似。")])])])])])]),e._v(" "),v("h1",{attrs:{id:"_4-出列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-出列"}},[e._v("#")]),e._v(" 4. 出列")]),e._v(" "),v("h1",{attrs:{id:"_4-出列-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-出列-2"}},[e._v("#")]),e._v(" 4. 出列")]),e._v(" "),v("p",[e._v("CLH 同步队列遵循 FIFO，首节点的线程释放同步状态后，将会唤醒它的"),v("strong",[e._v("下一个")]),e._v("节点（"),v("code",[e._v("Node.next")]),e._v("）。而后继节点将会在获取同步状态成功时，将自己设置为首节点( "),v("code",[e._v("head")]),e._v(" )。")]),e._v(" "),v("p",[e._v("这个过程非常简单，"),v("code",[e._v("head")]),e._v(" 执行该节点并断开原首节点的 "),v("code",[e._v("next")]),e._v(" 和当前节点的 "),v("code",[e._v("prev")]),e._v(" 即可。注意，在这个过程是"),v("strong",[e._v("不需要使用 CAS 来保证")]),e._v("的，因为"),v("strong",[e._v("只有一个")]),e._v("线程，能够成功获取到同步状态。")]),e._v(" "),v("p",[e._v("过程图如下：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://s2.loli.net/2023/12/26/3q9hZGHoEDmVBAT.png",alt:""}})]),e._v(" "),v("p",[v("code",[e._v("#setHead(Node node)")]),e._v(" 方法，实现上述的"),v("strong",[e._v("出列")]),e._v("逻辑。代码如下：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("private void setHead(Node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}\n")])])]),v("blockquote",[v("p",[e._v("https://www.iocoder.cn/JUC/sike/aqs-1-clh/")])])])}),[],!1,null,null,null);v.default=n.exports}}]);