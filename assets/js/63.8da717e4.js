(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{481:function(e,t,l){"use strict";l.r(t);var v=l(2),o=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-反射"}},[e._v("#")]),e._v(" 1 反射")]),e._v(" "),t("p",[e._v("Java反射机制允许程序在运行时获取类的详细信息（如类名、属性、方法、构造器等）并进行操作，无需在编译期知道具体的类或对象。这为动态加载和操作类提供了强大的灵活性。")]),e._v(" "),t("p",[e._v("以下是一些主要的反射API类以及它们提供的关键方法：")]),e._v(" "),t("ol",[t("li",[t("p",[t("strong",[e._v("java.lang.Class")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v('Class<?> clazz = Class.forName("com.example.MyClass");')]),e._v("：通过类名字符串加载并返回指定类的Class对象。")]),e._v(" "),t("li",[t("code",[e._v("clazz.getDeclaredFields()")]),e._v("：返回该类及其所有超类中声明的所有字段，包括私有（private）字段。")]),e._v(" "),t("li",[t("code",[e._v("clazz.getDeclaredMethods()")]),e._v("：返回此Class对象表示的类或接口声明的所有方法，包括私有方法。")]),e._v(" "),t("li",[t("code",[e._v("clazz.getConstructors()")]),e._v("：返回表示此Class对象所表示的类的所有公共构造方法的Constructor对象数组。")]),e._v(" "),t("li",[t("code",[e._v("clazz.newInstance()")]),e._v("：创建并初始化这个Class对象所表示的类的一个新实例。前提是该类有一个无参数的构造函数。")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("java.lang.reflect.Field")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("field.setAccessible(true)")]),e._v("：允许访问私有成员变量。")]),e._v(" "),t("li",[t("code",[e._v("field.get(obj)")]),e._v("：获取指定对象obj上的此Field对象表示的字段值。")]),e._v(" "),t("li",[t("code",[e._v("field.set(obj, value)")]),e._v("：将给定对象obj上此Field对象表示的字段设置为指定的新值。")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("java.lang.reflect.Method")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("method.invoke(obj, args...)")]),e._v("：在指定的对象obj上调用此Method对象表示的方法，并传递给定的参数args，返回该方法的结果或者抛出异常。")]),e._v(" "),t("li",[t("code",[e._v("method.getParameterTypes()")]),e._v("：返回表示此方法的形参类型的数组。")]),e._v(" "),t("li",[t("code",[e._v("method.setAccessible(true)")]),e._v("：使私有方法也可以被调用。")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("java.lang.reflect.Constructor")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("constructor.newInstance(args...)")]),e._v("：使用给定参数创建并初始化此Constructor表示的类的新实例。")]),e._v(" "),t("li",[t("code",[e._v("constructor.getParameterTypes()")]),e._v("：返回一个类型数组，这些类型描述了此构造方法的形参。")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("AnnotatedElement接口")])]),e._v(" "),t("ul",[t("li",[e._v("这个接口由Class、Constructor、Field和Method类实现，提供了一系列用于获取注解的方法：\n"),t("ul",[t("li",[t("code",[e._v("getAnnotation(Class<T> annotationClass)")]),e._v("：获取该元素上存在的指定类型的注解。")]),e._v(" "),t("li",[t("code",[e._v("getAnnotations()")]),e._v("：返回该元素上所有的注解。")])])])])])]),e._v(" "),t("p",[e._v("此外，还有更多其他辅助方法，例如判断类是否实现了某个接口、获取类的父类、获取包信息等。反射机制强大而灵活，但过度使用可能会影响性能，因为它绕过了JVM的一些优化措施，所以在实际开发中应合理使用。")])])}),[],!1,null,null,null);t.default=o.exports}}]);