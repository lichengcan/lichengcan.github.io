(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{438:function(n,e,a){"use strict";a.r(e);var t=a(2),b=Object(t.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h3",{attrs:{id:"base64工具类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#base64工具类"}},[this._v("#")]),this._v(" Base64工具类")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("public final class Base64Util {\n\n    static private final int BASELENGTH = 128;\n    static private final int LOOKUPLENGTH = 64;\n    static private final int TWENTYFOURBITGROUP = 24;\n    static private final int EIGHTBIT = 8;\n    static private final int SIXTEENBIT = 16;\n    static private final int FOURBYTE = 4;\n    static private final int SIGN = -128;\n    static private final char PAD = '=';\n    static private final boolean fDebug = false;\n    static final private byte[] base64Alphabet = new byte[BASELENGTH];\n    static final private char[] lookUpBase64Alphabet = new char[LOOKUPLENGTH];\n\n    static {\n        for (int i = 0; i < BASELENGTH; ++i) {\n            base64Alphabet[i] = -1;\n        }\n        for (int i = 'Z'; i >= 'A'; i--) {\n            base64Alphabet[i] = (byte) (i - 'A');\n        }\n        for (int i = 'z'; i >= 'a'; i--) {\n            base64Alphabet[i] = (byte) (i - 'a' + 26);\n        }\n        for (int i = '9'; i >= '0'; i--) {\n            base64Alphabet[i] = (byte) (i - '0' + 52);\n        }\n        base64Alphabet['+'] = 62;\n        base64Alphabet['/'] = 63;\n        for (int i = 0; i <= 25; i++) {\n            lookUpBase64Alphabet[i] = (char) ('A' + i);\n        }\n        for (int i = 26, j = 0; i <= 51; i++, j++) {\n            lookUpBase64Alphabet[i] = (char) ('a' + j);\n        }\n        for (int i = 52, j = 0; i <= 61; i++, j++) {\n            lookUpBase64Alphabet[i] = (char) ('0' + j);\n        }\n        lookUpBase64Alphabet[62] = '+';\n        lookUpBase64Alphabet[63] = '/';\n    }\n\n    private static boolean isWhiteSpace(char octect) {\n        return (octect == 0x20 || octect == 0xd || octect == 0xa || octect == 0x9);\n    }\n\n    private static boolean isPad(char octect) {\n        return (octect == PAD);\n    }\n\n    private static boolean isData(char octect) {\n        return (octect < BASELENGTH && base64Alphabet[octect] != -1);\n    }\n\n    /**\n     * 将十六进制八位字节编码为Base64\n     *\n     * @param binaryData 包含二进制数据的数组\n     * @return 编码Base64字符串\n     */\n    public static String encode(byte[] binaryData) {\n        if (binaryData == null) {\n            return null;\n        }\n        int lengthDataBits = binaryData.length * EIGHTBIT;\n        if (lengthDataBits == 0) {\n            return \"\";\n        }\n        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n        int numberQuartet = fewerThan24bits != 0 ? numberTriplets + 1 : numberTriplets;\n        char[] encodedData = new char[numberQuartet * 4];\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        if (fDebug) {\n            System.out.println(\"number of triplets = \" + numberTriplets);\n        }\n        for (int i = 0; i < numberTriplets; i++) {\n            b1 = binaryData[dataIndex++];\n            b2 = binaryData[dataIndex++];\n            b3 = binaryData[dataIndex++];\n            if (fDebug) {\n                System.out.println(\"b1= \" + b1 + \", b2= \" + b2 + \", b3= \" + b3);\n            }\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n            if (fDebug) {\n                System.out.println(\"val2 = \" + val2);\n                System.out.println(\"k4   = \" + (k << 4));\n                System.out.println(\"vak  = \" + (val2 | (k << 4)));\n            }\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 & 0x3f];\n        }\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            if (fDebug) {\n                System.out.println(\"b1=\" + b1);\n                System.out.println(\"b1<<2 = \" + (b1 >> 2));\n            }\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex++] = PAD;\n            encodedData[encodedIndex++] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex++] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex++] = PAD;\n        }\n        return new String(encodedData);\n    }\n\n    /**\n     * 将Base64数据解码为八位字节\n     *\n     * @param encoded 包含Base64数据的字符串\n     * @return 包含解码数据的数组.\n     */\n    public static byte[] decode(String encoded) {\n        if (encoded == null) {\n            return null;\n        }\n        char[] base64Data = encoded.toCharArray();\n        //删除空白\n        int len = removeWhiteSpace(base64Data);\n        //应该可以被四整除\n        if (len % FOURBYTE != 0) {\n            return null;\n        }\n        int numberQuadruple = (len / FOURBYTE);\n        if (numberQuadruple == 0) {\n            return new byte[0];\n        }\n        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;\n        char d1 = 0, d2 = 0, d3 = 0, d4 = 0;\n        int i = 0;\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        byte[] decodedData = new byte[(numberQuadruple) * 3];\n        for (; i < numberQuadruple - 1; i++) {\n            if (!isData((d1 = base64Data[dataIndex++])) || !isData((d2 = base64Data[dataIndex++]))\n                    || !isData((d3 = base64Data[dataIndex++]))\n                    || !isData((d4 = base64Data[dataIndex++]))) {\n                return null;\n            }//没有数据直接返回null\n            b1 = base64Alphabet[d1];\n            b2 = base64Alphabet[d2];\n            b3 = base64Alphabet[d3];\n            b4 = base64Alphabet[d4];\n            decodedData[encodedIndex++] = (byte) (b1 << 2 | b2 >> 4);\n            decodedData[encodedIndex++] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            decodedData[encodedIndex++] = (byte) (b3 << 6 | b4);\n        }\n        if (!isData((d1 = base64Data[dataIndex++])) || !isData((d2 = base64Data[dataIndex++]))) {\n            return null;\n        }\n        b1 = base64Alphabet[d1];\n        b2 = base64Alphabet[d2];\n        d3 = base64Data[dataIndex++];\n        d4 = base64Data[dataIndex++];\n        if (!isData((d3)) || !isData((d4))) {\n            //检查是否为填充字符\n            if (isPad(d3) && isPad(d4)) {\n                if ((b2 & 0xf) != 0) {//最后四位应为0\n                    return null;\n                }\n                byte[] tmp = new byte[i * 3 + 1];\n                System.arraycopy(decodedData, 0, tmp, 0, i * 3);\n                tmp[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n                return tmp;\n            } else if (!isPad(d3) && isPad(d4)) {\n                b3 = base64Alphabet[d3];\n                if ((b3 & 0x3) != 0){//最后2位应为零\n                    return null;\n                }\n                byte[] tmp = new byte[i * 3 + 2];\n                System.arraycopy(decodedData, 0, tmp, 0, i * 3);\n                tmp[encodedIndex++] = (byte) (b1 << 2 | b2 >> 4);\n                tmp[encodedIndex] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n                return tmp;\n            } else {\n                return null;\n            }\n        } else { //No PAD e.g 3cQl\n            b3 = base64Alphabet[d3];\n            b4 = base64Alphabet[d4];\n            decodedData[encodedIndex++] = (byte) (b1 << 2 | b2 >> 4);\n            decodedData[encodedIndex++] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            decodedData[encodedIndex++] = (byte) (b3 << 6 | b4);\n        }\n        return decodedData;\n    }\n\n    /**\n     * 从包含编码Base64数据的MIME中删除空白\n     *\n     * @param data base64数据的字节数组（带空白）\n     * @return 新的长度\n     */\n    private static int removeWhiteSpace(char[] data) {\n        if (data == null) {\n            return 0;\n        }\n        int newSize = 0;\n        int len = data.length;\n        for (int i = 0; i < len; i++) {\n            if (!isWhiteSpace(data[i])) {\n                data[newSize++] = data[i];\n            }\n        }\n        return newSize;\n    }\n}\n\n")])])])])}),[],!1,null,null,null);e.default=b.exports}}]);