(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{430:function(a,t,v){"use strict";v.r(t);var _=v(2),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/JVM-001.jpg",alt:""}})]),a._v(" "),t("h1",{attrs:{id:"java程序是如何运行的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java程序是如何运行的"}},[a._v("#")]),a._v(" Java程序是如何运行的？")]),a._v(" "),t("h3",{attrs:{id:"_1-jdk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-jdk"}},[a._v("#")]),a._v(" 1 JDK")]),a._v(" "),t("ul",[t("li",[a._v("HotSpot JVM：JDK的默认虚拟机（Oracle）")]),a._v(" "),t("li",[a._v("Java编译器（javac）")]),a._v(" "),t("li",[a._v("Java运行时环境jre（Java命令）")]),a._v(" "),t("li",[a._v("等")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/lichengcan/lichengcan.github.io/assets/82929061/874596e9-f457-4f54-91fc-42470bf90286",alt:"image"}})]),a._v(" "),t("h4",{attrs:{id:"详细说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#详细说明"}},[a._v("#")]),a._v(" 详细说明")]),a._v(" "),t("ol",[t("li",[a._v("JDK中的Java编译器（"),t("code",[a._v("javac")]),a._v("）将Java源代码文件（.java文件）编译为字节码文件（.class文件）。编译器会检查源代码的语法和语义，然后将其转换为字节码形式。这些字节码文件包含了Java程序的中间表示，它们是平台无关的。")]),a._v(" "),t("li",[a._v("JRE（Java Runtime Environment）包括Java虚拟机（JVM）和Java类库。JRE是Java程序的运行时环境，它负责加载和执行字节码文件。当你运行Java程序时，JVM会加载字节码文件，并使用解释器或即时编译器（JIT Compiler）将字节码转换为特定平台的机器码。JVM还负责管理内存、垃圾回收和线程等运行时任务。")]),a._v(" "),t("li",[a._v("JVM将字节码转换为底层操作系统可执行的机器码。这个过程称为即时编译（Just-In-Time Compilation），其中JVM会根据代码的执行情况进行动态编译和优化。即时编译器将频繁执行的代码编译成本地机器码，以提高程序的执行性能。")]),a._v(" "),t("li",[a._v("生成的机器码是底层操作系统可执行的代码。操作系统负责加载和执行这些机器码，最终在计算机上运行Java程序。操作系统为Java程序提供了底层的硬件和系统资源访问能力。")])]),a._v(" "),t("blockquote",[t("p",[a._v("综上所述，JDK中的Java编译器将Java源代码编译为字节码文件，JVM和JRE负责加载和执行字节码，并将其转换为底层操作系统可执行的机器码。操作系统最终负责执行这些机器码，并运行Java程序。这个过程保证了Java程序的跨平台性和可移植性。")])]),a._v(" "),t("h3",{attrs:{id:"_2-垃圾回收机制-garbage-collection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-垃圾回收机制-garbage-collection"}},[a._v("#")]),a._v(" 2 垃圾回收机制 Garbage Collection")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/lichengcan/lichengcan.github.io/assets/82929061/d3d38ac7-4969-417d-b228-a8f84c291b80",alt:"image"}})]),a._v(" "),t("h3",{attrs:{id:"_3-序列化、反序列化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-序列化、反序列化"}},[a._v("#")]),a._v(" 3 序列化、反序列化")]),a._v(" "),t("ul",[t("li",[a._v("为了能在网络上传输、存储到文件中")]),a._v(" "),t("li",[a._v("为了进程间的通信")])]),a._v(" "),t("p",[a._v("序列化：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/lichengcan/lichengcan.github.io/assets/82929061/d6a7a87d-9bfa-4035-b567-84b7dd68d730",alt:"image"}})]),a._v(" "),t("ol",[t("li",[a._v("序列化是指将对象转换为可以在网络传输或存储中进行传递或持久化的格式")]),a._v(" "),t("li",[a._v("在序列化过程中，对象的状态（包括属性值和数据）被转换为字节流或其他可传输的格式")]),a._v(" "),t("li",[a._v("以便于跨系统、跨平台的数据交换和共享")])]),a._v(" "),t("p",[a._v("反序列化：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/lichengcan/lichengcan.github.io/assets/82929061/313f1bbb-376e-444e-a405-f5845a778cb3",alt:"image"}})]),a._v(" "),t("ol",[t("li",[a._v("序列化的逆过程，即将序列化后的数据重新转换为对象的过程")])]),a._v(" "),t("h4",{attrs:{id:"java-中的serializable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-中的serializable"}},[a._v("#")]),a._v(" java 中的Serializable")]),a._v(" "),t("ul",[t("li",[a._v("实现 "),t("code",[a._v("Serializable")]),a._v(" 接口是为了将对象进行序列化和反序列化")]),a._v(" "),t("li",[a._v("该对象的类和其所有可访问的字段都需要是可序列化的。")]),a._v(" "),t("li",[a._v("如果一个类中的某个字段不可序列化，可以使用 "),t("code",[a._v("transient")]),a._v(" 关键字标记该字段，使其在序列化过程中被忽略。")])]),a._v(" "),t("h3",{attrs:{id:"_1-如何判定哪些内存需要回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何判定哪些内存需要回收"}},[a._v("#")]),a._v(" 1 如何判定哪些内存需要回收")]),a._v(" "),t("p",[a._v("在Java虚拟机的堆中会存放着很多的对象，那么，我们需要回收垃圾的时候，是通过什么算法来判断哪些垃圾的生命周期已到，需要回收呢？接下来的几种算法将帮助你解决这几个问题。")]),a._v(" "),t("h4",{attrs:{id:"引用计数算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[a._v("#")]),a._v(" 引用计数算法")]),a._v(" "),t("p",[a._v("先讲讲第一个算法："),t("strong",[a._v("引用计数算法")]),a._v("。")]),a._v(" "),t("p",[a._v("其实，这个算法的思想非常的简单，一句话就是："),t("strong",[a._v("给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。")])]),a._v(" "),t("p",[a._v("这些简单的算法现在是否还被大量的使用呢，其实，现在用的已经不多，没有被使用的最主要的原因是他有一个很大的"),t("strong",[a._v("缺点")]),a._v("："),t("strong",[a._v("很难解决对象之间循环引用的问题")]),a._v("。")]),a._v(" "),t("p",[t("strong",[a._v("循环引用")]),a._v("：当A有B的引用，B又有A的引用的时候，这个时候，即使A和B对象都为null，这个时候，引用计数算法也不会将他们进行垃圾回收。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v(" 1/**\n 2 * @ClassName Test_02\n 3 * @Description\n 4 * @Author lichengcan\n 5 * @Date 2023/11/5 16:59\n 6 * @Version 1.0\n 7 **/\n 8public class Test_02 {\n 9\n10    public static void main(String[] args) {\n11        Instance instanceA = new Instance();\n12        Instance instanceB = new Instance();\n13\n14        instanceA.instance = instanceB;\n15        instanceB.instance = instanceA;\n16\n17        instanceA = null;\n18        instanceB = null;\n19\n20        System.gc();\n21\n22        Scanner scanner = new Scanner(System.in);\n23        scanner.next();\n24    }\n25}\n26\n27class Instance{\n28    public Object instance = null;\n29}\n")])])]),t("p",[a._v("如果使用的是"),t("strong",[a._v("引用计数算法")]),a._v("，这是不能被回收的，当然，现在的JVM是可以被回收的。")]),a._v(" "),t("h4",{attrs:{id:"可达性分析算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[a._v("#")]),a._v(" 可达性分析算法")]),a._v(" "),t("p",[a._v("这个算法的思想也是很简单的，这里有一个概念叫做"),t("strong",[a._v("可达性分析")]),a._v("，如果知道图的数据结构，这里可以把每一个对象当做图中的一个节点，我们把一个节点叫做"),t("strong",[a._v("GC Roots")]),a._v("，如果一个节点到"),t("strong",[a._v("GC Roots")]),a._v("没有任何的相连的路径，那么就说明这个节点不可达，也就是这个节点可以被回收。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/640.png",alt:""}})]),a._v(" "),t("p",[a._v("上面图中，虽然obj7、8、9相互引用，但是到GC Roots不可达，所以，这种对象也是会被当做垃圾收集的。")]),a._v(" "),t("p",[a._v("在Java中，可以作为"),t("code",[a._v("GC Roots")]),a._v("的对象包括以下几种：")]),a._v(" "),t("ul",[t("li",[a._v("虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象。")]),a._v(" "),t("li",[a._v("方法区中类静态属性引用的对象。")]),a._v(" "),t("li",[a._v("方法区中常量引用的对象。")]),a._v(" "),t("li",[a._v("本地方法栈中JNI（即一般说的Native方法）引用的对象。")])]),a._v(" "),t("h3",{attrs:{id:"_2-什么时候回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么时候回收"}},[a._v("#")]),a._v(" 2 什么时候回收")]),a._v(" "),t("p",[a._v("在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于“缓刑”阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程。")]),a._v(" "),t("h4",{attrs:{id:"step1-判断有没有必要执行finalize-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step1-判断有没有必要执行finalize-方法"}},[a._v("#")]),a._v(" step1：判断有没有必要执行finalize()方法")]),a._v(" "),t("ul",[t("li",[a._v("如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是"),t("strong",[a._v("此对象是否有必要执行"),t("code",[a._v("finalize()")]),a._v("方法")]),a._v("。")])]),a._v(" "),t("p",[a._v("另外，有两种情况都视为“"),t("strong",[a._v("没有必要执行")]),a._v("”：")]),a._v(" "),t("ul",[t("li",[a._v("对象没有覆盖finaliza()方法。")]),a._v(" "),t("li",[a._v("finalize()方法已经被虚拟机调用过。")])]),a._v(" "),t("h4",{attrs:{id:"step2-如何执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step2-如何执行"}},[a._v("#")]),a._v(" step2：如何执行")]),a._v(" "),t("p",[a._v("如果这个对象被判定为有必要执行"),t("code",[a._v("finalize()")]),a._v("方法，那么此对象将会放置在一个叫做 "),t("code",[a._v("F-Queue")]),a._v(" 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的"),t("code",[a._v("Finalizer")]),a._v("线程去执行它。")]),a._v(" "),t("h4",{attrs:{id:"step3-执行死亡还是逃脱死亡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#step3-执行死亡还是逃脱死亡"}},[a._v("#")]),a._v(" step3：执行死亡还是逃脱死亡")]),a._v(" "),t("p",[a._v("首先，我们需要知道，"),t("code",[a._v("finalize()")]),a._v("方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行第二次小规模的标记。")]),a._v(" "),t("ul",[t("li",[a._v("逃脱死亡：对象想在"),t("code",[a._v("finalize()")]),a._v("方法中成功拯救自己，只要"),t("strong",[a._v("重新与引用链上的任何一个对象建立关联")]),a._v("即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合。")]),a._v(" "),t("li",[a._v("执行死亡：对象没有执行逃脱死亡，那就是死亡了。")])]),a._v(" "),t("h3",{attrs:{id:"_3-如何回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何回收"}},[a._v("#")]),a._v(" 3 如何回收")]),a._v(" "),t("p",[a._v("如何回收其实就是利用哪些算法进行回收，垃圾收集算法这里讲几种大家平时也是看到的比较的算法，分别为："),t("strong",[a._v("标记-清除算法")]),a._v("、"),t("strong",[a._v("复制算法")]),a._v("、"),t("strong",[a._v("标记-整理算法")]),a._v("、"),t("strong",[a._v("分代回收算法")]),a._v("。")]),a._v(" "),t("p",[a._v("这部分的内容其实在网上的文章比较多了，而且，基本上的差别不大，所以，从网上的文章选取下来，当做一个小的总结，大家可以参考这篇文章算是一个比较全的总结：GC算法与内存分配策略。")]),a._v(" "),t("h4",{attrs:{id:"标记-清除-mark-sweep-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除-mark-sweep-算法"}},[a._v("#")]),a._v(" 标记－清除（Mark-Sweep）算法")]),a._v(" "),t("p",[t("strong",[a._v("标记－清除（Mark-Sweep）")]),a._v(" 算法是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。顾名思义，算法分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程在前一节讲述对象标记判定时已经讲过了。")]),a._v(" "),t("p",[a._v("标记－清除算法的不足主要有以下两点：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("空间问题")]),a._v("，标记清除之后会产生大量不连续的"),t("strong",[a._v("内存碎片")]),a._v("，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。")]),a._v(" "),t("li",[t("strong",[a._v("效率问题")]),a._v("，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。")])]),a._v(" "),t("p",[a._v("标记－清除算法的执行过程如下图所示：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/6401.png",alt:""}})]),a._v(" "),t("h4",{attrs:{id:"复制-copying-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制-copying-算法"}},[a._v("#")]),a._v(" 复制（Copying）算法")]),a._v(" "),t("p",[a._v("为了解决标记-清除算法的效率问题，一种称为**“复制”（Copying）"),t("strong",[a._v("的收集算法出现了，思想为：它")]),a._v("将可用内存按容量分成大小相等的两块**，每次只使用其中的一块。"),t("strong",[a._v("当这一块内存用完，就将还存活着的对象复制到另一块上面")]),a._v("，然后再把已使用过的内存空间一次清理掉。")]),a._v(" "),t("p",[a._v("这样做使得"),t("strong",[a._v("每次都是对整个半区进行内存回收")]),a._v("，内存分配时也就"),t("strong",[a._v("不用考虑内存碎片")]),a._v("等复杂情况，只要"),t("strong",[a._v("移动堆顶指针，按顺序分配内存")]),a._v("即可，实现简单，运行高效。只是这种算法的代价是"),t("strong",[a._v("将内存缩小为原来的一半")]),a._v("，代价可能过高了。复制算法的执行过程如下图所示：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/6402.png",alt:""}})]),a._v(" "),t("h5",{attrs:{id:"标记-整理-mark-compact-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理-mark-compact-算法"}},[a._v("#")]),a._v(" 标记－整理（Mark-Compact）算法")]),a._v(" "),t("p",[a._v("复制算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是：如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在"),t("strong",[a._v("老年代一般不能直接选用复制算法")]),a._v("。")]),a._v(" "),t("p",[a._v("根据老年代的特点，"),t("strong",[a._v("标记－整理（Mark-Compact）"),t("strong",[a._v("算法被提出来，主要思想为：此算法的标记过程与")]),a._v("标记－清除")]),a._v("算法一样，但后续步骤不是直接对可回收对象进行清理，而是"),t("strong",[a._v("让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。")]),a._v(" 具体示意图如下所示：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/6403.png",alt:""}})]),a._v(" "),t("h5",{attrs:{id:"分代收集-generational-collection-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分代收集-generational-collection-算法"}},[a._v("#")]),a._v(" 分代收集（Generational Collection）算法")]),a._v(" "),t("p",[a._v("当前商业虚拟机的垃圾收集都采用"),t("strong",[a._v("分代收集（Generational Collection）算法")]),a._v("，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("新生代")]),a._v(" 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用"),t("strong",[a._v("复制算法")]),a._v("，只需要付出少量存活对象的复制成本就可以完成收集。")]),a._v(" "),t("li",[t("strong",[a._v("老年代")]),a._v(" 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用"),t("strong",[a._v("标记-清除")]),a._v("或"),t("strong",[a._v("标记-整理")]),a._v("算法来进行回收。")])]),a._v(" "),t("h1",{attrs:{id:"二-linux安装jdk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-linux安装jdk"}},[a._v("#")]),a._v(" 二 linux安装jdk")]),a._v(" "),t("h4",{attrs:{id:"_2-1-yum安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-yum安装"}},[a._v("#")]),a._v(" 2.1 yum安装")]),a._v(" "),t("h5",{attrs:{id:"查询要安装jdk的版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询要安装jdk的版本"}},[a._v("#")]),a._v(" 查询要安装jdk的版本")]),a._v(" "),t("p",[a._v("yum -y list java*")]),a._v(" "),t("h5",{attrs:{id:"安装jdk1-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装jdk1-8"}},[a._v("#")]),a._v(" 安装jdk1.8")]),a._v(" "),t("p",[a._v("yum install -y java-1.8.0-"),t("a",{attrs:{href:"https://so.csdn.net/so/search?q=openjdk&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[a._v("openjdk"),t("OutboundLink")],1),a._v(".x86_64")]),a._v(" "),t("p",[a._v("java -version")]),a._v(" "),t("h4",{attrs:{id:"_2-2-只能java不能javac"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-只能java不能javac"}},[a._v("#")]),a._v(" 2.2 只能Java不能javac")]),a._v(" "),t("h5",{attrs:{id:"_2-2-1-配置path路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-配置path路径"}},[a._v("#")]),a._v(" 2.2.1 配置path路径")]),a._v(" "),t("p",[a._v("export PATH=$PATH:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.372.b07-1.el7_9.x86_64/jre/bin")]),a._v(" "),t("h5",{attrs:{id:"_2-2-2-安装devel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-安装devel"}},[a._v("#")]),a._v(" 2.2.2 安装devel")]),a._v(" "),t("p",[a._v("使用yum install java-1.8.0-openjdk命令安装jdk后，java命令和java -version的输出都是正确的，唯独javac没有作用。")]),a._v(" "),t("p",[a._v("解决：同时还要再安装java-1.8.0-openjdk-devel，执行yum install java-1.8.0-openjdk-devel安装完成后即可使用javac命令进行编译。")]),a._v(" "),t("p",[a._v("然后配置环境变量\nvim /etc/profile")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("vim /etc/profile\n#set java environment  \nexport JAVA_HOME=/usr/lib/jvm/java\n\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/jre/lib/rt.jar\n\nexport PATH=$PATH:$JAVA_HOME/bin\n\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);