(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{427:function(e,t,n){"use strict";n.r(t);var a=n(2),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("Java 内存模型（JMM）是一个抽象的概念，并不真实存在，它描述了一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。")])]),e._v(" "),t("p",[e._v("JMM 关于同步的规定：")]),e._v(" "),t("ul",[t("li",[e._v("线程解锁前，必须把共享变量的值刷新回主内存。")]),e._v(" "),t("li",[e._v("线程加锁时，将清空工作内存中的共享变量，从而使用共享变量时需要从主内存重新读取最新的值（注意，加锁与解锁是同一把锁）。")]),e._v(" "),t("li",[e._v("线程解锁前，对于该锁保护的每个更新过的共享变量，必须立即同步到主内存中。")]),e._v(" "),t("li",[e._v("线程加锁时，对于该锁保护的每个共享变量，必须立即从主内存中读取最新的值，或者清空工作内存中的值，在使用前从主内存中重新获取。")])]),e._v(" "),t("h3",{attrs:{id:"jmm-的主要特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jmm-的主要特性"}},[e._v("#")]),e._v(" JMM 的主要特性：")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("原子性")]),e._v(": 原子性是指一个操作是不可中断的，即使是在多个线程同时执行的时候，一个操作一旦开始，就不会被其他线程干扰。")]),e._v(" "),t("li",[t("strong",[e._v("可见性")]),e._v(": 可见性是指当一个线程修改了某个共享变量的值，其他线程能够立即得知这个修改。JMM 通过 "),t("code",[e._v("volatile")]),e._v(" 关键字来保证变量修改的可见性。当一个共享变量被 "),t("code",[e._v("volatile")]),e._v(" 修饰时，它会保证修改的值立即同步到主内存，当有其他线程需要读取时，它会直接读取主内存中的最新值。")]),e._v(" "),t("li",[t("strong",[e._v("有序性")]),e._v(": 有序性是指程序执行的顺序按照代码的先后顺序执行。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。")])]),e._v(" "),t("h3",{attrs:{id:"happens-before-原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happens-before-原则"}},[e._v("#")]),e._v(" "),t("strong",[t("code",[e._v("happens-before")]),e._v(" 原则")]),e._v(":")]),e._v(" "),t("p",[e._v("这是 JMM 的重要概念，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。几个重要的 happens-before 原则如下：")]),e._v(" "),t("ol",[t("li",[e._v("程序次序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。")]),e._v(" "),t("li",[e._v("监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。")]),e._v(" "),t("li",[t("code",[e._v("volatile")]),e._v(" 变量规则：对一个 "),t("code",[e._v("volatile")]),e._v(" 域的写，happens-before 于任意后续对这个 "),t("code",[e._v("volatile")]),e._v(" 域的读。")]),e._v(" "),t("li",[e._v("传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。")])]),e._v(" "),t("h3",{attrs:{id:"示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例:")]),e._v(" "),t("p",[e._v("考虑以下代码示例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('javaCopy codepublic class SharedObject {\n    private int count = 0;\n\n    public void incrementCount() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\npublic class ThreadExample extends Thread {\n    private SharedObject sharedObject;\n\n    public ThreadExample(SharedObject sharedObject) {\n        this.sharedObject = sharedObject;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            sharedObject.incrementCount();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SharedObject sharedObject = new SharedObject();\n        ThreadExample thread1 = new ThreadExample(sharedObject);\n        ThreadExample thread2 = new ThreadExample(sharedObject);\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        System.out.println("Final count is: " + sharedObject.getCount());\n    }\n}\n')])])]),t("p",[e._v("在这个示例中，如果你运行这个程序，最终输出的 "),t("code",[e._v("count")]),e._v(" 值可能会小于 2000。这是因为 "),t("code",[e._v("count++")]),e._v(" 操作不是原子性的，它包括读取变量 "),t("code",[e._v("count")]),e._v(" 的当前值、增加 1 和写回新值三个步骤。由于没有同步措施，两个线程可能在同一时间执行 "),t("code",[e._v("count++")]),e._v(" 操作，导致一些增量丢失。")]),e._v(" "),t("p",[e._v("为了修复这个问题，你可以使用 "),t("code",[e._v("synchronized")]),e._v(" 关键字或 "),t("code",[e._v("AtomicInteger")]),e._v(" 类来确保原子性、可见性和有序性。这些工具和关键字是 Java 平台提供的并发工具，是 JMM 规则在语言层面的实现。")])])}),[],!1,null,null,null);t.default=r.exports}}]);