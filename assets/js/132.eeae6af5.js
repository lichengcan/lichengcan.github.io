(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{552:function(e,r,a){"use strict";a.r(r);var n=a(2),t=Object(n.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("blockquote",[r("p",[e._v("转载：https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github")])]),e._v(" "),r("h1",{attrs:{id:"_1-概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[e._v("#")]),e._v(" 1. 概述")]),e._v(" "),r("p",[e._v("考虑这是 RabbitMQ 如何在 Spring Boot 整合与使用的文章，所以还是简单介绍下 RabbitMQ 是什么？")]),e._v(" "),r("blockquote",[r("p",[e._v("FROM "),r("a",{attrs:{href:"https://www.oschina.net/p/rabbitmq",target:"_blank",rel:"noopener noreferrer"}},[e._v("《AMQP 消息服务器 RabbitMQ》"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("RabbitMQ 是由 LShift 提供的一个 Advanced Message Queuing Protocol (AMQP) 的开源实现，由以高性能、健壮以及可伸缩性出名的 Erlang 写成，因此也是继承了这些优点。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/991c599424d61e17aea8eb76571715c9.jpg",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("AMQP 里主要要说两个组件：Exchange 和 Queue ，绿色的 X 就是 Exchange ，红色的是 Queue ，这两者都在 Server 端，又称作 Broker ，这部分是 RabbitMQ 实现的。")]),e._v(" "),r("li",[e._v("而蓝色的则是客户端，通常有 Producer 和 Consumer 两种类型（角色）。")])])]),e._v(" "),r("p",[e._v("在本文中，提供更多的生产者 Producer 和消费者 Consumer 的使用示例。例如说：")]),e._v(" "),r("ul",[r("li",[e._v("四种类型的交换机( Exchange )")]),e._v(" "),r("li",[e._v("Producer 发送"),r("strong",[e._v("顺序")]),e._v("消息，Consumer "),r("strong",[e._v("顺序")]),e._v("消费消息。")]),e._v(" "),r("li",[e._v("Producer 发送"),r("strong",[e._v("定时")]),e._v("消息。")]),e._v(" "),r("li",[e._v("Producer "),r("strong",[e._v("批量")]),e._v("发送消息。")]),e._v(" "),r("li",[e._v("Producer 发送"),r("strong",[e._v("事务")]),e._v("消息。")]),e._v(" "),r("li",[e._v("Consumer "),r("strong",[e._v("广播")]),e._v("和"),r("strong",[e._v("集群")]),e._v("消费消息。")]),e._v(" "),r("li",[e._v("Consumer 批量消费消息。")])]),e._v(" "),r("h1",{attrs:{id:"_2-spring-amqp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-spring-amqp"}},[e._v("#")]),e._v(" 2. Spring-AMQP")]),e._v(" "),r("p",[e._v("在 Spring 生态中，提供了 "),r("a",{attrs:{href:"https://spring.io/projects/spring-amqp",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring-AMQP"),r("OutboundLink")],1),e._v(" 项目，让我们更简便的使用 AMQP 。其官网介绍如下：")]),e._v(" "),r("blockquote",[r("p",[e._v("The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions. Spring-AMQP 项目将 Spring 核心概念应用于基于 AMQP 的消息传递解决方案的开发。")]),e._v(" "),r("p",[e._v('It provides a "template" as a high-level abstraction for sending and receiving messages. 它提供了一个“模板”作为发送消息的高级抽象。')]),e._v(" "),r("p",[e._v('It also provides support for Message-driven POJOs with a "listener container". 它还通过“侦听器容器”为消息驱动的 POJO 提供支持。')]),e._v(" "),r("p",[e._v("These libraries facilitate management of AMQP resources while promoting the use of dependency injection and declarative configuration. 这些库促进 AMQP 资源的管理，同时促进使用依赖注入和声明性配置。")]),e._v(" "),r("p",[e._v("In all of these cases, you will see similarities to the JMS support in the Spring Framework. 在所有这些情况下，您将看到与 Spring 框架中的 JMS 支持的相似之处。")]),e._v(" "),r("p",[e._v("The project consists of two parts; spring-amqp is the base abstraction, and spring-rabbit is the RabbitMQ implementation. 该项目包括两个部分：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://mvnrepository.com/artifact/org.springframework.amqp/spring-amqp",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("spring-amqp")]),r("OutboundLink")],1),e._v(" 是 AMQP 的基础抽象。")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://mvnrepository.com/artifact/org.springframework.amqp/spring-rabbit",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("spring-rabbit")]),r("OutboundLink")],1),e._v(" 是基于 RabbitMQ 对 AMQP 的具体实现。")])])]),e._v(" "),r("ul",[r("li",[e._v("其实重点是最后一段内容，相信胖友能够明白意思的。")])]),e._v(" "),r("blockquote",[r("p",[e._v("Features(功能特性)")]),e._v(" "),r("ul",[r("li",[e._v("Listener container for asynchronous processing of inbound messages 监听器容器：异步处理接收到的消息")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitTemplate"),r("OutboundLink")],1),e._v(" for sending and receiving messages RabbitTemplate：发送和接收消息")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitAdmin"),r("OutboundLink")],1),e._v(" for automatically declaring queues, exchanges and bindings RabbitAdmin：自动创建队列，交换器，绑定器。")])])]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://spring.io/projects/spring-boot",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring-Boot"),r("OutboundLink")],1),e._v(" 项目中，提供了 AMQP 和 RabbitMQ 的自动化配置，所以我们仅需引入 "),r("a",{attrs:{href:"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("spring-boot-starter-amqp")]),r("OutboundLink")],1),e._v(" 依赖，即可愉快的使用。")]),e._v(" "),r("h1",{attrs:{id:"_3-快速入门"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-快速入门"}},[e._v("#")]),e._v(" 3. 快速入门")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo"),r("OutboundLink")],1),e._v(" 。")])]),e._v(" "),r("p",[e._v("在 AMQP 中，Producer 将消息发送到 Exchange ，再由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。")]),e._v(" "),r("blockquote",[r("p",[e._v("概念的讲解，引用自 "),r("a",{attrs:{href:"http://www.iocoder.cn/RabbitMQ/Detailed-understanding-of-the-basic-concepts-of-RabbitMQ/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《RabbitMQ 基础概念详解》"),r("OutboundLink")],1),e._v(" 文章。")])]),e._v(" "),r("p",[e._v("Exchange 根据 Routing Key 和 Binding Key 将消息路由到 Queue 。目前提供了 Direct、Topic、Fanout、Headers 四种类型。")]),e._v(" "),r("h2",{attrs:{id:"_3-1-direct-exchange"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-direct-exchange"}},[e._v("#")]),e._v(" 3.1 Direct Exchange")]),e._v(" "),r("p",[e._v("Direct 类型的 Exchange 路由规则比较简单，它会把消息路由到那些 binding key 与 routing key 完全匹配的 Queue 中。以下图的配置为例：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/aeb33c91bbf83726c24ba1dae9dc4e00.jpg",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("我们以 "),r("code",[e._v('routingKey="error"')]),e._v(" 发送消息到 Exchange ，则消息会路由到 Queue1("),r("code",[e._v("amqp.gen-S9b…")]),e._v(") 。")]),e._v(" "),r("li",[e._v("我们以 "),r("code",[e._v('routingKey="info"')]),e._v(" 或 "),r("code",[e._v('routingKey="warning"')]),e._v(" 来发送消息，则消息只会路由到 Queue2("),r("code",[e._v("amqp.gen-Agl…")]),e._v(") 。")]),e._v(" "),r("li",[e._v("如果我们以其它 routingKey 发送消息，则消息不会路由到这两个 Queue 中。")]),e._v(" "),r("li",[e._v("总结来说，指定 Exchange + routing key ，有且仅会路由到至多一个 Queue 中。😈 极端情况下，如果没有匹配，消息就发送到“空气”中，不会进入任何 Queue 中。")])]),e._v(" "),r("blockquote",[r("p",[e._v("注：Queue 名字 "),r("code",[e._v("amqp.gen-S9b…")]),e._v(" 和 "),r("code",[e._v("amqp.gen-Agl…")]),e._v(" 自动生成的。")])]),e._v(" "),r("p",[e._v("下面，我们来创建一个 Direct Exchange 的使用示例，对应 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h3",{attrs:{id:"_3-1-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-引入依赖"}},[e._v("#")]),e._v(" 3.1.1 引入依赖")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件中，引入相关依赖。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.1.RELEASE</version>\n        <relativePath/> \x3c!-- lookup parent from repository --\x3e\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>lab-04-rabbitmq-demo</artifactId>\n\n    <dependencies>\n        \x3c!-- 实现对 RabbitMQ 的自动化配置 --\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-amqp</artifactId>\n        </dependency>\n\n        \x3c!-- 方便等会写单元测试 --\x3e\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n')])])]),r("p",[e._v("具体每个依赖的作用，胖友自己认真看下艿艿添加的所有注释噢。")]),e._v(" "),r("h3",{attrs:{id:"_3-1-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-应用配置文件"}},[e._v("#")]),e._v(" 3.1.2 应用配置文件")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/resources",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("resources")]),r("OutboundLink")],1),e._v(" 目录下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 配置文件。配置如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("spring:\n  # RabbitMQ 配置项，对应 RabbitProperties 配置类\n  rabbitmq:\n    host: 127.0.0.1 # RabbitMQ 服务的地址\n    port: 5672 # RabbitMQ 服务的端口\n    username: guest # RabbitMQ 服务的账号\n    password: guest # RabbitMQ 服务的密码\n")])])]),r("ul",[r("li",[e._v("在 "),r("code",[e._v("spring.rabbitmq")]),e._v(" 配置项，设置 RabbitMQ 的配置，对应 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitProperties"),r("OutboundLink")],1),e._v(" 配置类。这里咱暂时最小化添加，更多的配置项，我们在下文的示例中，一点点抽丝剥茧。")]),e._v(" "),r("li",[e._v("Spring Boot 提供的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitAutoConfiguration"),r("OutboundLink")],1),e._v(" 自动化配置类，实现 RabbitMQ 的自动配置，创建相应的 Producer 和 Consumer 。")])]),e._v(" "),r("h3",{attrs:{id:"_3-1-3-application"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-application"}},[e._v("#")]),e._v(" 3.1.3 Application")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/Application.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Application.java")]),r("OutboundLink")],1),e._v(" 类，配置 "),r("code",[e._v("@SpringBootApplication")]),e._v(" 注解即可。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Application.java\n\n@SpringBootApplication\n@EnableAsync // 开启异步\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("我们额外添加了 "),r("code",[e._v("@EnableAsync")]),e._v(" 注解，因为我们稍后要使用 Spring 提供的异步调用的功能。不了解这块的胖友，可以看看艿艿写的 "),r("a",{attrs:{href:"http://www.iocoder.cn/Spring-Boot/Async-Job/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《芋道 Spring Boot 异步任务入门》"),r("OutboundLink")],1),e._v(" 文章。")])]),e._v(" "),r("h3",{attrs:{id:"_3-1-4-demo01message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-4-demo01message"}},[e._v("#")]),e._v(" 3.1.4 Demo01Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo01Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo01Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo01Message.java\n\npublic class Demo01Message implements Serializable {\n\n    public static final String QUEUE = "QUEUE_DEMO_01";\n\n    public static final String EXCHANGE = "EXCHANGE_DEMO_01";\n\n    public static final String ROUTING_KEY = "ROUTING_KEY_01";\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("注意，要实现 Java Serializable 序列化接口。因为 RabbitTemplate 默认使用 Java 自带的序列化方式，进行序列化 POJO 类型的消息。")]),e._v(" "),r("li",[e._v("在消息类里，我们枚举了 Exchange、Queue、RoutingKey 的名字。")])]),e._v(" "),r("h3",{attrs:{id:"_3-1-5-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-5-rabbitconfig"}},[e._v("#")]),e._v(" 3.1.5 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加 Direct Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\nimport org.springframework.amqp.core.Queue;\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo01Queue() {\n            return new Queue(Demo01Message.QUEUE, // Queue 名字\n                    true, // durable: 是否持久化\n                    false, // exclusive: 是否排它\n                    false); // autoDelete: 是否自动删除\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo01Exchange() {\n            return new DirectExchange(Demo01Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        // Exchange：Demo01Message.EXCHANGE\n        // Routing key：Demo01Message.ROUTING_KEY\n        // Queue：Demo01Message.QUEUE\n        @Bean\n        public Binding demo01Binding() {\n            return BindingBuilder.bind(demo01Queue()).to(demo01Exchange()).with(Demo01Message.ROUTING_KEY);\n        }\n\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("在 DirectExchangeDemoConfiguration 内部静态类中，我们创建了 Exchange、Queue、Binding 三个 Bean ，后续 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitAdmin"),r("OutboundLink")],1),e._v(" 会自动创建交换器、队列、绑定器。感兴趣的胖友，可以看看 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java#L555-L612",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("RabbitAdmin#initialize()")]),r("OutboundLink")],1),e._v(" 方法，或 "),r("a",{attrs:{href:"https://my.oschina.net/huaxian8812/blog/782300",target:"_blank",rel:"noopener noreferrer"}},[e._v("《RabbitMQ 自动创建队列/交换器/绑定》"),r("OutboundLink")],1),e._v(" 文章。")])]),e._v(" "),r("h3",{attrs:{id:"_3-1-6-demo01producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-6-demo01producer"}},[e._v("#")]),e._v(" 3.1.6 Demo01Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo01Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo01Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Demo01Producer.java\n\n@Component\npublic class Demo01Producer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id) {\n        // 创建 Demo01Message 消息\n        Demo01Message message = new Demo01Message();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(Demo01Message.EXCHANGE, Demo01Message.ROUTING_KEY, message);\n    }\n\n    public void syncSendDefault(Integer id) {\n        // 创建 Demo01Message 消息\n        Demo01Message message = new Demo01Message();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(Demo01Message.QUEUE, message);\n    }\n\n    @Async\n    public ListenableFuture<Void> asyncSend(Integer id) {\n        try {\n            // 发送消息\n            this.syncSend(id);\n            // 返回成功的 Future\n            return AsyncResult.forValue(null);\n        } catch (Throwable ex) {\n            // 返回异常的 Future\n            return AsyncResult.forExecutionException(ex);\n        }\n    }\n\n}\n")])])]),r("ul",[r("li",[r("p",[e._v("RabbitTemplate 是 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/AmqpTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("AmqpTemplate"),r("OutboundLink")],1),e._v(" 接口的实现类，所以此时使用 AmqpTemplate 亦可。不过又因为 RabbitTemplate 还实现了其它接口，所以操作会更为丰富。因此，这里我们选择了注入 RabbitTemplate 属性。")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("#syncSend(Integer id)")]),e._v(" 方法，调用 RabbitTemplate 的同步发送消息方法。方法定义如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// AmqpTemplate.java\n\nvoid convertAndSend(String exchange, String routingKey, Object message) throws AmqpException;\n")])])]),r("ul",[r("li",[e._v("指定 Exchange + RoutingKey ，从而路由到一个 Queue 中。")])])]),e._v(" "),r("li",[r("p",[r("code",[e._v("#syncSendDefault(Integer id)")]),e._v(" 方法，也调用 RabbitTemplate 的同步发送消息方法。方法定义如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// AmqpTemplate.java\n\nvoid convertAndSend(String routingKey, Object message) throws AmqpException;\n")])])]),r("ul",[r("li",[e._v("是不是觉得有点奇怪，这里我们传入的 RoutingKey 为队列名？！因为 RabbitMQ 有一条默认的 "),r("a",{attrs:{href:"https://emacsist.github.io/2015/12/06/rabbitmq%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#default-exchange-%E9%BB%98%E8%AE%A4%E4%BA%A4%E6%8D%A2%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"}},[e._v("Exchange: (AMQP default)"),r("OutboundLink")],1),e._v(" 规则："),r("code",[e._v("The default exchange is implicitly bound to every queue, with a routing key equal to the queue name. It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted")]),e._v(" 。")]),e._v(" "),r("li",[e._v("翻译过来的意思：默认交换器，隐式地绑定到每个队列，路由键等于队列名称。")]),e._v(" "),r("li",[e._v("所以，此处即使我们传入的 RoutingKey 为队列名，一样可以发到对应队列。")])])]),e._v(" "),r("li",[r("p",[r("code",[e._v("#asyncSend(Integer id)")]),e._v(" 方法，通过 "),r("code",[e._v("@Async")]),e._v(" 注解，声明异步调用该方法，从而实现异步消息到 RabbitMQ 中。因为 RabbitTemplate 并未像 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/core/KafkaTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("KafkaTemplate"),r("OutboundLink")],1),e._v(" 或 "),r("a",{attrs:{href:"https://github.com/apache/rocketmq-spring/blob/master/rocketmq-spring-boot/src/main/java/org/apache/rocketmq/spring/core/RocketMQTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RocketMQTemplate"),r("OutboundLink")],1),e._v(" 直接提供了异步发送消息的方法，所以我们需要结合 Spring 异步调用来实现。")]),e._v(" "),r("blockquote",[r("p",[e._v("在写完本文之后，发现还存在 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/AsyncRabbitTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("AsyncRabbitTemplate"),r("OutboundLink")],1),e._v(" 类，提供一部的 RabbitMQ 操作。😈")])])])]),e._v(" "),r("h3",{attrs:{id:"_3-1-7-demo01consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-7-demo01consumer"}},[e._v("#")]),e._v(" 3.1.7 Demo01Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo01Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo01Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo01Consumer.java\n\n@Component\n@RabbitListener(queues = Demo01Message.QUEUE)\npublic class Demo01Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo01Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n//    @RabbitHandler(isDefault = true)\n//    public void onMessage(org.springframework.amqp.core.Message message) {\n//        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n//    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在类上，添加了 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitListener.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("@RabbitListener")]),r("OutboundLink")],1),e._v(" 注解，声明了消费的队列是 "),r("code",[e._v('"QUEUE_DEMO_01"')]),e._v(" 。")]),e._v(" "),r("li",[e._v("在方法上，添加了 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitHandler.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("@RabbitHandler")]),r("OutboundLink")],1),e._v(" 注解，申明了处理消息的方法。同时，方法入参为消息的类型。这里，我们设置了"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v(" 。")]),e._v(" "),r("li",[e._v("如果我们想要获得消费消息的更多信息，例如说，RoutingKey、创建时间等等信息，则可以考虑使用艿艿"),r("strong",[e._v("注释掉的那段代码")]),e._v("，通过方法入参为 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/Message.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("org.springframework.amqp.core.Message")]),r("OutboundLink")],1),e._v(" 类型。不过绝大多数情况下，我们并不需要这么做。")])]),e._v(" "),r("h3",{attrs:{id:"_3-1-8-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-8-简单测试"}},[e._v("#")]),e._v(" 3.1.8 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo01ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo01ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写三个单元测试方法，调用 Demo01Producer 三个发送消息的方式。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo01ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo01ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo01Producer producer;\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id);\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n    @Test\n    public void tesSyncSendDefault() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSendDefault(id);\n        logger.info("[tesSyncSendDefault][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n    @Test\n    public void testAsyncSend() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.asyncSend(id).addCallback(new ListenableFutureCallback<Void>() {\n\n            @Override\n            public void onFailure(Throwable e) {\n                logger.info("[testASyncSend][发送编号：[{}] 发送异常]]", id, e);\n            }\n\n            @Override\n            public void onSuccess(Void aVoid) {\n                logger.info("[testASyncSend][发送编号：[{}] 发送成功，发送成功]", id);\n            }\n\n        });\n        logger.info("[testASyncSend][发送编号：[{}] 调用完成]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("比较简单，胖友自己看下三个单元测试方法。")])]),e._v(" "),r("p",[e._v("我们来执行 "),r("code",[e._v("#testSyncSend()")]),e._v(" 方法，测试同步发送消息。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 同步发送消息成功。\n2019-12-15 00:19:18.736  INFO 87164 --- [           main] c.i.s.l.r.producer.Demo01ProducerTest    : [testSyncSend][发送编号：[1575908358] 发送成功]\n\n# Demo01Consumer 成功消费了该消息\n2019-12-15 00:19:18.751  INFO 87164 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo01Consumer        : [onMessage][线程编号:17 消息内容：Demo01Message{id=1575908358}]\n")])])]),r("ul",[r("li",[e._v("同步发送的消息，成功被消费。")])]),e._v(" "),r("p",[e._v("我们再来执行 "),r("code",[e._v("#tesSyncSendDefault()")]),e._v(" 方法，测试另一个同步发送消息。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 同步发送消息成功。\n2019-12-15 00:20:50.226  INFO 87515 --- [           main] c.i.s.l.r.producer.Demo01ProducerTest    : [tesSyncSendDefault][发送编号：[1575908450] 发送成功]\n\n# Demo01Consumer 成功消费了该消息\n2019-12-15 00:20:50.240  INFO 87515 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo01Consumer        : [onMessage][线程编号:17 消息内容：Demo01Message{id=1575908450}]\n")])])]),r("ul",[r("li",[e._v("同步发送的消息，成功也被消费。")])]),e._v(" "),r("p",[e._v("我们最后来执行 "),r("code",[e._v("#testAsyncSend()")]),e._v(" 方法，测试异步发送消息。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 异步发送消息的调用完成。\n2019-12-15 00:22:48.891  INFO 88018 --- [           main] c.i.s.l.r.producer.Demo01ProducerTest    : [testASyncSend][发送编号：[1575908568] 调用完成]\n\n# Producer 异步发送消息成功。【回调】\n2019-12-15 00:22:48.905  INFO 88018 --- [         task-1] c.i.s.l.r.producer.Demo01ProducerTest    : [testASyncSend][发送编号：[1575908568] 发送成功，发送成功]\n\n# Demo01Consumer 成功消费了该消息\n2019-12-15 00:22:48.918  INFO 88018 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo01Consumer        : [onMessage][线程编号:17 消息内容：Demo01Message{id=1575908568}]\n")])])]),r("ul",[r("li",[e._v("异步发送的消息，成功也被消费。")])]),e._v(" "),r("h2",{attrs:{id:"_3-2-topic-exchange"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-topic-exchange"}},[e._v("#")]),e._v(" 3.2 Topic Exchange")]),e._v(" "),r("p",[e._v("前面讲到 Direct Exchange路由规则，是完全匹配 binding key 与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。")]),e._v(" "),r("p",[e._v("Topic Exchange 在匹配规则上进行了扩展，它与 Direct 类型的Exchange "),r("strong",[e._v("相似")]),e._v("，也是将消息路由到 binding key 与 routing key 相匹配的 Queue 中，但这里的匹配规则有些不同，它约定：")]),e._v(" "),r("ul",[r("li",[e._v("routing key 为一个句点号 "),r("code",[e._v('"."')]),e._v(" 分隔的字符串。我们将被句点号"),r("code",[e._v('"."')]),e._v('分隔开的每一段独立的字符串称为一个单词，例如 "stock.usd.nyse"、"nyse.vmw"、"quick.orange.rabbit"')]),e._v(" "),r("li",[e._v("binding key 与 routing key 一样也是句点号 "),r("code",[e._v('"."')]),e._v(" 分隔的字符串。")]),e._v(" "),r("li",[e._v("binding key 中可以存在两种特殊字符 "),r("code",[e._v('"*"')]),e._v(" 与 "),r("code",[e._v('"#"')]),e._v("，用于做模糊匹配。其中 "),r("code",[e._v('"*"')]),e._v(" 用于匹配一个单词，"),r("code",[e._v('"#"')]),e._v(" 用于匹配多个单词（可以是零个）。")])]),e._v(" "),r("p",[e._v("以下图中的配置为例：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/d343228b9d7606ac673ccd0028d4e424.jpg",alt:""}})]),e._v(" "),r("ul",[r("li",[r("code",[e._v('routingKey="quick.orange.rabbit"')]),e._v(" 的消息会同时路由到 Q1 与 Q2 。")]),e._v(" "),r("li",[r("code",[e._v('routingKey="lazy.orange.fox"')]),e._v(" 的消息会路由到 Q1 。")]),e._v(" "),r("li",[r("code",[e._v('routingKey="lazy.brown.fox"')]),e._v(" 的消息会路由到 Q2 。")]),e._v(" "),r("li",[r("code",[e._v('routingKey="lazy.pink.rabbit"')]),e._v(" 的消息会路由到Q2（只会投递给 Q2 一次，虽然这个 routingKey 与 Q2 的两个 bindingKey 都匹配）。")]),e._v(" "),r("li",[r("code",[e._v('routingKey="quick.brown.fox"')]),e._v("、"),r("code",[e._v('routingKey="orange"')]),e._v("、"),r("code",[e._v('routingKey="quick.orange.male.rabbit"')]),e._v(" 的消息将会被丢弃，因为它们没有匹配任何 bindingKey 。")])]),e._v(" "),r("p",[e._v("下面，我们来创建一个 Topic Exchange 的使用示例，继续在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h3",{attrs:{id:"_3-2-1-demo02message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-demo02message"}},[e._v("#")]),e._v(" 3.2.1 Demo02Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo02Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo02Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo02Message.java\n\npublic class Demo02Message implements Serializable {\n\n    public static final String QUEUE = "QUEUE_DEMO_02";\n\n    public static final String EXCHANGE = "EXCHANGE_DEMO_02";\n\n    public static final String ROUTING_KEY = "#.yu.nai";\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("在消息类里，我们枚举了 Exchange、Queue、RoutingKey 的名字。")]),e._v(" "),r("li",[e._v("重点看我们新定义的路由键 "),r("code",[e._v('ROUTING_KEY = "#.yu.nai"')]),e._v(" ，我们要匹配以 "),r("code",[e._v('"yu.nai"')]),e._v(" 结尾，开头可以是任意个单词的。")])]),e._v(" "),r("h3",{attrs:{id:"_3-2-2-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-rabbitconfig"}},[e._v("#")]),e._v(" 3.2.2 RabbitConfig")]),e._v(" "),r("p",[e._v("修改 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加 Topic Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n/**\n * Topic Exchange 示例的配置类\n */\npublic static class TopicExchangeDemoConfiguration {\n\n    // 创建 Queue\n    @Bean\n    public Queue demo02Queue() {\n        return new Queue(Demo02Message.QUEUE, // Queue 名字\n                true, // durable: 是否持久化\n                false, // exclusive: 是否排它\n                false); // autoDelete: 是否自动删除\n    }\n\n    // 创建 Topic Exchange\n    @Bean\n    public TopicExchange demo02Exchange() {\n        return new TopicExchange(Demo02Message.EXCHANGE,\n                true,  // durable: 是否持久化\n                false);  // exclusive: 是否排它\n    }\n\n    // 创建 Binding\n    // Exchange：Demo02Message.EXCHANGE\n    // Routing key：Demo02Message.ROUTING_KEY\n    // Queue：Demo02Message.QUEUE\n    @Bean\n    public Binding demo02Binding() {\n        return BindingBuilder.bind(demo02Queue()).to(demo02Exchange()).with(Demo02Message.ROUTING_KEY);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("在 TopicExchangeDemoConfiguration 内部静态类中，我们"),r("strong",[e._v("也是")]),e._v("创建了 Exchange、Queue、Binding 三个 Bean 。有差异点的是，这次我们创建的是 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/TopicExchange.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("TopicExchange"),r("OutboundLink")],1),e._v(" 。")])]),e._v(" "),r("h3",{attrs:{id:"_3-2-3-demo02producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-demo02producer"}},[e._v("#")]),e._v(" 3.2.3 Demo02Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo02Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo02Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Demo02Producer.java\n\n@Component\npublic class Demo02Producer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id, String routingKey) {\n        // 创建 Demo02Message 消息\n        Demo02Message message = new Demo02Message();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(Demo02Message.EXCHANGE, routingKey, message);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("的 "),r("code",[e._v("#syncSend(Integer id)")]),e._v(" 方法大体相似，差异点在于新增了方法参数 "),r("code",[e._v("routingKey")]),e._v(" ，方便我们传入不同的路由键。")])]),e._v(" "),r("h3",{attrs:{id:"_3-2-4-demo02consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-demo02consumer"}},[e._v("#")]),e._v(" 3.2.4 Demo02Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo02Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo02Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.7 Demo01Consumer」"),r("OutboundLink")],1),e._v("基本一致，差别在于消费的队列是 "),r("code",[e._v('"QUEUE_DEMO_02"')]),e._v(" 。")]),e._v(" "),r("h3",{attrs:{id:"_3-2-5-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-5-简单测试"}},[e._v("#")]),e._v(" 3.2.5 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo02ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo02ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写两个单元测试方法，调用 Demo02Producer 发送消息的方法。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo02ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo02ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo02Producer producer;\n\n    @Test\n    public void testSyncSendSuccess() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id, "da.yu.nai");\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n    @Test\n    public void testSyncSendFailure() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id, "yu.nai.shuai");\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("ul",[r("li",[r("code",[e._v("#testSyncSendSuccess()")]),e._v(" 方法，发送消息的 RoutingKey 是 "),r("code",[e._v('"da.yu.nai"')]),e._v(" ，可以匹配到 "),r("code",[e._v('"DEMO_QUEUE_02"')]),e._v(" 。")]),e._v(" "),r("li",[r("code",[e._v("#testSyncSendFailure()")]),e._v(" 方法，发送消息的 RoutingKey 是 "),r("code",[e._v('"yu.nai.shuai"')]),e._v(" ，无法匹配到 "),r("code",[e._v('"DEMO_QUEUE_02"')]),e._v(" 。")])]),e._v(" "),r("p",[e._v("我们先来执行 "),r("code",[e._v("#testSyncSendSuccess()")]),e._v(" 方法，可以匹配到 "),r("code",[e._v('"DEMO_QUEUE_02"')]),e._v(" 的情况。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 同步发送消息成功。\n2019-12-15 09:35:54.924  INFO 6894 --- [           main] c.i.s.l.r.producer.Demo02ProducerTest    : [testSyncSend][发送编号：[1575941754] 发送成功]\n\n# Demo02Consumer 成功消费了该消息\n2019-12-15 09:35:54.941  INFO 6894 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo02Consumer        : [onMessage][线程编号:19 消息内容：Demo02Message{id=1575941754}]\n")])])]),r("ul",[r("li",[e._v("符合预期。")])]),e._v(" "),r("p",[e._v("我们再来执行 "),r("code",[e._v("#testSyncSendFailure()")]),e._v(" 方法，无法匹配到 "),r("code",[e._v('"DEMO_QUEUE_02"')]),e._v(" 的情况。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Producer 同步发送消息成功。\n2019-12-15 09:37:11.353  INFO 7186 --- [           main] c.i.s.l.r.producer.Demo02ProducerTest    : [testSyncSend][发送编号：[1575941831] 发送成功]\n")])])]),r("ul",[r("li",[e._v("符合预期。因为 无法匹配到 "),r("code",[e._v('"DEMO_QUEUE_02"')]),e._v(" ，自然 Demo02Consumer 无法进行消费。")])]),e._v(" "),r("h2",{attrs:{id:"_3-3-fanout-exchange"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-fanout-exchange"}},[e._v("#")]),e._v(" 3.3 Fanout Exchange")]),e._v(" "),r("p",[e._v("Fanout Exchange 路由规则非常简单，它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中。如下图：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/203b64e17bd9e398cf619acb5df98e6b.jpg",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("生产者（P）发送到 Exchange（X）的所有消息都会路由到图中的两个 Queue，并最终被两个消费者（C1 与 C2）消费。")]),e._v(" "),r("li",[e._v("总结来说，指定 Exchange ，会路由到"),r("strong",[e._v("多个")]),e._v("绑定的 Queue 中。")])]),e._v(" "),r("p",[e._v("下面，我们来创建一个 Fanout Exchange 的使用示例，继续在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h3",{attrs:{id:"_3-3-1-demo03message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-demo03message"}},[e._v("#")]),e._v(" 3.3.1 Demo03Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo03Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo03Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo03Message.java\n\npublic class Demo03Message implements Serializable {\n\n    public static final String QUEUE_A = "QUEUE_DEMO_03_A";\n    public static final String QUEUE_B = "QUEUE_DEMO_03_B";\n\n    public static final String EXCHANGE = "EXCHANGE_DEMO_03";\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("我们"),r("strong",[e._v("未")]),e._v("定意思 RoutingKey 的名字。因为，Fanout Exchange 仅需要 Exchange 即可。")]),e._v(" "),r("li",[e._v("我们定义"),r("strong",[e._v("两个")]),e._v(" Queue 的名字。因为，我们要测试 Fanout Exchange 投递到多个 Queue 的效果。")])]),e._v(" "),r("h3",{attrs:{id:"_3-3-2-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-rabbitconfig"}},[e._v("#")]),e._v(" 3.3.2 RabbitConfig")]),e._v(" "),r("p",[e._v("修改 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加 Fanout Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n/**\n * Fanout Exchange 示例的配置类\n */\npublic static class FanoutExchangeDemoConfiguration {\n\n    // 创建 Queue A\n    @Bean\n    public Queue demo03QueueA() {\n        return new Queue(Demo03Message.QUEUE_A, // Queue 名字\n                true, // durable: 是否持久化\n                false, // exclusive: 是否排它\n                false); // autoDelete: 是否自动删除\n    }\n\n    // 创建 Queue B\n    @Bean\n    public Queue demo03QueueB() {\n        return new Queue(Demo03Message.QUEUE_B, // Queue 名字\n                true, // durable: 是否持久化\n                false, // exclusive: 是否排它\n                false); // autoDelete: 是否自动删除\n    }\n\n    // 创建 Fanout Exchange\n    @Bean\n    public FanoutExchange demo03Exchange() {\n        return new FanoutExchange(Demo03Message.EXCHANGE,\n                true,  // durable: 是否持久化\n                false);  // exclusive: 是否排它\n    }\n\n    // 创建 Binding A\n    // Exchange：Demo03Message.EXCHANGE\n    // Queue：Demo03Message.QUEUE_A\n    @Bean\n    public Binding demo03BindingA() {\n        return BindingBuilder.bind(demo03QueueA()).to(demo03Exchange());\n    }\n\n    // 创建 Binding B\n    // Exchange：Demo03Message.EXCHANGE\n    // Queue：Demo03Message.QUEUE_B\n    @Bean\n    public Binding demo03BindingB() {\n        return BindingBuilder.bind(demo03QueueB()).to(demo03Exchange());\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("在 FanoutExchangeDemoConfiguration 内部静态类中，我们"),r("strong",[e._v("也是")]),e._v("创建了 Exchange、Queue、Binding 三个 Bean 。有差异点的是，这次我们创建的是 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/FanoutExchange.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("FanoutExchange"),r("OutboundLink")],1),e._v(" 。")]),e._v(" "),r("li",[e._v("同时，因为我们要投递到两个 Queue 中，所以我们创建了两个 Binding 。")])]),e._v(" "),r("h3",{attrs:{id:"_3-3-3-demo03producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-demo03producer"}},[e._v("#")]),e._v(" 3.3.3 Demo03Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo03Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo03Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Demo03Producer.java\n\n@Component\npublic class Demo03Producer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id) {\n        // 创建 Demo03Message 消息\n        Demo03Message message = new Demo03Message();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(Demo03Message.EXCHANGE, null, message);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("的 "),r("code",[e._v("#syncSend(Integer id)")]),e._v(" 方法大体相似，差异点在于传入 "),r("code",[e._v("routingKey = null")]),e._v(" ，因为不需要。")])]),e._v(" "),r("h3",{attrs:{id:"_3-3-4-demo03consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-4-demo03consumer"}},[e._v("#")]),e._v(" 3.3.4 Demo03Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo03ConsumerA.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo03ConsumerA"),r("OutboundLink")],1),e._v(" 和 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo03ConsumerB.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo03ConsumerB"),r("OutboundLink")],1),e._v(" "),r("strong",[e._v("两个")]),e._v("类，消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo03ConsumerA.java\n@Component\n@RabbitListener(queues = Demo03Message.QUEUE_A)\npublic class Demo03ConsumerA {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo03Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n\n// Demo03ConsumerB.java\n@Component\n@RabbitListener(queues = Demo03Message.QUEUE_B)\npublic class Demo03ConsumerB {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo03Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("两个消费者，分别消费 "),r("code",[e._v('"QUEUE_DEMO_03_A"')]),e._v("、"),r("code",[e._v('"QUEUE_DEMO_03_B"')]),e._v(" 队列。")])]),e._v(" "),r("h3",{attrs:{id:"_3-3-5-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-5-简单测试"}},[e._v("#")]),e._v(" 3.3.5 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo03ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo03ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写一个单元测试方法，调用 Demo03Producer 发送消息的方法。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo03ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo03ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo03Producer producer;\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id);\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("p",[e._v("我们先来执行 "),r("code",[e._v("#testSyncSend()")]),e._v(" 方法，确认下 Fanout Exchange 的效果。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 同步发送消息成功。\n2019-12-15 13:42:51.794  INFO 50616 --- [           main] c.i.s.l.r.producer.Demo03ProducerTest    : [testSyncSend][发送编号：[1575956571] 发送成功]\n\n# Demo03ConsumerA 成功消费了该消息\n2019-12-15 13:42:51.811  INFO 50616 --- [ntContainer#2-1] c.i.s.l.r.consumer.Demo03ConsumerA       : [onMessage][线程编号:22 消息内容：Demo03Message{id=1575956571}]\n\n# Demo03ConsumerB 也成功消费了该消息\n2019-12-15 13:42:51.811  INFO 50616 --- [ntContainer#3-1] c.i.s.l.r.consumer.Demo03ConsumerB       : [onMessage][线程编号:24 消息内容：Demo03Message{id=1575956571}]\n")])])]),r("ul",[r("li",[e._v("符合预期。")]),e._v(" "),r("li",[e._v("发送的消息，成功投递到了两个队列中，所以被两个消费者都消费到了。")])]),e._v(" "),r("h2",{attrs:{id:"_3-4-headers-exchange"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-headers-exchange"}},[e._v("#")]),e._v(" 3.4 Headers Exchange")]),e._v(" "),r("p",[e._v("Headers Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。")]),e._v(" "),r("ul",[r("li",[e._v("在绑定 Queue 与 Exchange 时指定一组 headers 键值对。")]),e._v(" "),r("li",[e._v("当消息发送到 Exchange 时，RabbitMQ 会取到该消息的 headers（也是一个键值对的形式），对比其中的键值对是否完全匹配 Queue 与 Exchange 绑定时指定的键值对；如果完全匹配则消息会路由到该 Queue ，否则不会路由到该 Queue 。")])]),e._v(" "),r("p",[e._v("不过艿艿在查询资料的时候，有资料说 Headers Exchange 性能很差，实际场景也使用比较少。所以本小节的内容，胖友可以选择性看。")]),e._v(" "),r("p",[e._v("下面，我们来创建一个 Headers Exchange 的使用示例，继续在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h3",{attrs:{id:"_3-4-1-demo04message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-demo04message"}},[e._v("#")]),e._v(" 3.4.1 Demo04Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo04Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo04Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo03Message.java\n\npublic class Demo04Message implements Serializable {\n\n    public static final String QUEUE = "QUEUE_DEMO_04_A";\n\n    public static final String EXCHANGE = "EXCHANGE_DEMO_04";\n\n    public static final String HEADER_KEY = "color";\n    public static final String HEADER_VALUE = "red";\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("我们"),r("strong",[e._v("未")]),e._v("定意思 RoutingKey 的名字。因为，Headers Exchange 是通过 Exchange + Headers 的组合。")]),e._v(" "),r("li",[e._v("我们定义"),r("strong",[e._v("一个")]),e._v(" Headers 键值对，"),r("code",[e._v("color = red")]),e._v(" 。")])]),e._v(" "),r("h3",{attrs:{id:"_3-4-2-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2-rabbitconfig"}},[e._v("#")]),e._v(" 3.4.2 RabbitConfig")]),e._v(" "),r("p",[e._v("修改 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加 Headers Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n/**\n * Headers Exchange 示例的配置类\n */\npublic static class HeadersExchangeDemoConfiguration {\n\n    // 创建 Queue\n    @Bean\n    public Queue demo04Queue() {\n        return new Queue(Demo04Message.QUEUE, // Queue 名字\n                true, // durable: 是否持久化\n                false, // exclusive: 是否排它\n                false); // autoDelete: 是否自动删除\n    }\n\n    // 创建 Headers Exchange\n    @Bean\n    public HeadersExchange demo04Exchange() {\n        return new HeadersExchange(Demo04Message.EXCHANGE,\n                true,  // durable: 是否持久化\n                false);  // exclusive: 是否排它\n    }\n\n    // 创建 Binding\n    // Exchange：Demo04Message.EXCHANGE\n    // Queue：Demo04Message.QUEUE\n    // Headers: Demo04Message.HEADER_KEY + Demo04Message.HEADER_VALUE\n    @Bean\n    public Binding demo4Binding() {\n        return BindingBuilder.bind(demo04Queue()).to(demo04Exchange())\n                .where(Demo04Message.HEADER_KEY).matches(Demo04Message.HEADER_VALUE); // 配置 Headers 匹配\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("在 TopicExchangeDemoConfiguration 内部静态类中，我们"),r("strong",[e._v("也是")]),e._v("创建了 Exchange、Queue、Binding 三个 Bean 。有差异点的是，这次我们创建的是 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/HeadersExchange.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("HeadersExchange"),r("OutboundLink")],1),e._v(" 。")]),e._v(" "),r("li",[e._v("同时，我们创建的 Binding 是基于 Headers 匹配。")])]),e._v(" "),r("h3",{attrs:{id:"_3-4-3-demo04producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-3-demo04producer"}},[e._v("#")]),e._v(" 3.4.3 Demo04Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo04Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo04Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Demo02Producer.java\n\n@Component\npublic class Demo04Producer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id, String headerValue) {\n        // 创建 MessageProperties 属性\n        MessageProperties messageProperties = new MessageProperties();\n        messageProperties.setHeader(Demo04Message.HEADER_KEY, headerValue); // 设置 header\n        // 创建 Message 消息\n        Message message = rabbitTemplate.getMessageConverter().toMessage(\n                new Demo04Message().setId(id), messageProperties);\n        // 同步发送消息\n        rabbitTemplate.send(Demo04Message.EXCHANGE, null, message);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("的 "),r("code",[e._v("#syncSend(Integer id)")]),e._v(" 方法大体相似，差异点在于新增了方法参数 "),r("code",[e._v("headerValue")]),e._v(" ，方便我们传入不同的 Headers 值。")]),e._v(" "),r("li",[e._v("因为 RabbitTemplate 会提供很方便的传递 Headers 的 API 方法，所以我们只好自己构建，当然也比较简单哈。")])]),e._v(" "),r("h3",{attrs:{id:"_3-4-4-demo04consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-4-demo04consumer"}},[e._v("#")]),e._v(" 3.4.4 Demo04Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo04Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo04Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.7 Demo01Consumer」"),r("OutboundLink")],1),e._v("基本一致，差别在于消费的队列是 "),r("code",[e._v('"QUEUE_DEMO_04"')]),e._v(" 。")]),e._v(" "),r("h3",{attrs:{id:"_3-4-5-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-5-简单测试"}},[e._v("#")]),e._v(" 3.4.5 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo04ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo04ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写两个单元测试方法，调用 Demo04Producer 发送消息的方法。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo04ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo04ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo04Producer producer;\n\n    @Test\n    public void testSyncSendSuccess() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id, Demo04Message.HEADER_VALUE);\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n    @Test\n    public void testSyncSendFailure() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id, "error");\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("ul",[r("li",[r("code",[e._v("#testSyncSendSuccess()")]),e._v(" 方法，发送消息的 Headers 的值 "),r("code",[e._v('"red"')]),e._v(" ，可以匹配到 "),r("code",[e._v('"DEMO_QUEUE_04"')]),e._v(" 。")]),e._v(" "),r("li",[r("code",[e._v("#testSyncSendFailure()")]),e._v(" 方法，发送消息的 Headers 的值 "),r("code",[e._v('"error"')]),e._v(" ，无法匹配到 "),r("code",[e._v('"DEMO_QUEUE_04"')]),e._v(" 。")])]),e._v(" "),r("p",[e._v("我们先来执行 "),r("code",[e._v("#testSyncSendSuccess()")]),e._v(" 方法，可以匹配到 "),r("code",[e._v('"DEMO_QUEUE_04"')]),e._v(" 的情况。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 同步发送消息成功。\n2019-12-15 14:30:05.872  INFO 61498 --- [           main] c.i.s.l.r.producer.Demo04ProducerTest    : [testSyncSend][发送编号：[1575959405] 发送成功]\n\n# Demo04Consumer 成功消费了该消息\n2019-12-15 14:30:05.888  INFO 61498 --- [ntContainer#4-1] c.i.s.l.r.consumer.Demo04Consumer        : [onMessage][线程编号:25 消息内容：Demo04Message{id=1575959405}]\n")])])]),r("ul",[r("li",[e._v("符合预期。")])]),e._v(" "),r("p",[e._v("我们再来执行 "),r("code",[e._v("#testSyncSendFailure()")]),e._v(" 方法，无法匹配到 "),r("code",[e._v('"DEMO_QUEUE_04"')]),e._v(" 的情况。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Producer 同步发送消息成功。\n2019-12-15 14:30:47.090  INFO 61664 --- [           main] c.i.s.l.r.producer.Demo04ProducerTest    : [testSyncSend][发送编号：[1575959447] 发送成功]\n")])])]),r("ul",[r("li",[e._v("符合预期。因为 无法匹配到 "),r("code",[e._v('"DEMO_QUEUE_04"')]),e._v(" ，自然 Demo04Consumer 无法进行消费。")])]),e._v(" "),r("h1",{attrs:{id:"_4-批量发送消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-批量发送消息"}},[e._v("#")]),e._v(" 4. 批量发送消息")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-batch"),r("OutboundLink")],1),e._v(" 。")])]),e._v(" "),r("p",[e._v("在一些业务场景下，我们希望使用 Producer 批量发送消息，提高发送性能。不同于我们在"),r("a",{attrs:{href:"http://www.iocoder.cn/Spring-Boot/RocketMQ/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《芋道 Spring Boot 消息队列 RocketMQ 入门》"),r("OutboundLink")],1),e._v(" 的"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4. 批量发送消息」"),r("OutboundLink")],1),e._v(" 功能，RocketMQ 是提供了一个可以批量发送多条消息的 API 。而 Spring-AMQP 提供的批量发送消息，它提供了一个 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/MessageBatch.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("MessageBatch"),r("OutboundLink")],1),e._v(" 消息收集器，将发送给"),r("strong",[e._v("相同 Exchange + RoutingKey 的消息们")]),e._v("，“"),r("strong",[e._v("偷偷")]),e._v("”收集在一起，当满足条件时候，一次性批量发送提交给 RabbitMQ Broker 。")]),e._v(" "),r("p",[e._v("Spring-AMQP 通过 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/BatchingRabbitTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("BatchingRabbitTemplate"),r("OutboundLink")],1),e._v(" 提供批量发送消息的功能。如下是三个条件，满足"),r("strong",[e._v("任一")]),e._v("即会批量发送：")]),e._v(" "),r("ul",[r("li",[e._v("【数量】"),r("code",[e._v("batchSize")]),e._v(" ：超过收集的消息数量的最大条数。")]),e._v(" "),r("li",[e._v("【空间】"),r("code",[e._v("bufferLimit")]),e._v(" ：超过收集的消息占用的最大内存。")]),e._v(" "),r("li",[e._v("【时间】"),r("code",[e._v("timeout")]),e._v(" ：超过收集的时间的最大等待时长，单位：毫秒。😈 不过要注意，这里的超时开始计时的时间，是"),r("strong",[e._v("以最后一次发送时间为起点")]),e._v("。也就说，每调用一次发送消息，都以当前时刻开始计时，重新到达 "),r("code",[e._v("timeout")]),e._v(" 毫秒才算超时。")])]),e._v(" "),r("p",[e._v("另外，BatchingRabbitTemplate 提供的批量发送消息的能力"),r("strong",[e._v("比较弱")]),e._v("。对于同一个 BatchingRabbitTemplate 对象来说，"),r("strong",[e._v("同一时刻只能有一个批次(保证 Exchange + RoutingKey 相同)")]),e._v("，否则会报错。")]),e._v(" "),r("p",[e._v("下面，我们来实现一个 Producer 批量发送消息的示例。考虑到不污染"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3. 快速入门」"),r("OutboundLink")],1),e._v(" 的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-batch"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_4-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-引入依赖"}},[e._v("#")]),e._v(" 4.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_4-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-应用配置文件"}},[e._v("#")]),e._v(" 4.2 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_4-3-demo05message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-demo05message"}},[e._v("#")]),e._v(" 4.3 Demo05Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo05Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_4-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-rabbitconfig"}},[e._v("#")]),e._v(" 4.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加 BatchingRabbitTemplate 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo05Queue() {\n            return new Queue(Demo05Message.QUEUE, // Queue 名字\n                    true, // durable: 是否持久化\n                    false, // exclusive: 是否排它\n                    false); // autoDelete: 是否自动删除\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo05Exchange() {\n            return new DirectExchange(Demo05Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        // Exchange：Demo05Message.EXCHANGE\n        // Routing key：Demo05Message.ROUTING_KEY\n        // Queue：Demo05Message.QUEUE\n        @Bean\n        public Binding demo05Binding() {\n            return BindingBuilder.bind(demo05Queue()).to(demo05Exchange()).with(Demo05Message.ROUTING_KEY);\n        }\n\n    }\n\n    @Bean\n    public BatchingRabbitTemplate batchRabbitTemplate(ConnectionFactory connectionFactory) {\n        // 创建 BatchingStrategy 对象，代表批量策略\n        int batchSize = 16384; // 超过收集的消息数量的最大条数。\n        int bufferLimit = 33554432; // 每次批量发送消息的最大内存\n        int timeout = 30000; // 超过收集的时间的最大等待时长，单位：毫秒\n        BatchingStrategy batchingStrategy = new SimpleBatchingStrategy(batchSize, bufferLimit, timeout);\n\n        // 创建 TaskScheduler 对象，用于实现超时发送的定时器\n        TaskScheduler taskScheduler = new ConcurrentTaskScheduler();\n\n        // 创建 BatchingRabbitTemplate 对象\n        BatchingRabbitTemplate batchTemplate = new BatchingRabbitTemplate(batchingStrategy, taskScheduler);\n        batchTemplate.setConnectionFactory(connectionFactory);\n        return batchTemplate;\n    }\n\n}\n")])])]),r("ul",[r("li",[r("p",[e._v("DirectExchangeDemoConfiguration 配置类，用于定义 Queue、Exchange、Binding 的配置。")])]),e._v(" "),r("li",[r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("#batchRabbitTemplate(ConnectionFactory connectionFactory)\n")])])]),r("p",[e._v("方法，创建 BatchingRabbitTemplate Bean 对象。")]),e._v(" "),r("ul",[r("li",[e._v("具体的 "),r("code",[e._v("batchSize")]),e._v("、"),r("code",[e._v("bufferLimit")]),e._v("、"),r("code",[e._v("timeout")]),e._v(" 数值配置多少，根据自己的应用来。这里，我们故意将 "),r("code",[e._v("timeout")]),e._v(" 配置成了 30 秒，主要为了演示之用。")]),e._v(" "),r("li",[e._v("创建 BatchingRabbitTemplate 对象的代码，艿艿已经添加注释，可以自己阅读理解下噢。")])])])]),e._v(" "),r("h2",{attrs:{id:"_4-5-demo05producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-demo05producer"}},[e._v("#")]),e._v(" 4.5 Demo05Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo05Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 BatchingRabbitTemplate ，实现批量发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Demo05Producer.java\n\n@Component\npublic class Demo05Producer {\n\n    @Autowired\n    private BatchingRabbitTemplate batchingRabbitTemplate;\n\n    public void syncSend(Integer id) {\n        // 创建 Demo05Message 消息\n        Demo05Message message = new Demo05Message();\n        message.setId(id);\n        // 同步发送消息\n        batchingRabbitTemplate.convertAndSend(Demo05Message.EXCHANGE, Demo05Message.ROUTING_KEY, message);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("看起来和我们在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("提供的发送消息的方法，除了换成了 BatchingRabbitTemplate 来发送消息，其它都是一致的。😈 对的，这也是为什么艿艿在上文说到，Spring-AMQP 是“"),r("strong",[e._v("偷偷")]),e._v("”收集来实现批量发送，对于我们使用发送消息的方法，还是一致的。")])]),e._v(" "),r("p",[e._v("BatchingRabbitTemplate 通过重写 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/BatchingRabbitTemplate.java#L76-L99",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("#send(String exchange, String routingKey, Message message, CorrelationData correlationData)")]),r("OutboundLink")],1),e._v(" "),r("strong",[e._v("核心")]),e._v("方法，实现批量发送的功能。感兴趣的胖友，可以自己去研究下源码，不复杂哈~")]),e._v(" "),r("h2",{attrs:{id:"_4-6-demo05consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-demo05consumer"}},[e._v("#")]),e._v(" 4.6 Demo05Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo05Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo05Consumer.java\n\n@Component\n@RabbitListener(queues = Demo05Message.QUEUE)\npublic class Demo05Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo05Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.7 Demo01Consumer」"),r("OutboundLink")],1),e._v("基本一致，差别在于消费的队列是 "),r("code",[e._v('"QUEUE_DEMO_02"')]),e._v(" 。")])]),e._v(" "),r("h2",{attrs:{id:"_4-7-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-简单测试"}},[e._v("#")]),e._v(" 4.7 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo05ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写单元测试方法，测试 Producer 批量发送消息的效果。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo05ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo05ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo05Producer producer;\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        for (int i = 0; i < 3; i++) {\n            // 同步发送消息\n            int id = (int) (System.currentTimeMillis() / 1000);\n            producer.syncSend(id);\n\n            // 故意每条消息之间，隔离 10 秒\n            logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n            Thread.sleep(10 * 1000L);\n        }\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("同步发送三条消息，每次发送消息之间，都故意 sleep 10 秒。😈 目的是，恰好满足我们配置的 "),r("code",[e._v("timeout")]),e._v(" 最大等待时长。")])]),e._v(" "),r("p",[e._v("我们来执行 "),r("code",[e._v("#testASyncSend()")]),e._v(" 方法，测试批量发送消息。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Producer 成功同步发送了 3 条消息，每条间隔 10 秒。\n2019-12-15 16:50:15.419  INFO 94085 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575967815] 发送成功]\n2019-12-15 16:50:25.426  INFO 94085 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575967825] 发送成功]\n2019-12-15 16:50:35.427  INFO 94085 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575967835] 发送成功]\n\n// Demo05Consumer 在最后一条消息发送成功后果的 30 秒，消费到这 3 条消息。\n2019-12-15 16:51:05.449  INFO 94085 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息内容：Demo05Message{id=1575967815}]\n2019-12-15 16:51:05.450  INFO 94085 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息内容：Demo05Message{id=1575967825}]\n2019-12-15 16:51:05.450  INFO 94085 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息内容：Demo05Message{id=1575967835}]\n")])])]),r("ul",[r("li",[e._v("因为使用 BatchingRabbitTemplate 批量发送消息，所以在 Producer 成功发送完第一条消息后，Consumer 并未消费到这条消息。")]),e._v(" "),r("li",[e._v("又因为 BatchingRabbitTemplate 是按照每次发送后，都重新计时，所以在最后一条消息成功发送后的 30 秒，Consumer 才消费到批量发送的 3 条消息。")])]),e._v(" "),r("h1",{attrs:{id:"_5-批量消费消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-批量消费消息"}},[e._v("#")]),e._v(" 5. 批量消费消息")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-batch-consume"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4. 批量发送消息」"),r("OutboundLink")],1),e._v("小节，我们已经实现批量发送消息到 RabbitMQ Broker 中。那么，我们来思考一个问题，这批消息在 RabbitMQ Broker 到底是存储"),r("strong",[e._v("一条")]),e._v("消息，还是"),r("strong",[e._v("多条")]),e._v("消息？")]),e._v(" "),r("ul",[r("li",[e._v("如果胖友使用过 Kafka、RocketMQ 这两个消息队列，那么判断肯定会是"),r("strong",[e._v("多条")]),e._v("消息。")]),e._v(" "),r("li",[e._v("从"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4.6 Demo05Consumer」"),r("OutboundLink")],1),e._v("中，我们可以看到"),r("strong",[e._v("逐条")]),e._v("消息的消费，也会认为是"),r("strong",[e._v("多条")]),e._v("消息。")])]),e._v(" "),r("p",[e._v("😭 实际上，RabbitMQ Broker 存储的是"),r("strong",[e._v("一条")]),e._v("消息。又或者说，"),r("strong",[e._v("RabbitMQ 并没有提供批量接收消息的 API 接口")]),e._v("。")]),e._v(" "),r("p",[e._v("那么，为什么我们在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4. 批量发送消息」"),r("OutboundLink")],1),e._v("能够实现呢？答案是批量发送消息是 Spring-AMQP 的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SimpleBatchingStrategy"),r("OutboundLink")],1),e._v(" 所封装提供：")]),e._v(" "),r("ul",[r("li",[e._v("在 Producer 最终批量发送消息时，SimpleBatchingStrategy 会通过 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java#L141-L156",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("#assembleMessage()")]),r("OutboundLink")],1),e._v(" 方法，将批量发送的"),r("strong",[e._v("多条")]),e._v("消息"),r("strong",[e._v("组装")]),e._v("成一条“批量”消息，然后进行发送。")]),e._v(" "),r("li",[e._v("在 Consumer 拉取到消息时，会根据"),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java#L158-L163",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("#canDebatch(MessageProperties properties)")]),r("OutboundLink")],1),e._v(" 方法，判断该消息是否为一条“批量”消息？如果是，则调用"),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java#L165-L194",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("# deBatch(Message message, Consumer fragmentConsumer)")]),r("OutboundLink")],1),e._v(" 方法，将一条“批量”消息"),r("strong",[e._v("拆开")]),e._v("，变成"),r("strong",[e._v("多条")]),e._v("消息。")])]),e._v(" "),r("blockquote",[r("p",[e._v("这个操作，是不是略微有点骚气？！艿艿在这里卡了很久！！！莫名其妙的~一直以为，RabbitMQ 提供了批量发送消息的 API 接口啊。")]),e._v(" "),r("p",[e._v("OK ，虽然很悲伤，但是我们还是回到这个小节的主题。")])]),e._v(" "),r("p",[e._v("在一些业务场景下，我们希望使用 Consumer 批量消费消息，提高消费速度。在 Spring-AMQP 中，提供了两种批量消费消息的方式。本小节，我们先来看第一种，它需要基于"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4. 批量发送消息」"),r("OutboundLink")],1),e._v("之上实现。")]),e._v(" "),r("p",[e._v("在 SimpleBatchingStrategy 将一条“批量”消息拆开，变成多条消息后，直接"),r("strong",[e._v("批量")]),e._v("交给 Consumer 进行消费处理。")]),e._v(" "),r("p",[e._v("下面，我们来实现一个 Consumer 批量消费消息的示例。考虑到不污染"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4. 批量发送消息」"),r("OutboundLink")],1),e._v(" 的示例，我们在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-batch"),r("OutboundLink")],1),e._v(" 项目的基础上，复制出一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-batch-consume"),r("OutboundLink")],1),e._v(" 项目。😈 酱紫，我们也能少写点代码，哈哈哈~")]),e._v(" "),r("h2",{attrs:{id:"_5-1-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-rabbitconfig"}},[e._v("#")]),e._v(" 5.1 RabbitConfig")]),e._v(" "),r("p",[e._v("修改 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加自定义的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/config/SimpleRabbitListenerContainerFactory.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SimpleRabbitListenerContainerFactory"),r("OutboundLink")],1),e._v(" Bean ，支持用于创建"),r("strong",[e._v("支持批量消费")]),e._v("的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SimpleRabbitListenerContainer"),r("OutboundLink")],1),e._v(" 。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// RabbitConfig.java\n\n@Bean(name = "consumerBatchContainerFactory")\npublic SimpleRabbitListenerContainerFactory consumerBatchContainerFactory(\n        SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {\n    // 创建 SimpleRabbitListenerContainerFactory 对象\n    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n    configurer.configure(factory, connectionFactory);\n    // <X> 额外添加批量消费的属性\n    factory.setBatchListener(true);\n    return factory;\n}\n')])])]),r("ul",[r("li",[e._v("在 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAnnotationDrivenConfiguration.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitAnnotationDrivenConfiguration"),r("OutboundLink")],1),e._v(" 自动化配置类中，它会默认创建一个名字为 "),r("code",[e._v('"rabbitListenerContainerFactory"')]),e._v(" 的 SimpleRabbitListenerContainerFactory Bean ，可用于消费者的监听器是"),r("strong",[e._v("单个")]),e._v("消费消费的。")]),e._v(" "),r("li",[e._v("我们自定义创建的一个名字为"),r("code",[e._v('"consumerBatchContainerFactory"')]),e._v(" 的 SimpleRabbitListenerContainerFactory Bean ，可用于消费者的监听器是"),r("strong",[e._v("批量")]),e._v("消费消费的。重点是 "),r("code",[e._v("<X>")]),e._v(" 处，配置消费者的监听器是"),r("strong",[e._v("批量")]),e._v("消费消息的类型，其它的可以暂时不用理解。")])]),e._v(" "),r("h2",{attrs:{id:"_5-2-demo05consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-demo05consumer"}},[e._v("#")]),e._v(" 5.2 Demo05Consumer")]),e._v(" "),r("p",[e._v("修改 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo05Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05Consumer"),r("OutboundLink")],1),e._v(" 类，"),r("strong",[e._v("批量")]),e._v("消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo05Consumer.java\n\n@Component\n@RabbitListener(queues = Demo05Message.QUEUE,\n    containerFactory = "consumerBatchContainerFactory")\npublic class Demo05Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(List<Demo05Message> messages) {\n        logger.info("[onMessage][线程编号:{} 消息数量：{}]", Thread.currentThread().getId(), messages.size());\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在类上的 "),r("code",[e._v("@@RabbitListener")]),e._v(" 注解的 "),r("code",[e._v("containerFactory")]),e._v(" 属性，设置了我们在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「5.1 RabbitConfig」"),r("OutboundLink")],1),e._v("创建的 SimpleRabbitListenerContainerFactory Bean ，表示它要批量消费消息。")]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v("#onMessage(...)")]),e._v(" 消费方法上，修改方法入参的类型为 List 数组。")])]),e._v(" "),r("h2",{attrs:{id:"_5-3-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-简单测试"}},[e._v("#")]),e._v(" 5.3 简单测试")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4.7 简单测试」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo05ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05ProducerTest"),r("OutboundLink")],1),e._v(" 单元测试类。")]),e._v(" "),r("p",[e._v("我们来执行 "),r("code",[e._v("#testASyncSend()")]),e._v(" 方法，测试批量消费消息。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Producer 成功同步发送了 3 条消息，每条间隔 10 秒。\n2019-12-15 22:42:08.755  INFO 60216 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575988928] 发送成功]\n2019-12-15 22:42:18.757  INFO 60216 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575988938] 发送成功]\n2019-12-15 22:42:28.758  INFO 60216 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575988948] 发送成功]\n\n// Demo05Consumer 在最后一条消息发送成功后果的 30 秒，一次性批量消费了这 3 条消息。\n2019-12-15 22:42:58.775  INFO 60216 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息数量：3]\n")])])]),r("ul",[r("li",[e._v("符合预期，Demo05Consumer 批量消费了 3 条消息。")])]),e._v(" "),r("h1",{attrs:{id:"_6-批量消费消息-第二弹"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-批量消费消息-第二弹"}},[e._v("#")]),e._v(" 6. 批量消费消息（第二弹）")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-batch-consume-02"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「5. 批量消费消息」"),r("OutboundLink")],1),e._v("小节，我们已经学习了一种批量消费消息的方式。因为其依赖"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「4. 批量发送消息」"),r("OutboundLink")],1),e._v("的功能，有点过于苛刻。所以，Spring-AMQP 提供了第二种批量消费消息的方式。")]),e._v(" "),r("p",[e._v("其实现方式是，阻塞等待最多 "),r("code",[e._v("receiveTimeout")]),e._v(" 秒，拉取 "),r("code",[e._v("batchSize")]),e._v(" 条消息，进行批量消费。")]),e._v(" "),r("ul",[r("li",[e._v("如果在 "),r("code",[e._v("receiveTimeout")]),e._v(" 秒内已经成功拉取到 "),r("code",[e._v("batchSize")]),e._v(" 条消息，则直接进行批量消费消息。")]),e._v(" "),r("li",[e._v("如果在 "),r("code",[e._v("receiveTimeout")]),e._v(" 秒还没拉取到 "),r("code",[e._v("batchSize")]),e._v(" 条消息，不再等待，而是进行批量消费消息。")])]),e._v(" "),r("p",[e._v("不过 Spring-AMQP 的阻塞等待时长 "),r("code",[e._v("receiveTimeout")]),e._v(" 的设计有点“神奇”。")]),e._v(" "),r("ul",[r("li",[e._v("它代表的是，每次拉取一条消息，最多阻塞等待 "),r("code",[e._v("receiveTimeout")]),e._v(" 时长。如果等待不到下一条消息，则进入已获取到的消息的批量消费。😈 也就是说，极端情况下，可能等待 "),r("code",[e._v("receiveTimeout * batchSize")]),e._v(" 时长，才会进行批量消费。")]),e._v(" "),r("li",[e._v("感兴趣的朋友，可以点击 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java#L922",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("SimpleMessageListenerContainer#doReceiveAndExecute(BlockingQueueConsumer consumer)")]),r("OutboundLink")],1),e._v(" 方法，简单阅读源码，即可快速理解。")])]),e._v(" "),r("p",[e._v("下面，我们来实现一个 Consumer 批量消费消息的示例。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-batch-consume-02"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_6-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-引入依赖"}},[e._v("#")]),e._v(" 6.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_6-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-应用配置文件"}},[e._v("#")]),e._v(" 6.2 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_6-3-demo06message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-demo06message"}},[e._v("#")]),e._v(" 6.3 Demo06Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo06Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo06Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_6-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-rabbitconfig"}},[e._v("#")]),e._v(" 6.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加自定义的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/config/SimpleRabbitListenerContainerFactory.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SimpleRabbitListenerContainerFactory"),r("OutboundLink")],1),e._v(" Bean ，支持用于创建"),r("strong",[e._v("支持批量消费")]),e._v("的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SimpleRabbitListenerContainer"),r("OutboundLink")],1),e._v(" 。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// RabbitConfig.java\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo06Queue() {\n            return new Queue(Demo06Message.QUEUE, // Queue 名字\n                    true, // durable: 是否持久化\n                    false, // exclusive: 是否排它\n                    false); // autoDelete: 是否自动删除\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo06Exchange() {\n            return new DirectExchange(Demo06Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        // Exchange：Demo06Message.EXCHANGE\n        // Routing key：Demo06Message.ROUTING_KEY\n        // Queue：Demo06Message.QUEUE\n        @Bean\n        public Binding demo06Binding() {\n            return BindingBuilder.bind(demo06Queue()).to(demo06Exchange()).with(Demo06Message.ROUTING_KEY);\n        }\n\n    }\n\n    @Bean(name = "consumerBatchContainerFactory")\n    public SimpleRabbitListenerContainerFactory consumerBatchContainerFactory(\n            SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {\n        // 创建 SimpleRabbitListenerContainerFactory 对象\n        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n        configurer.configure(factory, connectionFactory);\n        // 额外添加批量消费的属性\n        factory.setBatchListener(true);\n        // <X>\n        factory.setBatchSize(10);\n        factory.setReceiveTimeout(30 * 1000L);\n        factory.setConsumerBatchEnabled(true);\n        return factory;\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("DirectExchangeDemoConfiguration 配置类，用于定义 Queue、Exchange、Binding 的配置。")]),e._v(" "),r("li",[e._v("相比"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「5.1 RabbitConfig」"),r("OutboundLink")],1),e._v("来说，额外增加了 "),r("code",[e._v("batchSize = 10")]),e._v("、"),r("code",[e._v("receiveTimeout = 30 * 1000L")]),e._v("、"),r("code",[e._v("consumerBatchEnabled = 30 * 1000L")]),e._v(" 属性。😈 严格意义上来说，"),r("strong",[e._v("本小节才是真正意义上的批量消费消息")]),e._v("。")])]),e._v(" "),r("h2",{attrs:{id:"_6-5-demo06producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-demo06producer"}},[e._v("#")]),e._v(" 6.5 Demo06Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo06Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo06Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_6-6-demo06consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-demo06consumer"}},[e._v("#")]),e._v(" 6.6 Demo06Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo05Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05Consumer"),r("OutboundLink")],1),e._v(" 类，"),r("strong",[e._v("批量")]),e._v("消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo06Consumer.java\n\n@Component\n@RabbitListener(queues = Demo06Message.QUEUE,\n    containerFactory = "consumerBatchContainerFactory")\npublic class Demo06Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(List<Demo06Message> messages) {\n        logger.info("[onMessage][线程编号:{} 消息数量：{}]", Thread.currentThread().getId(), messages.size());\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「5.2 Demo05Consumer」"),r("OutboundLink")],1),e._v("一致，只差在消费不同的队列。")])]),e._v(" "),r("h2",{attrs:{id:"_6-7-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-简单测试"}},[e._v("#")]),e._v(" 6.7 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo06ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo06ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写单元测试方法，测试 Consumer 批量消费消息的效果。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo06ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo06ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo06Producer producer;\n\n    @Test\n    public void testSyncSend01() throws InterruptedException {\n        // 发送 3 条消息\n        this.testSyncSend(3);\n    }\n\n    @Test\n    public void testSyncSen02() throws InterruptedException {\n        // 发送 10 条消息\n        this.testSyncSend(10);\n    }\n\n    private void testSyncSend(int n) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            // 同步发送消息\n            int id = (int) (System.currentTimeMillis() / 1000);\n            producer.syncSend(id);\n            logger.info("[testSyncSendMore][发送编号：[{}] 发送成功]", id);\n        }\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("ul",[r("li",[r("code",[e._v("#testSyncSend01()")]),e._v(" 方法，发送 3 条消息，测试 Demo06Consumer 获取数量为 "),r("code",[e._v("batchSize = 10")]),e._v(" 消息，"),r("strong",[e._v("超时")]),e._v("情况下的批量消费。")]),e._v(" "),r("li",[r("code",[e._v("#testSyncSend02()")]),e._v(" 方法，发送 10 条消息，测试 Demo06Consumer 获取数量为 "),r("code",[e._v("batchSize = 10")]),e._v(" 消息，"),r("strong",[e._v("未超时")]),e._v("情况下的批量消费。")])]),e._v(" "),r("p",[e._v("我们来执行 "),r("code",[e._v("#testSyncSend01()")]),e._v(" 方法，"),r("strong",[e._v("超时")]),e._v("情况下的批量消费。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Producer 成功同步发送了 3 条消息\n2019-12-15 00:01:18.097  INFO 78389 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993678] 发送成功]\n2019-12-15 00:01:18.099  INFO 78389 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993678] 发送成功]\n2019-12-15 00:01:18.099  INFO 78389 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993678] 发送成功]\n\n// Consumer 30 秒超时等待后，批量消费到 3 条消息\n2019-12-15 00:01:48.116  INFO 78389 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo06Consumer        : [onMessage][线程编号:17 消息数量：3]\n")])])]),r("ul",[r("li",[e._v("符合预期。具体胖友看下日志上的注释说明。")])]),e._v(" "),r("p",[e._v("我们来执行 "),r("code",[e._v("#testSyncSend02()")]),e._v(" 方法，"),r("strong",[e._v("未超时")]),e._v("情况下的批量消费。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Producer 成功同步发送了 10 条消息\n2019-12-15 00:03:50.406  INFO 78997 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993830] 发送成功]\n// ... 省略 8 条消息\n2019-12-15 00:03:50.410  INFO 78997 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993830] 发送成功]\n\n// Consumer 拉取到 10 条消息后，立即批量消费到 10 条消息\n2019-12-15 00:03:50.429  INFO 78997 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo06Consumer        : [onMessage][线程编号:17 消息数量：10\n")])])]),r("ul",[r("li",[e._v("符合预期。具体胖友看下日志上的注释说明。")])]),e._v(" "),r("p",[e._v("😈 至此，我们已经完成了两种 Spring-AMQP 的批量消费消费的方法。更多的内容，可以看看 "),r("a",{attrs:{href:"https://docs.spring.io/spring-amqp/docs/current/reference/html/#receiving-batch",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Spring-AMQP 官方文档 —— @RabbitListener with Batching》"),r("OutboundLink")],1),e._v(" 文档。")]),e._v(" "),r("h2",{attrs:{id:"有个小坑"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有个小坑"}},[e._v("#")]),e._v(" 有个小坑")]),e._v(" "),r("p",[e._v("RabbitMQ 批量消费是基于缓冲区的，且需要在同一线程下。")]),e._v(" "),r("p",[e._v("经过测试当发送的数据是10条时，mq分了两个线程去消费：28号线程消费5个，25号线程消费5个，这个时候不会触发BatchSize，也就是仍然需要等到超时了才会消费。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/image-20231213145544351.png",alt:""}})]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/image-20231213145556000.png",alt:""}})]),e._v(" "),r("h1",{attrs:{id:"_7-消费重试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-消费重试"}},[e._v("#")]),e._v(" 7. 消费重试")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-consume-retry"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("在开始本小节之前，胖友首先要对 RabbitMQ 的"),r("a",{attrs:{href:"https://www.rabbitmq.com/dlx.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("死信队列"),r("OutboundLink")],1),e._v("的机制，有一定的了解。不了解的胖友，可以看看"),r("a",{attrs:{href:"http://www.iocoder.cn/RabbitMQ/dead-letter-queue/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《RabbitMQ 之死信队列》"),r("OutboundLink")],1),e._v("文章。")]),e._v(" "),r("p",[e._v("在消息"),r("strong",[e._v("消费失败")]),e._v("的时候，Spring-AMQP 会通过"),r("strong",[e._v("消费重试")]),e._v("机制，重新投递该消息给 Consumer ，让 Consumer 有机会重新消费消息，实现消费成功。")]),e._v(" "),r("p",[e._v("当然，Spring-AMQP 并不会无限重新投递消息给 Consumer 重新消费，而是在默认情况下，达到 N 次重试次数时，Consumer 还是消费失败时，该消息就会进入到"),r("strong",[e._v("死信队列")]),e._v("。后续，我们可以通过对死信队列中的消息进行重发，来使得消费者实例再次进行消费。")]),e._v(" "),r("ul",[r("li",[e._v("在"),r("a",{attrs:{href:"http://www.iocoder.cn/Spring-Boot/RocketMQ/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《芋道 Spring Boot 消息队列 RocketMQ 入门》"),r("OutboundLink")],1),e._v("的"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「6. 消费重试」"),r("OutboundLink")],1),e._v("小节中，我们可以看到，消费重试和死信队列，是 RocketMQ 自带的功能。")]),e._v(" "),r("li",[e._v("而在 RabbitMQ 中，消费重试是由 Spring-AMQP 所封装提供的，死信队列是 RabbitMQ 自带的功能。")])]),e._v(" "),r("p",[e._v("那么消费失败到达最大次数的消息，是怎么进入到死信队列的呢？Spring-AMQP 在消息到达最大消费次数的时候，会将该消息进行否定("),r("code",[e._v("basic.nack")]),e._v(")，并且 "),r("code",[e._v("requeue=false")]),e._v(" ，这样后续就可以利用 RabbitMQ 的"),r("a",{attrs:{href:"https://www.rabbitmq.com/dlx.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("死信队列"),r("OutboundLink")],1),e._v("的机制，将该消息转发到死信队列。")]),e._v(" "),r("p",[e._v("另外，每条消息的失败重试，是可以配置一定的"),r("strong",[e._v("间隔时间")]),e._v("。具体，我们在示例的代码中，来进行具体的解释。")]),e._v(" "),r("p",[e._v("下面，我们来实现一个 Consumer 消费重试的示例。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-consume-retry"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_7-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-引入依赖"}},[e._v("#")]),e._v(" 7.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_7-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-应用配置文件"}},[e._v("#")]),e._v(" 7.2 应用配置文件")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/resources",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("resources")]),r("OutboundLink")],1),e._v(" 目录下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 配置文件。配置如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("spring:\n  # RabbitMQ 配置项，对应 RabbitProperties 配置类\n  rabbitmq:\n    host: 127.0.0.1 # RabbitMQ 服务的地址\n    port: 5672 # RabbitMQ 服务的端口\n    username: guest # RabbitMQ 服务的账号\n    password: guest # RabbitMQ 服务的密码\n    listener:\n      simple:\n        # 对应 RabbitProperties.ListenerRetry 类\n        retry:\n          enabled: true # 开启消费重试机制\n          max-attempts: 3 # 最大重试次数。默认为 3 。\n          initial-interval: 1000 # 重试间隔，单位为毫秒。默认为 1000 。\n")])])]),r("ul",[r("li",[r("p",[e._v("相比"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v("来说，我们通过"),r("strong",[e._v("新增")]),e._v(" "),r("code",[e._v("spring.rabbitmq.simple.retry.enable=true")]),e._v(" 配置项，来开启 Spring-AMQP 的消费重试的功能。同时，通过"),r("strong",[e._v("新增")]),e._v(" "),r("code",[e._v("max-attempts")]),e._v(" 和 "),r("code",[e._v("initial-interval")]),e._v(" 配置项，设置重试次数和间隔。")]),e._v(" "),r("blockquote",[r("p",[r("code",[e._v("max-attempts")]),e._v(" 配置项要注意，是一条消息一共尝试消费总共 "),r("code",[e._v("max-attempts")]),e._v(" 次，包括首次的正常消费。")])])]),e._v(" "),r("li",[r("p",[e._v("另外，胖友可以通过添加 "),r("code",[e._v("spring.rabbitmq.listener.simple.retry.multiplier")]),e._v(" 配置项来实现"),r("strong",[e._v("递乘")]),e._v("的时间间隔，添加 "),r("code",[e._v("spring.rabbitmq.listener.simple.retry.max-interval")]),e._v(" 配置项来实现"),r("strong",[e._v("最大")]),e._v("的时间间隔。")])])]),e._v(" "),r("p",[e._v("在 Spring-AMQP 的消费重试机制中，在消费失败到达最大次数后，会"),r("strong",[e._v("自动")]),e._v("抛出 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/AmqpRejectAndDontRequeueException.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("AmqpRejectAndDontRequeueException"),r("OutboundLink")],1),e._v(" 异常，从而结束该消息的消费重试。这意味着什么呢？如果我们在消费消息的逻辑中，"),r("strong",[e._v("主动")]),e._v("抛出 AmqpRejectAndDontRequeueException 异常，也能结束该消息的消费重试。😈 结束的方式，Spring-AMQP 是通过我们在上文中提到的 "),r("code",[e._v("basic.nack")]),e._v(" + "),r("code",[e._v("requeue=false")]),e._v(" ，从而实现转发该消息到死信队列中。")]),e._v(" "),r("p",[e._v("另外，默认情况下，"),r("code",[e._v("spring.rabbitmq.simple.retry.enable=false")]),e._v(" ，关闭 Spring-AMQP 的消费重试功能。但是实际上，消费发生异常的消息，还是会一直"),r("strong",[e._v("重新消费")]),e._v("。这是为什么呢？Spring-AMQP 会将该消息通过 "),r("code",[e._v("basic.nack")]),e._v(" + "),r("code",[e._v("requeue=true")]),e._v(" ，重新投递回"),r("strong",[e._v("原队列的尾巴")]),e._v("。如此，我们便会不断拉取到该消息，不断“重试”消费该消息。当然在这种情况下，我们一样可以"),r("strong",[e._v("主动")]),e._v("抛出 AmqpRejectAndDontRequeueException 异常，也能结束该消息的消费重试。😈 结束的方式，Spring-AMQP 也是通过我们在上文中提到的 "),r("code",[e._v("basic.nack")]),e._v(" + "),r("code",[e._v("requeue=false")]),e._v(" ，从而实现转发该消息到死信队列中。")]),e._v(" "),r("p",[e._v("这里，我们再来简单说说 Spring-AMQP 是怎么提供"),r("strong",[e._v("消费重试")]),e._v("的功能的。")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Spring-AMQP 基于 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-retry",target:"_blank",rel:"noopener noreferrer"}},[e._v("spring-retry"),r("OutboundLink")],1),e._v(" 项目提供的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/support/RetryTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RetryTemplate"),r("OutboundLink")],1),e._v(" ，实现重试功能。Spring-AMQP 在获取到消息时，会交给 RetryTemplate 来调用消费者 Consumer 的监听器 Listener(就是我们实现的)，实现该消息的"),r("strong",[e._v("多次")]),e._v("消费重试。")])]),e._v(" "),r("li",[r("p",[e._v("在该消息的"),r("strong",[e._v("每次消费失败")]),e._v("后，RetryTemplate 会通过 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/backoff/BackOffPolicy.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("BackOffPolicy"),r("OutboundLink")],1),e._v(" 来进行计算，该消息的"),r("strong",[e._v("下一次重新消费的时间")]),e._v("，通过 "),r("code",[e._v("Thread#sleep(...)")]),e._v(" 方法，实现重新消费的时间间隔。到达时间间隔后，RetryTemplate 又会调用消费者 Consumer 的监听器 Listener 来消费该消息。")])]),e._v(" "),r("li",[r("p",[e._v("当该消息的重试消费到达"),r("strong",[e._v("上限")]),e._v("后，RetryTemplate 会调用 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/interceptor/MethodInvocationRecoverer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("MethodInvocationRecoverer"),r("OutboundLink")],1),e._v(" 回调来实现恢复。而 Spring-AMQP 自定义实现了 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/retry/RejectAndDontRequeueRecoverer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RejectAndDontRequeueRecoverer"),r("OutboundLink")],1),e._v(" 来"),r("strong",[e._v("自动")]),e._v("抛出 AmqpRejectAndDontRequeueException 异常，从而结束该消息的消费重试。😈 结束的方式，Spring-AMQP 是通过我们在上文中提到的 "),r("code",[e._v("basic.nack")]),e._v(" + "),r("code",[e._v("requeue=false")]),e._v(" ，从而实现转发该消息到死信队列中。")])]),e._v(" "),r("li",[r("p",[e._v("有一点需要注意，Spring-AMQP 提供的消费重试的"),r("strong",[e._v("计数")]),e._v("是"),r("strong",[e._v("客户端")]),e._v("级别的，重启 JVM 应用后，计数是会丢失的。所以，如果想要计数进行持久化，需要自己重新实现下。")]),e._v(" "),r("blockquote",[r("p",[e._v("😈 RocketMQ 提供的消费重试的计数，目前是"),r("strong",[e._v("服务端")]),e._v("级别，已经进行持久化。")])])])]),e._v(" "),r("blockquote",[r("p",[e._v("😜 瞎哔哔了好长一段，涉及到的信息量可能比较大，如果艿艿有解释不清晰或者错误的地方，又或者哪里不了解，可以给艿艿留言，乐意之至为胖友解答。")]),e._v(" "),r("p",[e._v("同时，也可以调试下整个过程涉及到的源码，更加具象下。「源码之前，了无秘密」。")])]),e._v(" "),r("h2",{attrs:{id:"_7-3-demo07message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-demo07message"}},[e._v("#")]),e._v(" 7.3 Demo07Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo07Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo07Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo07Message.java\n\n\n    public static final String QUEUE = "QUEUE_DEMO_07"; // 正常队列\n    public static final String DEAD_QUEUE = "DEAD_QUEUE_DEMO_07"; // 死信队列\n\n    public static final String EXCHANGE = "EXCHANGE_DEMO_07";\n\n    public static final String ROUTING_KEY = "ROUTING_KEY_07"; // 正常路由键\n    public static final String DEAD_ROUTING_KEY = "DEAD_ROUTING_KEY_07"; // 死信路由键\n\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("相比"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v("来说，额外增加了死信队列会用到的 Queue 和 RoutingKey ，而 Exchange 我们先复用 "),r("code",[e._v('EXCHANGE = "EXCHANGE_DEMO_07"')]),e._v(" 。")])]),e._v(" "),r("h2",{attrs:{id:"_7-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-rabbitconfig"}},[e._v("#")]),e._v(" 7.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，额外添加"),r("strong",[e._v("死信队列")]),e._v("的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo07Queue() {\n            return QueueBuilder.durable(Demo07Message.QUEUE) // durable: 是否持久化\n                    .exclusive() // exclusive: 是否排它\n                    .autoDelete() // autoDelete: 是否自动删除\n                    .deadLetterExchange(Demo07Message.EXCHANGE)\n                    .deadLetterRoutingKey(Demo07Message.DEAD_ROUTING_KEY)\n                    .build();\n        }\n\n        // 创建 Dead Queue\n        @Bean\n        public Queue demo07DeadQueue() {\n            return new Queue(Demo07Message.DEAD_QUEUE, // Queue 名字\n                    true, // durable: 是否持久化\n                    false, // exclusive: 是否排它\n                    false); // autoDelete: 是否自动删除\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo07Exchange() {\n            return new DirectExchange(Demo07Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        // Exchange：Demo07Message.EXCHANGE\n        // Routing key：Demo07Message.ROUTING_KEY\n        // Queue：Demo07Message.QUEUE\n        @Bean\n        public Binding demo07Binding() {\n            return BindingBuilder.bind(demo07Queue()).to(demo07Exchange()).with(Demo07Message.ROUTING_KEY);\n        }\n\n        // 创建 Dead Binding\n        // Exchange：Demo07Message.EXCHANGE\n        // Routing key：Demo07Message.DEAD_ROUTING_KEY\n        // Queue：Demo07Message.DEAD_QUEUE\n        @Bean\n        public Binding demo07DeadBinding() {\n            return BindingBuilder.bind(demo07DeadQueue()).to(demo07Exchange()).with(Demo07Message.DEAD_ROUTING_KEY);\n        }\n\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("相比"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.5 RabbitConfig」"),r("OutboundLink")],1),e._v("来说，主要有"),r("strong",[e._v("两个")]),e._v("差异点。")]),e._v(" "),r("li",[e._v("第一点，创建的正常 Queue 额外设置了，当消息成为死信时，RabbitMQ 自动转发到 Exchange 为 "),r("code",[e._v("Demo07Message.EXCHANGE")]),e._v("，RoutingKey 为 "),r("code",[e._v("Demo07Message.DEAD_ROUTING_KEY")]),e._v(" 的死信队列中。")]),e._v(" "),r("li",[e._v("第二点，通过 "),r("code",[e._v("#demo07DeadQueue()")]),e._v(" 方法来创建死信队列的 Queue ，通过 "),r("code",[e._v("#demo07DeadBinding()")]),e._v(" 方法来创建死信队列的 Binding 。😈 因为我们重用了 Exchange 为 "),r("code",[e._v("Demo07Message.EXCHANGE")]),e._v(" ，所以无需创建。当然，胖友也可以根据自己的需要，创建死信队列的 Exchange 。")])]),e._v(" "),r("h2",{attrs:{id:"_7-5-demo07producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-demo07producer"}},[e._v("#")]),e._v(" 7.5 Demo07Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo07Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo07Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_7-6-demo07consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-demo07consumer"}},[e._v("#")]),e._v(" 7.6 Demo07Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo07Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo07Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo07Consumer.java\n\n@Component\n@RabbitListener(queues = Demo07Message.QUEUE)\npublic class Demo07Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo07Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n        // <X> 注意，此处抛出一个 RuntimeException 异常，模拟消费失败\n        throw new RuntimeException("我就是故意抛出一个异常");\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在 "),r("code",[e._v("<X>")]),e._v(" 处，我们在消费消息时候，抛出一个 RuntimeException 异常，模拟消费失败。")])]),e._v(" "),r("h2",{attrs:{id:"_7-7-demo07deadconsumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-7-demo07deadconsumer"}},[e._v("#")]),e._v(" 7.7 Demo07DeadConsumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo07DeadConsumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo07DeadConsumer"),r("OutboundLink")],1),e._v(" 类，消费"),r("strong",[e._v("死信队列")]),e._v("的消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo07DeadConsumer.java\n\n@Component\n@RabbitListener(queues = Demo07Message.DEAD_QUEUE)\npublic class Demo07DeadConsumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo07Message message) {\n        logger.info("[onMessage][【死信队列】线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在类上，添加了 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitListener.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("@RabbitListener")]),r("OutboundLink")],1),e._v(" 注解，声明了消费的队列是 "),r("code",[e._v('"DEAD_QUEUE_DEMO_07"')]),e._v(" 这个"),r("strong",[e._v("死信队列")]),e._v("。")])]),e._v(" "),r("p",[e._v("这里的消费逻辑，仅仅是示例，实现逻辑胖友根据自己的需要，自己来具体实现，嘿嘿。")]),e._v(" "),r("h2",{attrs:{id:"_7-8-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-8-简单测试"}},[e._v("#")]),e._v(" 7.8 简单测试")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.8 简单测试」"),r("OutboundLink")],1),e._v(" 大体一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo07ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo05ProducerTest"),r("OutboundLink")],1),e._v(" 单元测试类。")]),e._v(" "),r("p",[e._v("我们来执行 "),r("code",[e._v("#testSyncSend()")]),e._v(" 方法，测试 Consumer 消费重试的效果。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 成功同步发送了 1 条消息\n2019-12-15 14:21:40.424  INFO 66569 --- [           main] c.i.s.l.r.producer.Demo07ProducerTest    : [testSyncSend][发送编号：[1576045300] 发送成功]\n\n# Demo07Consumer 第 1 次消费\n2019-12-15 14:21:40.442  INFO 66569 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo07Consumer        : [onMessage][线程编号:17 消息内容：Demo07Message{id=1576045300}]\n# 一秒后，Consumer 第 2 次消费\n2019-12-15 14:21:41.446  INFO 66569 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo07Consumer        : [onMessage][线程编号:17 消息内容：Demo07Message{id=1576045300}]\n# 一秒后，Consumer 第 3 次消费\n2019-12-15 14:21:42.450  INFO 66569 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo07Consumer        : [onMessage][线程编号:17 消息内容：Demo07Message{id=1576045300}]\n\n# RejectAndDontRequeueRecoverer 打印该消息消费重试到达上限，同时打印异常堆栈\n2019-12-15 14:21:42.457  WARN 66569 --- [ntContainer#0-1] o.s.a.r.r.RejectAndDontRequeueRecoverer  : Retries exhausted for message (Body:'[B@514e3b1c(byte[187])' MessageProperties [headers={}, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=EXCHANGE_DEMO_07, receivedRoutingKey=ROUTING_KEY_07, deliveryTag=1, consumerTag=amq.ctag-UpkeXbl-7TYRNt_LuYDZJQ, consumerQueue=QUEUE_DEMO_07])\n// ... 省略一大堆异常堆栈\n\n# Demo07DeadConsumer 消费死信队列的该条消息\n2019-12-15 14:21:42.463  INFO 66569 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo07DeadConsumer    : [onMessage][【死信队列】线程编号:19 消息内容：Demo07Message{id=1576045300}]\n")])])]),r("ul",[r("li",[e._v("Demo07Consumer 重试消费消息 3 次，每次间隔 1 秒，全部都失败，最终该消息转发到死信队列中。")]),e._v(" "),r("li",[e._v("Demo07DeadConsumer 消费死信队列中的该消息。")])]),e._v(" "),r("h2",{attrs:{id:"_7-9-发送重试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-9-发送重试"}},[e._v("#")]),e._v(" 7.9 发送重试")]),e._v(" "),r("p",[e._v("在 Spring-AMQP 也提供了消息发送失败时的重试机制，也是基于 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-retry",target:"_blank",rel:"noopener noreferrer"}},[e._v("spring-retry"),r("OutboundLink")],1),e._v(" 项目提供的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/support/RetryTemplate.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RetryTemplate"),r("OutboundLink")],1),e._v(" 来实现。在 "),r("code",[e._v("application.yaml")]),e._v(" 配置如下即可：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("spring:\n  # RabbitMQ 配置项，对应 RabbitProperties 配置类\n  rabbitmq:\n    host: 127.0.0.1 # RabbitMQ 服务的地址\n    port: 5672 # RabbitMQ 服务的端口\n    username: guest # RabbitMQ 服务的账号\n    password: guest # RabbitMQ 服务的密码\n    template:\n      # 对应 RabbitProperties.Retry 类\n      retry:\n        enabled: true # 开启发送机制\n        max-attempts: 3 # 最大重试次数。默认为 3 。\n        initial-interval: 1000 # 重试间隔，单位为毫秒。默认为 1000 。\n")])])]),r("ul",[r("li",[r("p",[r("code",[e._v("spring.rabbitmq.template.enable=true")]),e._v(" 配置项，来开启 Spring-AMQP 的发送重试的功能。同时，通过"),r("strong",[e._v("新增")]),e._v(" "),r("code",[e._v("max-attempts")]),e._v(" 和 "),r("code",[e._v("initial-interval")]),e._v(" 配置项，设置重试次数和间隔。")]),e._v(" "),r("blockquote",[r("p",[r("code",[e._v("max-attempts")]),e._v(" 配置项要注意，是一条消息一共尝试消费总共 "),r("code",[e._v("max-attempts")]),e._v(" 次，包括首次的正常消费。")])])]),e._v(" "),r("li",[r("p",[e._v("另外，胖友可以通过添加 "),r("code",[e._v("spring.rabbitmq.template.retry.multiplier")]),e._v(" 配置项来实现"),r("strong",[e._v("递乘")]),e._v("的时间间隔，添加 "),r("code",[e._v("spring.rabbitmq.template.retry.max-interval")]),e._v(" 配置项来实现"),r("strong",[e._v("最大")]),e._v("的时间间隔。")])])]),e._v(" "),r("p",[e._v("这里艿艿就暂时不拓展开来讲，胖友可以自己尝试下哈。")]),e._v(" "),r("h1",{attrs:{id:"_8-定时消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-定时消息"}},[e._v("#")]),e._v(" 8. 定时消息")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-delay"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「7. 消费重试」"),r("OutboundLink")],1),e._v("小节中，我们看到 Spring-AMQP 基于 RabbitMQ 提供的"),r("strong",[e._v("死信队列")]),e._v("，通过 "),r("code",[e._v("basic.nack")]),e._v(" + "),r("code",[e._v("requeue=false")]),e._v(" 的方式，将重试消费到达上限次数的消息，投递到死信队列中。")]),e._v(" "),r("p",[e._v("本小节，我们还是基于 RabbitMQ 的"),r("strong",[e._v("死信队列")]),e._v("，实现"),r("strong",[e._v("定时消息")]),e._v("的功能。RabbitMQ 提供了过期时间 "),r("a",{attrs:{href:"https://www.rabbitmq.com/ttl.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("TTL"),r("OutboundLink")],1),e._v(" 机制，可以设置消息在队列中的存活时长。在消息到达过期时间时，会从当前队列中删除，并被 RabbitMQ 自动转发到对应的死信队列中。")]),e._v(" "),r("p",[e._v("那么，如果我们创建消费者 Consumer ，来消费该死信队列，是不是就实现了"),r("strong",[e._v("延迟队列")]),e._v("的效果。😈 如此，我们便实现了定时消息的功能。")]),e._v(" "),r("p",[e._v("下面，我们来实现一个定时消息的示例。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-delay"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_8-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-引入依赖"}},[e._v("#")]),e._v(" 8.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_8-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-应用配置文件"}},[e._v("#")]),e._v(" 8.2 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_8-3-demo08message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-demo08message"}},[e._v("#")]),e._v(" 8.3 Demo08Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo08Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo08Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo08Message.java\n\npublic class Demo08Message implements Serializable {\n\n    public static final String QUEUE = "QUEUE_DEMO_08"; // 正常队列\n    public static final String DELAY_QUEUE = "DELAY_QUEUE_DEMO_08"; // 延迟队列（死信队列）\n\n    public static final String EXCHANGE = "EXCHANGE_DEMO_08";\n\n    public static final String ROUTING_KEY = "ROUTING_KEY_08"; // 正常路由键\n    public static final String DELAY_ROUTING_KEY = "DELAY_ROUTING_KEY_08"; // 延迟路由键（死信路由键）\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("相比"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「8.3 Demo07Message」"),r("OutboundLink")],1),e._v("来说，基本一致，只是换了下命名，将 "),r("code",[e._v("DEAD")]),e._v(" 改成 "),r("code",[e._v("DELAY")]),e._v(" 来方便胖友理解。")])]),e._v(" "),r("h2",{attrs:{id:"_8-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-rabbitconfig"}},[e._v("#")]),e._v(" 8.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，额外添加"),r("strong",[e._v("延迟队列")]),e._v("（死信队列）的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo08Queue() {\n            return QueueBuilder.durable(Demo08Message.QUEUE) // durable: 是否持久化\n                    .exclusive() // exclusive: 是否排它\n                    .autoDelete() // autoDelete: 是否自动删除\n                    .ttl(10 * 1000) // 设置队列里的默认过期时间为 10 秒\n                    .deadLetterExchange(Demo08Message.EXCHANGE)\n                    .deadLetterRoutingKey(Demo08Message.DELAY_ROUTING_KEY)\n                    .build();\n        }\n\n        // 创建 Delay Queue\n        @Bean\n        public Queue demo08DelayQueue() {\n            return new Queue(Demo08Message.DELAY_QUEUE, // Queue 名字\n                    true, // durable: 是否持久化\n                    false, // exclusive: 是否排它\n                    false); // autoDelete: 是否自动删除\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo08Exchange() {\n            return new DirectExchange(Demo08Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        // Exchange：Demo08Message.EXCHANGE\n        // Routing key：Demo08Message.ROUTING_KEY\n        // Queue：Demo08Message.QUEUE\n        @Bean\n        public Binding demo08Binding() {\n            return BindingBuilder.bind(demo08Queue()).to(demo08Exchange()).with(Demo08Message.ROUTING_KEY);\n        }\n\n        // 创建 Delay Binding\n        // Exchange：Demo08Message.EXCHANGE\n        // Routing key：Demo08Message.DELAY_ROUTING_KEY\n        // Queue：Demo08Message.DELAY_QUEUE\n        @Bean\n        public Binding demo08DelayBinding() {\n            return BindingBuilder.bind(demo08DelayQueue()).to(demo08Exchange()).with(Demo08Message.DELAY_ROUTING_KEY);\n        }\n\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("相比"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「7.4 RabbitConfig」"),r("OutboundLink")],1),e._v("来说，主要有"),r("strong",[e._v("一个")]),e._v("差异点。在 "),r("code",[e._v("#demo08Queue()")]),e._v(" 方法来创建的 Queue ，我们设置了该队列的消息的默认过期时间为 10 秒。")])]),e._v(" "),r("h2",{attrs:{id:"_8-5-demo08producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-demo08producer"}},[e._v("#")]),e._v(" 8.5 Demo08Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo08Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo08Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Demo08Producer.java\n\n@Component\npublic class Demo08Producer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id, Integer delay) {\n        // 创建 Demo07Message 消息\n        Demo08Message message = new Demo08Message();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(Demo08Message.EXCHANGE, Demo08Message.ROUTING_KEY, message, new MessagePostProcessor() {\n\n            @Override\n            public Message postProcessMessage(Message message) throws AmqpException {\n                // 设置消息的 TTL 过期时间\n                if (delay != null && delay > 0) {\n                    message.getMessageProperties().setExpiration(String.valueOf(delay)); // Spring-AMQP API 设计有问题，所以传入了 String = =\n                }\n                return message;\n            }\n\n        });\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("调用 "),r("code",[e._v("#syncSend(Integer id, Integer delay)")]),e._v(" 方法来发送消息时，如果传递了方法参数 "),r("code",[e._v("delay")]),e._v(" ，则我们会设置消息的 TTL 过期时间。")])]),e._v(" "),r("h2",{attrs:{id:"_8-6-demo08consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-demo08consumer"}},[e._v("#")]),e._v(" 8.6 Demo08Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo08Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo08Consumer"),r("OutboundLink")],1),e._v(" 类，消费"),r("strong",[e._v("延迟队列")]),e._v("（死信队列）的消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('@Component\n@RabbitListener(queues = Demo08Message.DELAY_QUEUE)\npublic class Demo08Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo08Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在类上，添加了 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitListener.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("@RabbitListener")]),r("OutboundLink")],1),e._v(" 注解，声明了消费的队列是 "),r("code",[e._v('"DELAY_QUEUE_DEMO_08"')]),e._v(" 这个"),r("strong",[e._v("延迟队列（死信队列）")])]),e._v(" "),r("li",[e._v("在消费逻辑中，我们正常消费该消息即可，实现自己需要的业务逻辑。")])]),e._v(" "),r("h2",{attrs:{id:"_8-7-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-7-简单测试"}},[e._v("#")]),e._v(" 8.7 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo08ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo08ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写单元测试方法，测试"),r("strong",[e._v("定时消息")]),e._v("的效果。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo08ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo08ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo08Producer producer;\n\n    @Test\n    public void testSyncSend01() throws InterruptedException {\n        // 不设置消息的过期时间，使用队列默认的消息过期时间\n        this.testSyncSendDelay(null);\n    }\n\n    @Test\n    public void testSyncSend02() throws InterruptedException {\n        // 设置发送消息的过期时间为 5000 毫秒\n        this.testSyncSendDelay(5000);\n    }\n\n    private void testSyncSendDelay(Integer delay) throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id, delay);\n        logger.info("[testSyncSendDelay][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("ul",[r("li",[r("code",[e._v("#testSyncSend01()")]),e._v(" 方法，不设置消息的过期时间，使用队列"),r("strong",[e._v("默认的消息过期")]),e._v("时间。")]),e._v(" "),r("li",[r("code",[e._v("#testSyncSend02()")]),e._v(" 方法，发送消息的"),r("strong",[e._v("过期时间为 5000 毫秒")]),e._v("。")])]),e._v(" "),r("p",[e._v("我们先来执行 "),r("code",[e._v("#testSyncSend01()")]),e._v(" 方法，不设置消息的过期时间，使用队列"),r("strong",[e._v("默认的消息过期")]),e._v("时间。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 同步发送消息成功。\n2019-12-15 15:44:34.571  INFO 85481 --- [           main] c.i.s.l.r.producer.Demo08ProducerTest    : [testSyncSendDelay][发送编号：[1576050274] 发送成功]\n\n# Consumer 10 秒后，消费到该消息\n2019-12-15 15:44:44.588  INFO 85481 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo08Consumer        : [onMessage][线程编号:17 消息内容：Demo08Message{id=1576050274}]\n")])])]),r("ul",[r("li",[e._v("符合预期。")])]),e._v(" "),r("p",[e._v("我们再来执行 "),r("code",[e._v("#testSyncSend02()")]),e._v(" 方法，发送消息的"),r("strong",[e._v("过期时间为 5000 毫秒")]),e._v("。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# Producer 同步发送消息成功。\n2019-12-15 15:45:41.076  INFO 85735 --- [           main] c.i.s.l.r.producer.Demo08ProducerTest    : [testSyncSendDelay][发送编号：[1576050341] 发送成功]\n\n# Consumer 5 秒后，消费到该消息\n2019-12-15 15:45:46.090  INFO 85735 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo08Consumer        : [onMessage][线程编号:17 消息内容：Demo08Message{id=1576050341}]\n")])])]),r("ul",[r("li",[e._v("符合预期。")])]),e._v(" "),r("h2",{attrs:{id:"_8-8-rabbitmq-delayed-message-plugin"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-8-rabbitmq-delayed-message-plugin"}},[e._v("#")]),e._v(" 8.8 RabbitMQ Delayed Message Plugin")]),e._v(" "),r("p",[e._v("RabbitMQ 目前提供了 "),r("a",{attrs:{href:"https://github.com/rabbitmq/rabbitmq-delayed-message-exchange",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitMQ Delayed Message Plugin"),r("OutboundLink")],1),e._v(" 插件，提供更加"),r("strong",[e._v("通用")]),e._v("的定时消息的功能。")]),e._v(" "),r("p",[e._v("使用起来比较简单，艿艿这里先暂时不提供示例。感兴趣的胖友，可以看看 "),r("a",{attrs:{href:"http://www.iocoder.cn/Fight/Spring-Boot-RabbitMQ-deferred-message-implementation-full-version/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Spring Boot RabbitMQ 延迟消息实现完整版》"),r("OutboundLink")],1),e._v(" 文章。")]),e._v(" "),r("p",[e._v("这两种方案，生产环境下，还是"),r("strong",[e._v("推荐直接使用 RabbitMQ Delayed Message Plugin 插件的方式")]),e._v("。毕竟，这是 RabbitMQ 官方认可的插件，使用起来肯定是没错的。")]),e._v(" "),r("h1",{attrs:{id:"_9-消息模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-消息模式"}},[e._v("#")]),e._v(" 9. 消息模式")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-message-model"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("在消息队列中，有两种经典的消息模式：「点对点」和「发布订阅」。具体的概念，就先不解释，胖友可以看看"),r("a",{attrs:{href:"http://www.iocoder.cn/Fight/There-are-two-modes-of-message-queuing-point-to-point-and-publish-subscription/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《消息队列两种模式：点对点与发布订阅》"),r("OutboundLink")],1),e._v("文章。")]),e._v(" "),r("p",[e._v("如果胖友有使用过 RocketMQ 或者 Kafka 消息队列，可能比较习惯的叫法是：")]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("集群消费（Clustering）")]),e._v("：对应「点对点」 集群消费模式下，相同 Consumer Group 的每个 Consumer 实例平均分摊消息。")]),e._v(" "),r("p",[r("strong",[e._v("广播消费（Broadcasting）")]),e._v("：对应「发布订阅」 广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。")])]),e._v(" "),r("p",[e._v("😈 下文我们统一采用集群消费和广播消费叫法。")]),e._v(" "),r("p",[e._v("下面，我们分别在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1 集群消费」"),r("OutboundLink")],1),e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.2 广播消费」"),r("OutboundLink")],1),e._v("的示例代码。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-message-model"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_9-1-集群消费"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-集群消费"}},[e._v("#")]),e._v(" 9.1 集群消费")]),e._v(" "),r("p",[e._v("在 RabbitMQ 中，如果多个 Consumer 订阅相同的 Queue ，那么每一条消息有且仅会被一个 Consumer 所消费。这个特性，就为我们实现集群消费提供了基础。")]),e._v(" "),r("p",[e._v("在本示例中，我们会把一个 Queue 作为一个 Consumer Group ，同时创建消费该 Queue 的 Consumer 。这样，在我们启动多个 JVM 进程时，就会有多个 Consumer 消费该 Queue ，从而实现集群消费的效果。")]),e._v(" "),r("p",[e._v("下面，让我们开始集群消费的示例。")]),e._v(" "),r("h3",{attrs:{id:"_9-1-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-1-引入依赖"}},[e._v("#")]),e._v(" 9.1.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h3",{attrs:{id:"_9-1-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-2-应用配置文件"}},[e._v("#")]),e._v(" 9.1.2 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h3",{attrs:{id:"_9-1-3-clusteringmessage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-3-clusteringmessage"}},[e._v("#")]),e._v(" 9.1.3 ClusteringMessage")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/ClusteringMessage.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("ClusteringMessage"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// ClusteringMessage.java\n\npublic class ClusteringMessage implements Serializable {\n\n    public static final String QUEUE = "QUEUE_CLUSTERING";\n\n    public static final String EXCHANGE = "EXCHANGE_CLUSTERING";\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("在这里，我们并没有定义 RoutingKey 的枚举，答案我们在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.6 ClusteringConsumer」"),r("OutboundLink")],1),e._v("揭晓。")])]),e._v(" "),r("h3",{attrs:{id:"_9-1-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-4-rabbitconfig"}},[e._v("#")]),e._v(" 9.1.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加集群消费需要的 Exchange 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * 集群消费的示例的配置\n     */\n    public static class ClusteringConfiguration {\n\n        // 创建 Topic Exchange\n        @Bean\n        public TopicExchange clusteringExchange() {\n            return new TopicExchange(ClusteringMessage.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("在这里，我们创建了 Exchange 类型是 "),r("strong",[e._v("Topic")]),e._v(" 。")])]),e._v(" "),r("p",[e._v("为什么不选择 Exchange 类型是 "),r("strong",[e._v("Direct")]),e._v(" 呢？考虑到集群消费的模式，会存在多 Consumer Group 消费的情况，显然我们要支持一条消息投递到多个 Queue 中，所以 Direct Exchange 基本就被排除了。")]),e._v(" "),r("p",[e._v("为什么不选择 Exchange 类型是 "),r("strong",[e._v("Fanout")]),e._v(" 或者 "),r("strong",[e._v("Headers")]),e._v(" 呢？实际是可以的，不过询问了朋友(didi) "),r("a",{attrs:{href:"https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring Cloud Stream RabbitMQ"),r("OutboundLink")],1),e._v(" 是怎么实现的。得知答案是"),r("a",{attrs:{href:"https://raw.githubusercontent.com/spring-cloud/spring-cloud-stream-binder-rabbit/master/docs/src/main/asciidoc/images/rabbit-binder.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("默认"),r("OutboundLink")],1),e._v("是使用 Topic Exchange 的，所以艿艿示例这里也就使用 Topic Exchange 类型了。")]),e._v(" "),r("h3",{attrs:{id:"_9-1-5-clusteringproducer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-5-clusteringproducer"}},[e._v("#")]),e._v(" 9.1.5 ClusteringProducer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/ClusteringProducer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("ClusteringProducer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// ClusteringProducer.java\n\n@Component\npublic class ClusteringProducer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id) {\n        // 创建 ClusteringMessage  消息\n        ClusteringMessage message = new ClusteringMessage();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(ClusteringMessage.EXCHANGE, null, message);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.2.3 Demo02Producer」"),r("OutboundLink")],1),e._v("是基本一致的，除了调用 RabbitTemplate 发送消息时，我们传递的 "),r("code",[e._v("routingKey")]),e._v(" 参数为 "),r("code",[e._v("null")]),e._v(" 。为什么呢？答案我们也在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.6 ClusteringConsumer」"),r("OutboundLink")],1),e._v("揭晓。")])]),e._v(" "),r("h3",{attrs:{id:"_9-1-6-clusteringconsumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-6-clusteringconsumer"}},[e._v("#")]),e._v(" 9.1.6 ClusteringConsumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/ClusteringConsumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("ClusteringConsumer"),r("OutboundLink")],1),e._v(" 类，"),r("strong",[e._v("集群")]),e._v("消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// ClusteringConsumer.java\n\n@Component\n@RabbitListener(\n        bindings = @QueueBinding(\n                value = @Queue(\n                        name = ClusteringMessage.QUEUE + "-" + "GROUP-01"\n                ),\n                exchange = @Exchange(\n                        name = ClusteringMessage.EXCHANGE,\n                        type = ExchangeTypes.TOPIC,\n                        declare = "false"\n                ),\n                key = "#"\n        )\n)\npublic class ClusteringConsumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(ClusteringMessage message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n')])])]),r("ul",[r("li",[r("p",[e._v("相比其它 Consumer 示例来说，这里添加的 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解复杂很多。")])]),e._v(" "),r("li",[r("p",[e._v("在 "),r("code",[e._v("bindings")]),e._v(" 属性，我们添加了 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/QueueBinding.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("@QueueBinding")]),r("OutboundLink")],1),e._v(" 注解，来定义了一个 Binding 。通过 "),r("code",[e._v("key")]),e._v(" 属性，设置使用的 RoutingKey 为 "),r("code",[e._v("#")]),e._v(" ，"),r("strong",[e._v("匹配所有")]),e._v("。这就是为什么我们在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.3 ClusteringMessage」"),r("OutboundLink")],1),e._v("未定义 RoutingKey ，以及在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.5 ClusteringProducer」"),r("OutboundLink")],1),e._v("中使用 "),r("code",[e._v("routingKey = null")]),e._v(" 的原因。")])]),e._v(" "),r("li",[r("p",[e._v("在")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("exchange\n")])])]),r("p",[e._v("属性，我们添加了")]),e._v(" "),r("p",[r("code",[e._v("@Exchange")])]),e._v(" "),r("p",[e._v("注解，设置了对应")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("EXCHANGE_CLUSTERING\n")])])]),r("p",[e._v("这个 Exchange 。")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("type")]),e._v(" 属性，设置是 TopicExchange 。")]),e._v(" "),r("li",[r("code",[e._v("declare")]),e._v(" 属性，因为"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.4 RabbitConfig」"),r("OutboundLink")],1),e._v("中，已经配置创建这个 Exchange 了。")])])]),e._v(" "),r("li",[r("p",[e._v("在 "),r("code",[e._v("value")]),e._v(" 属性，我们添加了 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/Queue.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("@Queue")]),r("OutboundLink")],1),e._v(" 注解，设置消费 "),r("code",[e._v("QUEUE_CLUSTERING-GROUP-01")]),e._v(" 这个 Queue 的消息。")])])]),e._v(" "),r("p",[e._v("注意，通过添加 "),r("code",[e._v("@Exchange")]),e._v("、"),r("code",[e._v("@Queue")]),e._v("、"),r("code",[e._v("@QueueBinding")]),e._v(" 注解，如果未声明 "),r("code",[e._v('declare="false"')]),e._v(" 时，会"),r("strong",[e._v("自动创建对应")]),e._v("的 Exchange、Queue、Binding 。")]),e._v(" "),r("h3",{attrs:{id:"_9-1-7-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-7-简单测试"}},[e._v("#")]),e._v(" 9.1.7 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/ClusteringProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("ClusteringProducerTest"),r("OutboundLink")],1),e._v(" 测试类，用于测试集群消费。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// ClusteringProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class ClusteringProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private ClusteringProducer producer;\n\n    @Test\n    public void mock() throws InterruptedException {\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        // 发送 3 条消息\n        for (int i = 0; i < 3; i++) {\n            int id = (int) (System.currentTimeMillis() / 1000);\n            producer.syncSend(id);\n            logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n        }\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("p",[e._v("首先，执行 "),r("code",[e._v("#mock()")]),e._v(" 测试方法，先启动一个消费 "),r("code",[e._v('"QUEUE_CLUSTERING-GROUP-01"')]),e._v(" 这个 Queue 的 Consumer 节点。")]),e._v(" "),r("p",[e._v("然后，执行 "),r("code",[e._v("#testSyncSend()")]),e._v(" 测试方法，再启动一个消费 "),r("code",[e._v('"QUEUE_CLUSTERING-GROUP-01"')]),e._v(" 这个 Queue 的 Consumer 节点。同时，该测试方法，调用 "),r("code",[e._v("ClusteringProducer#syncSend(id)")]),e._v(" 方法，同步发送了 3 条消息。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// #### testSyncSend 方法对应的控制台 ####\n\n# Producer 同步发送消息成功\n2019-12-15 22:13:44.372  INFO 43363 --- [           main] c.i.s.l.r.p.ClusteringProducerTest       : [testSyncSend][发送编号：[1576073624] 发送成功]\n2019-12-15 22:13:44.373  INFO 43363 --- [           main] c.i.s.l.r.p.ClusteringProducerTest       : [testSyncSend][发送编号：[1576073624] 发送成功]\n2019-12-15 22:13:44.374  INFO 43363 --- [           main] c.i.s.l.r.p.ClusteringProducerTest       : [testSyncSend][发送编号：[1576073624] 发送成功]\n\n# ClusteringConsumer 消费了 1 条消息\n2019-12-15 22:13:44.393  INFO 43363 --- [ntContainer#1-1] c.i.s.l.r.consumer.ClusteringConsumer    : [onMessage][线程编号:19 消息内容：ClusteringtMessage{id=1576073624}]\n\n// ### mock 方法对应的控制台 ####\n\n# ClusteringConsumer 消费了 2 条消息\n2019-12-15 22:13:44.396  INFO 43308 --- [ntContainer#1-1] c.i.s.l.r.consumer.ClusteringConsumer    : [onMessage][线程编号:19 消息内容：ClusteringtMessage{id=1576073624}]\n2019-12-15 22:13:44.398  INFO 43308 --- [ntContainer#1-1] c.i.s.l.r.consumer.ClusteringConsumer    : [onMessage][线程编号:19 消息内容：ClusteringtMessage{id=1576073624}]\n")])])]),r("ul",[r("li",[e._v("3 条消息，都仅被 "),r("strong",[e._v("两个")]),e._v(" Consumer 节点的"),r("strong",[e._v("一个")]),e._v("进行消费。符合集群消费的预期~")])]),e._v(" "),r("p",[e._v("因为考虑让集群消费的示例做的比较简单，所以并未提供一条消息投递到多个 Queue 中，从而实现多集群下的集群消费的效果。不过比较简单，胖友可以自行在创建一个类似"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.6 ClusteringConsumer」"),r("OutboundLink")],1),e._v("的消费者类，设置消费另外一个 Queue 即可。例如说：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('@Component\n@RabbitListener(\n        bindings = @QueueBinding(\n                value = @Queue(\n                        name = ClusteringMessage.QUEUE + "-" + "GROUP-02" // 这里从 "GROUP-01" 改成了 "GROUP-02" 。\n                ),\n                exchange = @Exchange(\n                        name = ClusteringMessage.EXCHANGE,\n                        type = ExchangeTypes.TOPIC,\n                        declare = "false"\n                ),\n                key = "#"\n        )\n)\n')])])]),r("h2",{attrs:{id:"_9-2-广播消费"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-广播消费"}},[e._v("#")]),e._v(" 9.2 广播消费")]),e._v(" "),r("p",[e._v("在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1 集群消费」"),r("OutboundLink")],1),e._v("中，我们通过“在 RabbitMQ 中，如果多个 Consumer 订阅相同的 Queue ，那么每一条消息有且仅会被一个 Consumer 所消费”特性，来实现了集群消费。但是，在实现广播消费时，这个特性恰恰成为了一种阻碍。")]),e._v(" "),r("p",[e._v("不过机智的我们，我们可以通过给每个 Consumer 创建一个其"),r("strong",[e._v("独有")]),e._v(" Queue ，从而保证都能接收到全量的消息。同时，RabbitMQ 支持队列的自动删除，所以我们可以在 Consumer 关闭的时候，通过该功能删除其"),r("strong",[e._v("独有")]),e._v("的 Queue 。")]),e._v(" "),r("p",[e._v("下面，让我们开始集群消费的示例。考虑到简便，我们直接继续在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo"),r("OutboundLink")],1),e._v(" 项目改造。")]),e._v(" "),r("h3",{attrs:{id:"_9-2-1-broadcastmessage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-1-broadcastmessage"}},[e._v("#")]),e._v(" 9.2.1 BroadcastMessage")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/BroadcastMessage.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("BroadcastMessage"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// BroadcastMessage.java\n\npublic class BroadcastMessage implements Serializable {\n\n    public static final String QUEUE = "QUEUE_BROADCASTING";\n\n    public static final String EXCHANGE = "EXCHANGE_BROADCASTING";\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.3 ClusteringMessage」"),r("OutboundLink")],1),e._v("一致，只是 Queue 和 Exchange 的名字不同。")])]),e._v(" "),r("h3",{attrs:{id:"_9-2-2-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-2-rabbitconfig"}},[e._v("#")]),e._v(" 9.2.2 RabbitConfig")]),e._v(" "),r("p",[e._v("修改 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加自定义的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/config/SimpleRabbitListenerContainerFactory.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SimpleRabbitListenerContainerFactory"),r("OutboundLink")],1),e._v(" Bean ，添加广播消费需要的 Exchange 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n/**\n * 广播消费的示例的配置\n */\npublic static class BroadcastingConfiguration {\n\n    // 创建 Topic Exchange\n    @Bean\n    public TopicExchange broadcastingExchange() {\n        return new TopicExchange(BroadcastMessage.EXCHANGE,\n                true,  // durable: 是否持久化\n                false);  // exclusive: 是否排它\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.4 RabbitConfig」"),r("OutboundLink")],1),e._v("的 ClusteringConfiguration 配置类是一致，只是创建了不同的 Exchange 。")])]),e._v(" "),r("h3",{attrs:{id:"_9-2-3-broadcastproducer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-3-broadcastproducer"}},[e._v("#")]),e._v(" 9.2.3 BroadcastProducer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/BroadcastProducer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("BroadcastProducer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// BroadcastProducer.java\n\n@Component\npublic class BroadcastProducer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id) {\n        // 创建 BroadcastMessage 消息\n        BroadcastMessage message = new BroadcastMessage();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(BroadcastMessage.EXCHANGE, null, message);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.5 ClusteringProducer」"),r("OutboundLink")],1),e._v("是一致，只是使用了不同的 Exchange 和消息。")])]),e._v(" "),r("h3",{attrs:{id:"_9-2-4-broadcastconsumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-4-broadcastconsumer"}},[e._v("#")]),e._v(" 9.2.4 BroadcastConsumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/ClusteringConsumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("BroadcastConsumer"),r("OutboundLink")],1),e._v(" 类，"),r("strong",[e._v("广播")]),e._v("消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// BroadcastConsumer.java\n\n@Component\n@RabbitListener(\n        bindings = @QueueBinding(\n                value = @Queue(\n                        name = BroadcastMessage.QUEUE + "-" + "#{T(java.util.UUID).randomUUID()}",\n                        autoDelete = "true"\n                ),\n                exchange = @Exchange(\n                        name = BroadcastMessage.EXCHANGE,\n                        type = ExchangeTypes.TOPIC,\n                        declare = "false"\n                )\n        )\n)\npublic class BroadcastConsumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(BroadcastMessage message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("总体和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9.1.6 ClusteringConsumer」"),r("OutboundLink")],1),e._v("是一致，主要差异在两点。")]),e._v(" "),r("li",[e._v("第一点，在 "),r("code",[e._v("@Queue")]),e._v(" 注解的 "),r("code",[e._v("name")]),e._v(" 属性，我们通过 Spring EL 表达式，在 Queue 的名字上，使用 UUID 生成其后缀。这样，我们就能保证每个项目启动的 Consumer 的 Queue 不同，以达到广播消费的目的。")]),e._v(" "),r("li",[e._v("第二点，在 "),r("code",[e._v("@Queue")]),e._v(" 注解的 "),r("code",[e._v("autoDelete")]),e._v(" 属性，我们设置为 "),r("code",[e._v('"true"')]),e._v(" ，这样在 Consumer 关闭时，该队列就可以被自动删除了。")])]),e._v(" "),r("h3",{attrs:{id:"_9-2-5-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-5-简单测试"}},[e._v("#")]),e._v(" 9.2.5 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/BroadcastProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("BroadcastProducerTest"),r("OutboundLink")],1),e._v(" 测试类，用于测试广播消费。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// BroadcastProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class BroadcastProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private BroadcastProducer producer;\n\n    @Test\n    public void mock() throws InterruptedException {\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id);\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("p",[e._v("首先，执行 "),r("code",[e._v("#mock()")]),e._v(" 测试方法，先启动一个消费 "),r("code",[e._v('"QUEUE_BROADCAST-${UUID1}"')]),e._v(" 这个 Queue 的 Consumer 节点。")]),e._v(" "),r("p",[e._v("然后，执行 "),r("code",[e._v("#testSyncSend()")]),e._v(" 测试方法，再启动一个消费 "),r("code",[e._v('"QUEUE_BROADCAST-${UUID2}"')]),e._v(" 这个 Queue 的 Consumer 节点。同时，该测试方法，调用 "),r("code",[e._v("BroadcastProducer#syncSend(id)")]),e._v(" 方法，同步发送了 3 条消息。控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// #### testSyncSend 方法对应的控制台 ####\n\n# Producer 同步发送消息成功\n2019-12-15 00:11:41.459  INFO 64479 --- [           main] c.i.s.l.r.p.BroadcastProducerTest        : [testSyncSend][发送编号：[1576080701] 发送成功]\n2019-12-15 00:11:41.460  INFO 64479 --- [           main] c.i.s.l.r.p.BroadcastProducerTest        : [testSyncSend][发送编号：[1576080701] 发送成功]\n2019-12-15 00:11:41.461  INFO 64479 --- [           main] c.i.s.l.r.p.BroadcastProducerTest        : [testSyncSend][发送编号：[1576080701] 发送成功]\n\n# BroadcastConsumer 消费了 3 条消息\n2019-12-15 00:11:41.478  INFO 64479 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]\n2019-12-15 00:11:41.479  INFO 64479 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]\n2019-12-15 00:11:41.480  INFO 64479 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]\n\n// ### mock 方法对应的控制台 ####\n\n# BroadcastConsumer 也消费了 3 条消\n2019-12-15 00:11:41.460  INFO 63795 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]\n2019-12-15 00:11:41.462  INFO 63795 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]\n2019-12-15 00:11:41.462  INFO 63795 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]\n")])])]),r("ul",[r("li",[r("strong",[e._v("两个")]),e._v(" Consumer 节点，都消费了这条发送的消息。符合广播消费的预期~")])]),e._v(" "),r("h1",{attrs:{id:"_10-并发消费"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-并发消费"}},[e._v("#")]),e._v(" 10. 并发消费")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-concurrency"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("在上述的示例中，我们配置的每一个 Spring-AMQP "),r("code",[e._v("@RabbitListener")]),e._v(" ，都是"),r("strong",[e._v("串行")]),e._v("消费的。显然，这在监听的 Queue 每秒消息量比较大的时候，会导致消费不及时，导致消息积压的问题。")]),e._v(" "),r("p",[e._v("虽然说，我们可以通过启动多个 JVM 进程，实现"),r("strong",[e._v("多进程的并发消费")]),e._v("，从而加速消费的速度。但是问题是，否能够实现"),r("strong",[e._v("多线程")]),e._v("的并发消费呢？答案是"),r("strong",[e._v("有")]),e._v("。")]),e._v(" "),r("p",[e._v("在 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解中，有 "),r("code",[e._v("concurrency")]),e._v(" 属性，它可以指定并发消费的线程数。例如说，如果设置 "),r("code",[e._v("concurrency=4")]),e._v(" 时，Spring-AMQP 就会为"),r("strong",[e._v("该")]),e._v(" "),r("code",[e._v("@RabbitListener")]),e._v(" 创建 4 个线程，进行并发消费。")]),e._v(" "),r("p",[e._v("考虑到让胖友能够更好的理解 "),r("code",[e._v("concurrency")]),e._v(" 属性，我们来简单说说 Spring-AMQP 在这块的实现方式。我们来举个例子：")]),e._v(" "),r("ul",[r("li",[e._v("首先，我们来创建一个 Queue 为 "),r("code",[e._v('"DEMO_09"')]),e._v(" 。")]),e._v(" "),r("li",[e._v("然后，我们创建一个 Demo9Consumer 类，并在其消费方法上，添加 "),r("code",[e._v("@RabbitListener(concurrency=2)")]),e._v(" 注解。")]),e._v(" "),r("li",[e._v("再然后，我们启动项目。Spring-AMQP 会根据 "),r("code",[e._v("@RabbitListener(concurrency=2)")]),e._v(" 注解，创建 "),r("strong",[e._v("2")]),e._v(" 个 RabbitMQ Consumer 。注意噢，是 "),r("strong",[e._v("2")]),e._v(" 个 RabbitMQ Consumer 呢！！！后续，每个 RabbitMQ Consumer 会被"),r("strong",[e._v("单独")]),e._v("分配到一个线程中，进行拉取消息，消费消息。")])]),e._v(" "),r("p",[e._v("酱紫讲解一下，胖友对 Spring-AMQP 实现"),r("strong",[e._v("多线程")]),e._v("的并发消费的机制，是否理解了。")]),e._v(" "),r("p",[e._v("下面，我们开始本小节的示例。本示例就是上述举例的具体实现。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-concurrency"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_10-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-引入依赖"}},[e._v("#")]),e._v(" 10.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_10-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-应用配置文件"}},[e._v("#")]),e._v(" 10.2 应用配置文件")]),e._v(" "),r("p",[e._v("在开始看具体的应用配置文件之前，我们先来了了解下 Spring-AMQP 的两个 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java#L566-L579",target:"_blank",rel:"noopener noreferrer"}},[e._v("ContainerType"),r("OutboundLink")],1),e._v(" 容器类型，枚举如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitProperties.java\n\npublic enum ContainerType {\n\n\t/**\n\t * Container where the RabbitMQ consumer dispatches messages to an invoker thread.\n\t */\n\tSIMPLE,\n\n\t/**\n\t * Container where the listener is invoked directly on the RabbitMQ consumer\n\t * thread.\n\t */\n\tDIRECT\n\n}\n")])])]),r("p",[e._v("① 第一种类型，"),r("code",[e._v("SIMPLE")]),e._v(" 对应 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SimpleMessageListenerContainer"),r("OutboundLink")],1),e._v(" 消息监听器容器。它一共有两"),r("strong",[e._v("类")]),e._v("线程：")]),e._v(" "),r("ul",[r("li",[e._v("Consumer 线程，负责从 RabbitMQ Broker 获取 Queue 中的消息，存储到"),r("strong",[e._v("内存中")]),e._v("的 "),r("a",{attrs:{href:"https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/BlockingQueue.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("BlockingQueue"),r("OutboundLink")],1),e._v(" 阻塞队列中。")]),e._v(" "),r("li",[e._v("Listener 线程，负责从"),r("strong",[e._v("内存中")]),e._v("的 BlockingQueue 获取消息，进行消费逻辑。")])]),e._v(" "),r("p",[e._v("注意，每一个 Consumer 线程，对应一个 RabbitMQ Consumer ，对应一个 Listener 线程。也就是说，它们三者是"),r("strong",[e._v("一一对应")]),e._v("的。")]),e._v(" "),r("p",[e._v("② 第二种类型，"),r("code",[e._v("DIRECT")]),e._v(" 对应 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/DirectMessageListenerContainer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("DirectMessageListenerContainer"),r("OutboundLink")],1),e._v(" 消息监听器容器。它只有"),r("strong",[e._v("一类")]),e._v("线程，即做 "),r("code",[e._v("SIMPLE")]),e._v(" 的 Consumer 线程的工作，也做 "),r("code",[e._v("SIMPLE")]),e._v(" 的 Listener 线程工作。")]),e._v(" "),r("p",[e._v("注意，因为只有"),r("strong",[e._v("一类")]),e._v("线程，所以它要么正在获取消息，要么正在消费消息，也就是"),r("strong",[e._v("串行")]),e._v("的。")]),e._v(" "),r("p",[e._v("🔥 默认情况下，Spring-AMQP 选择使用第一种类型，即 "),r("code",[e._v("SIMPLE")]),e._v(" 容器类型。")]),e._v(" "),r("p",[e._v("下面，让我们一起看看 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 配置文件。配置如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("spring:\n  # RabbitMQ 配置项，对应 RabbitProperties 配置类\n  rabbitmq:\n    host: 127.0.0.1 # RabbitMQ 服务的地址\n    port: 5672 # RabbitMQ 服务的端口\n    username: guest # RabbitMQ 服务的账号\n    password: guest # RabbitMQ 服务的密码\n    listener:\n      type: simple # 选择的 ListenerContainer 的类型。默认为 simple 类型\n      simple:\n        concurrency: 2 # 每个 @ListenerContainer 的并发消费的线程数\n        max-concurrency: 10 # 每个 @ListenerContainer 允许的并发消费的线程数\n#      direct:\n#        consumers-per-queue: 2 # 对于每一个 @RabbitListener ，一个 Queue ，对应创建几个 Consumer 。\n")])])]),r("ul",[r("li",[r("p",[e._v("相比")]),e._v(" "),r("p",[e._v("「3.1.2 应用配置文件」")]),e._v(" "),r("p",[e._v("来说，额外三个参数：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("spring.rabbitmq.listener.type")])]),e._v(" "),r("li",[r("code",[e._v("spring.rabbitmq.listener.simple.concurrency")])]),e._v(" "),r("li",[r("code",[e._v("spring.rabbitmq.listener.simple.max-concurrency")])])])])]),e._v(" "),r("p",[e._v("要"),r("strong",[e._v("注意")]),e._v("，是 "),r("code",[e._v("spring.rabbitmq.listener.simple.max-concurrency")]),e._v(" 配置，是"),r("strong",[e._v("限制")]),e._v("每个 "),r("code",[e._v("@RabbitListener")]),e._v(" 的"),r("strong",[e._v("允许")]),e._v("配置的 "),r("code",[e._v("concurrency")]),e._v(" 最大大小。如果超过，则会抛出 IllegalArgumentException 异常。在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「10.6 Demo09Consumer」"),r("OutboundLink")],1),e._v("中，我们会看到 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解，有一个 "),r("code",[e._v("concurrency")]),e._v(" 属性，可以自定义每个 "),r("code",[e._v("@RabbitListener")]),e._v(" 的并发消费的线程数。")]),e._v(" "),r("h2",{attrs:{id:"_10-3-demo09message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-demo09message"}},[e._v("#")]),e._v(" 10.3 Demo09Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo09Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo09Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_10-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-rabbitconfig"}},[e._v("#")]),e._v(" 10.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，配置相关的 Exchange、Queue、Binding 。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.5 RabbitConfig」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_10-5-demo09producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-5-demo09producer"}},[e._v("#")]),e._v(" 10.5 Demo09Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo09Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo09Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_10-6-demo09consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-6-demo09consumer"}},[e._v("#")]),e._v(" 10.6 Demo09Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo09Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo09Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo06Consumer.java\n\n@Component\n@RabbitListener(queues = Demo09Message.QUEUE,\n    concurrency = "2")\npublic class Demo09Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo09Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.7 Demo01Consumer」"),r("OutboundLink")],1),e._v("一致，只差在消费不同的队列。")]),e._v(" "),r("li",[e._v("另外，可以通过 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解，设置并发数。优先级最高，可覆盖配置文件中的 "),r("code",[e._v("spring.rabbitmq.listener.simple.concurrency")]),e._v(" 配置项。")])]),e._v(" "),r("p",[e._v("不过个人建议，还是每个 "),r("code",[e._v("@RabbitListener")]),e._v(" 各自配置，毕竟每个 Queue 的消息数量，都是不同的。当然，也可以结合使用 😈 。")]),e._v(" "),r("h2",{attrs:{id:"_10-7-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-简单测试"}},[e._v("#")]),e._v(" 10.7 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo09ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo09ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写一个单元测试方法，发送 10 条消息，观察并发消费情况。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo09ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo09ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo09Producer producer;\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        for (int i = 0; i < 10; i++) {\n            int id = (int) (System.currentTimeMillis() / 1000);\n            producer.syncSend(id);\n//            logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n        }\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("p",[e._v("执行单元测试方法，控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# 线程编号为 17\n2019-12-15 10:48:20.013  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.015  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.016  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.017  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.017  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]\n\n# 线程编号 18\n2019-12-15 10:48:20.013  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.015  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.016  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.016  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]\n2019-12-15 10:48:20.017  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]\n")])])]),r("ul",[r("li",[e._v("我们可以看到，两个线程在消费 "),r("code",[e._v('"QUEUE_DEMO_09"')]),e._v(" 下的消息。")])]),e._v(" "),r("p",[e._v("此时，如果我们使用 "),r("a",{attrs:{href:"https://www.rabbitmq.com/management.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitMQ Management"),r("OutboundLink")],1),e._v(" 来查看 "),r("code",[e._v('"QUEUE_DEMO_09"')]),e._v(" 的消费者列表：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/lichengcan/images/main/01.png",alt:""}})]),e._v(" "),r("h1",{attrs:{id:"_11-顺序消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-顺序消息"}},[e._v("#")]),e._v(" 11. 顺序消息")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-orderly"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("我们先来一起了解下顺序消息的"),r("strong",[e._v("顺序消息")]),e._v("的定义：")]),e._v(" "),r("ul",[r("li",[e._v("普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。")]),e._v(" "),r("li",[e._v("完全严格顺序 ：在【普通顺序消息】的基础上，Consumer 严格顺序消费。")])]),e._v(" "),r("p",[e._v("那么，让我们来思考下，如果我们希望在 RabbitMQ 上，实现顺序消息需要做两个事情。")]),e._v(" "),r("p",[e._v("① "),r("strong",[e._v("事情一")]),e._v("，我们需要保证 RabbitMQ Producer 发送相关联的消息发送到相同的 Queue 中。例如说，我们要发送用户信息发生变更的 Message ，那么如果我们希望使用顺序消息的情况下，可以将"),r("strong",[e._v("用户编号")]),e._v("相同的消息发送到相同的 Queue 中。")]),e._v(" "),r("p",[e._v("② "),r("strong",[e._v("事情二")]),e._v("，我们在有"),r("strong",[e._v("且仅启动一个")]),e._v(" Consumer 消费该队列，保证 Consumer 严格顺序消费。")]),e._v(" "),r("p",[e._v("不过如果这样做，会存在两个问题，我们逐个来看看。")]),e._v(" "),r("p",[e._v("① "),r("strong",[e._v("问题一")]),e._v("，正如我们在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「10. 并发消费」"),r("OutboundLink")],1),e._v("中提到，如果我们将消息仅仅投递到一个 Queue 中，并且采用单个 Consumer "),r("strong",[e._v("串行")]),e._v("消费，在监听的 Queue 每秒消息量比较大的时候，会导致消费不及时，导致消息积压的问题。")]),e._v(" "),r("p",[e._v("此时，我们有两种方案来解决：")]),e._v(" "),r("ul",[r("li",[e._v("方案一，在 Producer 端，将 Queue 拆成多个"),r("strong",[e._v("子")]),e._v(" Queue 。假设原先 Queue 是 "),r("code",[e._v("QUEUE_USER")]),e._v(" ，那么我们就分拆成 "),r("code",[e._v("QUEUE_USER_00")]),e._v(" 至 "),r("code",[e._v("QUEUE_USER_..${N-1}")]),e._v(" 这样 N 个队列，然后基于消息的用户编号取余，路由到对应的"),r("strong",[e._v("子")]),e._v(" Queue 中。")]),e._v(" "),r("li",[e._v("方案二，在 Consumer 端，将 Queue 拉取到的消息，将相关联的消息发送到"),r("strong",[e._v("相同的线程")]),e._v("中来消费。例如说，还是 Queue 是 "),r("code",[e._v("QUEUE_USER")]),e._v(" 的例子，我们创建 N 个线程池大小为 1 的 "),r("a",{attrs:{href:"https://github.com/JetBrains/jdk8u_jdk/blob/master/src/share/classes/java/util/concurrent/ExecutorService.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("ExecutorService"),r("OutboundLink")],1),e._v(" 数组，然后基于消息的用户编号取余，提交到对应的 ExecutorService 中的单个线程来执行。")])]),e._v(" "),r("p",[e._v("两个方案，并不冲突，可以结合使用。")]),e._v(" "),r("p",[e._v("② "),r("strong",[e._v("问题二")]),e._v("，如果我们启动相同 Consumer 的"),r("strong",[e._v("多个进程")]),e._v("，会导致相同 Queue 的消息被分配到多个 Consumer 进行消费，破坏 Consumer 严格顺序消费。")]),e._v(" "),r("p",[e._v("此时，我们有两种方案来解决：")]),e._v(" "),r("ul",[r("li",[e._v("方案一，引入 ZooKeeper 来协调，动态设置多个进程中的"),r("strong",[e._v("相同的")]),e._v(" Consumer 的开关，保证有且仅有一个 Consumer 开启对"),r("strong",[e._v("同一个")]),e._v(" Queue 的消费。")]),e._v(" "),r("li",[e._v("方案二，仅适用于【问题一】的【方案一】。还是引入 ZooKeeper 来协调，动态设置多个进程中的"),r("strong",[e._v("相同的")]),e._v(" Consumer 消费的 Queue 的分配，保证有且仅有一个 Consumer 开启对"),r("strong",[e._v("同一个")]),e._v(" Queue 的消费。")])]),e._v(" "),r("p",[e._v("下面，我们开始本小节的示例。本示例就是上述举例的具体实现。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-orderly"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("ul",[r("li",[e._v("对于问题一，我们采用方案一。因为在 Spring-AMQP 中，自己定义线程来消费消息，无法和现有的 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-framework/blob/master/spring-jms/src/main/java/org/springframework/jms/listener/MessageListenerContainer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("MessageListenerContainer"),r("OutboundLink")],1),e._v(" 的实现所结合，除非自定义一个 MessageListenerContainer 实现类。")]),e._v(" "),r("li",[e._v("对于问题二，因为实现起来比较复杂，暂时先不提供。")])]),e._v(" "),r("h2",{attrs:{id:"_11-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-1-引入依赖"}},[e._v("#")]),e._v(" 11.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_11-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-应用配置文件"}},[e._v("#")]),e._v(" 11.2 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_11-3-demo10message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-3-demo10message"}},[e._v("#")]),e._v(" 11.3 Demo10Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo10Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo10Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo10Message.java\n\npublic class Demo10Message implements Serializable {\n\n    private static final String QUEUE_BASE = "QUEUE_DEMO_10-";\n    public static final String QUEUE_0 = QUEUE_BASE + "0";\n    public static final String QUEUE_1 = QUEUE_BASE + "1";\n    public static final String QUEUE_2 = QUEUE_BASE + "2";\n    public static final String QUEUE_3 = QUEUE_BASE + "3";\n\n    public static final int QUEUE_COUNT = 4;\n\n    public static final String EXCHANGE = "EXCHANGE_DEMO_10";\n\n    /**\n     * 编号\n     */\n    private Integer id;\n\n    // ... 省略 set/get/toString 方法\n\n}\n')])])]),r("ul",[r("li",[e._v("定义了 "),r("code",[e._v("QUEUE_DEMO_10-")]),e._v(" 的四个"),r("strong",[e._v("子")]),e._v(" Queue 。")]),e._v(" "),r("li",[e._v("定义了统一的 Exchange 。")]),e._v(" "),r("li",[e._v("暂未定义 RoutingKey 的名字，我们会使用“队列编号”作为 RoutingKey ，然后路由消息到每个子 Queue 中。")])]),e._v(" "),r("h2",{attrs:{id:"_11-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-4-rabbitconfig"}},[e._v("#")]),e._v(" 11.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，添加 Direct Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// RabbitConfig.java\n\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo10Queue0() {\n            return new Queue(Demo10Message.QUEUE_0);\n        }\n        @Bean\n        public Queue demo10Queue1() {\n            return new Queue(Demo10Message.QUEUE_1);\n        }\n        @Bean\n        public Queue demo10Queue2() {\n            return new Queue(Demo10Message.QUEUE_2);\n        }\n        @Bean\n        public Queue demo10Queue3() {\n            return new Queue(Demo10Message.QUEUE_3);\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo10Exchange() {\n            return new DirectExchange(Demo10Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        @Bean\n        public Binding demo10Binding0() {\n            return BindingBuilder.bind(demo10Queue0()).to(demo10Exchange()).with("0");\n        }\n        @Bean\n        public Binding demo10Binding1() {\n            return BindingBuilder.bind(demo10Queue1()).to(demo10Exchange()).with("1");\n        }\n        @Bean\n        public Binding demo10Binding2() {\n            return BindingBuilder.bind(demo10Queue2()).to(demo10Exchange()).with("2");\n        }\n        @Bean\n        public Binding demo10Binding3() {\n            return BindingBuilder.bind(demo10Queue3()).to(demo10Exchange()).with("3");\n        }\n\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("首先，创建了四个"),r("strong",[e._v("子")]),e._v(" Queue 。")]),e._v(" "),r("li",[e._v("然后，创建了一个 Exchange 。")]),e._v(" "),r("li",[e._v("最后，创建了四个 Bingding ，对应每一个"),r("strong",[e._v("子")]),e._v(" Queue ，RoutingKey 为队列编号。")])]),e._v(" "),r("h2",{attrs:{id:"_11-5-demo10producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-5-demo10producer"}},[e._v("#")]),e._v(" 11.5 Demo10Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo01Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo01Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息到"),r("strong",[e._v("子")]),e._v(" Queue 中。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Demo10Producer.java\n\n@Component\npublic class Demo10Producer {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public void syncSend(Integer id) {\n        // 创建 Demo10Message 消息\n        Demo10Message message = new Demo10Message();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(Demo10Message.EXCHANGE, this.getRoutingKey(id), message);\n    }\n\n    private String getRoutingKey(Integer id) {\n        return String.valueOf(id % Demo10Message.QUEUE_COUNT);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("发送消息时，我们对 "),r("code",[e._v("Demo10Message.id % 队列编号")]),e._v(" 进行取余，获得"),r("strong",[e._v("队列编号")]),e._v("作为 RoutingKey ，从而路由消息到对应的"),r("strong",[e._v("子")]),e._v(" Queue 中。")])]),e._v(" "),r("h2",{attrs:{id:"_11-6-demo10consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-6-demo10consumer"}},[e._v("#")]),e._v(" 11.6 Demo10Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo10Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo10Consumer"),r("OutboundLink")],1),e._v(" 类，"),r("strong",[e._v("严格")]),e._v("消费"),r("strong",[e._v("顺序")]),e._v("消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo10Consumer.java\n\n@Component\n@RabbitListener(queues = Demo10Message.QUEUE_0)\n@RabbitListener(queues = Demo10Message.QUEUE_1)\n@RabbitListener(queues = Demo10Message.QUEUE_2)\n@RabbitListener(queues = Demo10Message.QUEUE_3)\npublic class Demo10Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler(isDefault = true)\n    public void onMessage(Message<Demo10Message> message) {\n        logger.info("[onMessage][线程编号:{} Queue:{} 消息编号：{}]", Thread.currentThread().getId(), getQueue(message),\n                message.getPayload().getId());\n    }\n\n    private static String getQueue(Message<Demo10Message> message) {\n        return message.getHeaders().get("amqp_consumerQueue", String.class);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("为了实现每个"),r("strong",[e._v("子")]),e._v(" Queue 能够被每个 Consumer "),r("strong",[e._v("串行")]),e._v("消费，从而实现基于"),r("strong",[e._v("子")]),e._v(" Queue 的"),r("strong",[e._v("并行")]),e._v("的"),r("strong",[e._v("严格")]),e._v("消费"),r("strong",[e._v("顺序")]),e._v("消息，我们只好在类上添了四个 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解，每个对应一个"),r("strong",[e._v("子")]),e._v(" Queue 。")]),e._v(" "),r("li",[e._v("如果胖友使用一个 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解，并添加四个"),r("strong",[e._v("子")]),e._v(" Queue ，然后设置 "),r("code",[e._v("concurrency = 4")]),e._v(" 时，实际是并发四个线程，消费四个"),r("strong",[e._v("子")]),e._v(" Queue 的消息，无法保证"),r("strong",[e._v("严格")]),e._v("消费"),r("strong",[e._v("顺序")]),e._v("消息。")])]),e._v(" "),r("h2",{attrs:{id:"_11-7-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-7-简单测试"}},[e._v("#")]),e._v(" 11.7 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo10ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo10ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写一个单元测试方法，发送 8 条消息，观察顺序消费情况。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo10ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo10ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo10Producer producer;\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        for (int i = 0; i < 2; i++) {\n            for (int id = 0; id < 4; id++) {\n                producer.syncSend(id);\n//            logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n            }\n        }\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("发送 2 轮消息，每一轮消息的编号都是 0 至 3 。")])]),e._v(" "),r("p",[e._v("执行单元测试方法，控制台输出如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("# 线程编号为 21\n2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#2-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:21 Queue:QUEUE_DEMO_10-2 消息编号：2]\n2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#2-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:21 Queue:QUEUE_DEMO_10-2 消息编号：2]\n\n# 线程编号为 17\n2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:17 Queue:QUEUE_DEMO_10-0 消息编号：0]\n2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:17 Queue:QUEUE_DEMO_10-0 消息编号：0]\n\n# 线程编号为 23\n2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#3-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:23 Queue:QUEUE_DEMO_10-3 消息编号：3]\n2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#3-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:23 Queue:QUEUE_DEMO_10-3 消息编号：3]\n\n# 线程编号为 19\n2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:19 Queue:QUEUE_DEMO_10-1 消息编号：1]\n2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:19 Queue:QUEUE_DEMO_10-1 消息编号：1]\n")])])]),r("ul",[r("li",[e._v("相同编号的消息，被投递到相同的"),r("strong",[e._v("子")]),e._v(" Queue ，被相同的线程所消费。符合预期~")])]),e._v(" "),r("h1",{attrs:{id:"_12-事务消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-事务消息"}},[e._v("#")]),e._v(" 12. 事务消息")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-transaction"),r("OutboundLink")],1),e._v(" 。")])]),e._v(" "),r("p",[e._v("RabbitMQ 内置提供事务消息的支持。对事务消息的概念不了解的胖友，可以看看 "),r("a",{attrs:{href:"http://www.iocoder.cn/RabbitMQ/message-confirmation-mechanism-transaction-Confirm/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《RabbitMQ 之消息确认机制（事务 + Confirm）》"),r("OutboundLink")],1),e._v(" 文章的"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「事务机制」"),r("OutboundLink")],1),e._v("小节。")]),e._v(" "),r("p",[e._v("不过 RabbitMQ 提供的并不是"),r("strong",[e._v("完整的")]),e._v("的事务消息的支持，缺少了"),r("strong",[e._v("回查机制")]),e._v("。目前，常用的分布式消息队列，只有 RocketMQ 提供了完整的事务消息的支持，具体的可以看看"),r("a",{attrs:{href:"http://www.iocoder.cn/Spring-Boot/RocketMQ/?self",target:"_blank",rel:"noopener noreferrer"}},[e._v("《芋道 Spring Boot 消息队列 RocketMQ 入门》"),r("OutboundLink")],1),e._v(" 的"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「9. 事务消息」"),r("OutboundLink")],1),e._v("小节，😈 暂时不拓展开来讲。")]),e._v(" "),r("p",[e._v("下面，我们开始本小节的示例。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-transaction"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_12-1-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-引入依赖"}},[e._v("#")]),e._v(" 12.1 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_12-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-应用配置文件"}},[e._v("#")]),e._v(" 12.2 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_12-3-demo11message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-demo11message"}},[e._v("#")]),e._v(" 12.3 Demo11Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo11Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo11Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_12-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-rabbitconfig"}},[e._v("#")]),e._v(" 12.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，额外配置事务相关的。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n@Configuration\n@EnableTransactionManagement\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo11Queue() {\n            return new Queue(Demo11Message.QUEUE, // Queue 名字\n                    true, // durable: 是否持久化\n                    false, // exclusive: 是否排它\n                    false); // autoDelete: 是否自动删除\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo11Exchange() {\n            return new DirectExchange(Demo11Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        // Exchange：Demo11Message.EXCHANGE\n        // Routing key：Demo11Message.ROUTING_KEY\n        // Queue：Demo11Message.QUEUE\n        @Bean\n        public Binding demo11Binding() {\n            return BindingBuilder.bind(demo11Queue()).to(demo11Exchange()).with(Demo11Message.ROUTING_KEY);\n        }\n\n    }\n\n    @Bean\n    public RabbitTransactionManager rabbitTransactionManager(ConnectionFactory connectionFactory, RabbitTemplate rabbitTemplate) {\n        // <Y> 设置 RabbitTemplate 支持事务\n        rabbitTemplate.setChannelTransacted(true);\n\n        // 创建 RabbitTransactionManager 对象\n        return new RabbitTransactionManager(connectionFactory);\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("DirectExchangeDemoConfiguration 配置类，用于定义 Queue、Exchange、Binding 的配置。")]),e._v(" "),r("li",[e._v("在类上，添加 "),r("code",[e._v("@EnableTransactionManagement")]),e._v(" 注解，开启"),r("a",{attrs:{href:"https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring Transaction"),r("OutboundLink")],1),e._v(" 的支持。")]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v("#rabbitTransactionManager()")]),e._v(" 方法，创建 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/transaction/RabbitTransactionManager.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitTransactionManager"),r("OutboundLink")],1),e._v(" 事务管理器 Bean 。")]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v("<Y>")]),e._v(" 处，标记创建的 RabbitMQ Channel 是事务性的，从而可以使用 RabbitMQ 的事务消息。")])]),e._v(" "),r("p",[e._v("因为 Spring-AMQP 通过 RabbitTransactionManager 来实现对 Spring Transaction 的集成，所以在实际开发中，我们只需要配合使用 "),r("code",[e._v("@Transactional")]),e._v(" 注解，来声明事务即可。")]),e._v(" "),r("h2",{attrs:{id:"_12-5-demo11producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12-5-demo11producer"}},[e._v("#")]),e._v(" 12.5 Demo11Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo11Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo11Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo11Producer.java\n\n@Component\npublic class Demo11Producer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Transactional\n    public void syncSend(Integer id) throws InterruptedException {\n        // 创建 Demo11Message 消息\n        Demo11Message message = new Demo11Message();\n        message.setId(id);\n        // 同步发送消息\n        rabbitTemplate.convertAndSend(Demo11Message.EXCHANGE, Demo11Message.ROUTING_KEY, message);\n        logger.info("[syncSend][发送编号：[{}] 发送成功]", id);\n\n        // <X> 等待\n        Thread.sleep(10 * 1000L);\n    }\n\n}\n')])])]),r("ul",[r("li",[r("p",[e._v("在发送消息方法上，我们添加了 "),r("code",[e._v("@Transactional")]),e._v(" 注解，声明事务。因为我们创建了 RabbitTransactionManager 事务管理器，所以这里会创建 RabbitMQ 事务。")])]),e._v(" "),r("li",[r("p",[e._v("在"),r("X",[e._v("处，我们故意等待")])],1),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code")])])])]),e._v(" "),r("p",[e._v("Thread#sleep(long millis)")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('\n10 秒，判断 RabbitMQ 事务是否生效。\n\n- 如果同步发送消息成功后，Consumer 立即消费到该消息，说明未生效。\n- 如果 Consumer 是 10 秒之后，才消费到该消息，说明已生效。\n\n## 12.6 Demo11Consumer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer) 包下，创建 [Demo11Consumer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo11Consumer.java) 类，消费消息。\n\n和[「3.1.7 Demo01Consumer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)基本一致，差别在于消费的队列是 `"QUEUE_DEMO_11"` 。\n\n## 12.7 简单测试\n\n创建 [Demo11ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo11ProducerTest.java) 测试类，编写单元测试方法，测试 Producer 发送**事务**消息的效果。代码如下：\n\n\n\n')])])]),r("p",[e._v("// Demo11ProducerTest.java")]),e._v(" "),r("p",[e._v("@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo11ProducerTest {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("@Autowired\nprivate Demo11Producer producer;\n\n@Test\npublic void testSyncSend() throws InterruptedException {\n    int id = (int) (System.currentTimeMillis() / 1000);\n    producer.syncSend(id);\n\n    // 阻塞等待，保证消费\n    new CountDownLatch(1).await();\n}\n")])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n执行单元测试方法，控制台输出如下：\n\n\n\n")])])]),r("p",[e._v("// Producer 成功同步发送了 1 条消息。此时，事务并未提交\n2019-12-12 22:03:05.525  INFO 17729 --- [           main] c.i.s.l.r.producer.Demo11Producer        : [syncSend][发送编号：[1576159385] 发送成功]")]),e._v(" "),r("p",[e._v("// 10 秒后，Producer 提交事务。\n// 此时，Consumer 消费到该消息。\n2019-12-12 22:03:15.548  INFO 17729 --- [ntContainer#4-1] c.i.s.l.r.consumer.Demo11Consumer        : [onMessage][线程编号:25 消息内容：Demo11Message{id=1576159385}]")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- Consumer 在事务消息提交后，消费到该消息。符合预期~\n\n# 13. 消费者的消息确认\n\n> 示例代码对应仓库：[lab-04-rabbitmq-demo-ack](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack) 。\n\n在 RabbitMQ 中，Consumer 有两种消息确认的方式：\n\n- 方式一，自动确认。\n- 方式二，手动确认。\n\n对于**自动确认**的方式，RabbitMQ Broker 只要将消息写入到 TCP Socket 中成功，就认为该消息投递成功，而无需 Consumer **手动确认**。\n\n对于**手动确认**的方式，RabbitMQ Broker 将消息发送给 Consumer 之后，由 Consumer **手动确认**之后，才任务消息投递成功。\n\n实际场景下，因为自动确认存在可能**丢失消息**的情况，所以在对**可靠性**有要求的场景下，我们基本采用手动确认。当然，如果允许消息有一定的丢失，对**性能**有更高的产经下，我们可以考虑采用自动确认。\n\n😈 更多关于消费者的消息确认的内容，胖友可以阅读如下的文章：\n\n- [《Consumer Acknowledgements and Publisher Confirms》](https://www.rabbitmq.com/confirms.html) 的消费者部分的内容，对应中文翻译为 [《消费者应答（ACK）和发布者确认（Confirm）》](https://blog.bossma.cn/rabbitmq/consumer-ack-and-publisher-confirm/) 。\n- [《RabbitMQ 之消息确认机制（事务 + Confirm）》](http://www.iocoder.cn/RabbitMQ/message-confirmation-mechanism-transaction-Confirm/?self) 文章的[「消息确认（Consumer端）」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)小节。\n\n在 Spring-AMQP 中，在 [AcknowledgeMode](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/AcknowledgeMode.java) 中，定义了三种消息确认的方式：\n\n\n\n")])])]),r("p",[e._v("// AcknowledgeMode.java")]),e._v(" "),r("p",[e._v("/**")]),e._v(" "),r("ul",[r("li",[e._v("No acks - {@code autoAck=true} in {@code Channel.basicConsume()}.\n*/\nNONE, // 对应 Consumer 的自动确认")])]),e._v(" "),r("p",[e._v("/**")]),e._v(" "),r("ul",[r("li",[e._v("Manual acks - user must ack/nack via a channel aware listener.\n*/\nMANUAL, // 对应 Consumer 的手动确认，由开发者在消费逻辑中，手动进行确认。")])]),e._v(" "),r("p",[e._v("/**")]),e._v(" "),r("ul",[r("li",[e._v("Auto - the container will issue the ack/nack based on whether")]),e._v(" "),r("li",[e._v("the listener returns normally, or throws an exception.")]),e._v(" "),r("li",[r("p",[r("em",[e._v("Do not confuse with RabbitMQ {@code autoAck} which is\n")])])]),e._v(" "),r("li",[e._v("represented by {@link #NONE} here"),e._v(".\n*/\nAUTO; // 对应 Consumer 的手动确认，在消费消息完成（包括正常返回、和抛出异常）后，由 Spring-AMQP 框架来“自动”进行确认。")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 实际上，就是将**手动确认**进一步细分，提供了由 Spring-AMQP 提供 Consumer 级别的自动确认。\n\n**在上述的示例中，我们都采用了 Spring-AMQP 默认的 `AUTO` 模式**。下面，我们来搭建一个 `MANUAL` 模式，手动确认的示例。考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-ack](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack) 项目。\n\n## 13.1 引入依赖\n\n和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/pom.xml) 文件。\n\n## 13.2 应用配置文件\n\n在 [`resources`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/resources) 目录下，创建 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/resources/application.yaml) 配置文件。配置如下：\n\n\n\n")])])]),r("p",[e._v("spring:")]),e._v(" "),r("h1",{attrs:{id:"rabbitmq-配置项-对应-rabbitproperties-配置类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-配置项-对应-rabbitproperties-配置类"}},[e._v("#")]),e._v(" RabbitMQ 配置项，对应 RabbitProperties 配置类")]),e._v(" "),r("p",[e._v("rabbitmq:\nhost: 127.0.0.1 # RabbitMQ 服务的地址\nport: 5672 # RabbitMQ 服务的端口\nusername: guest # RabbitMQ 服务的账号\npassword: guest # RabbitMQ 服务的密码\nlistener:\nsimple:\nacknowledge-mode: manual # 配置 Consumer 手动提交")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 相比[「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)来说，我们通过**新增** `spring.rabbitmq.listener.simple.acknowledge-mode=true` 配置项，来配置 Consumer 手动提交。\n\n## 13.3 Demo12Message\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message) 包下，创建 [Demo12Message](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo12Message.java) 消息类，提供给当前示例使用。\n\n和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。\n\n## 13.4 RabbitConfig\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，配置相关的 Exchange、Queue、Binding 。\n\n和[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。\n\n## 13.5 Demo12Producer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo12Producer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/Demo12Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。\n\n和[「3.1.6 Demo01Producer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、RoutingKey 名字不同。\n\n## 13.6 Demo12Consumer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer) 包下，创建 [Demo09Consumer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo12Consumer.java) 类，消费消息。代码如下：\n\n\n\n")])])]),r("p",[e._v("// Demo12Consumer.java")]),e._v(" "),r("p",[e._v("@Component\n@RabbitListener(queues = Demo12Message.QUEUE)\npublic class Demo12Consumer {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\n@RabbitHandler\npublic void onMessage(Demo12Message message, Channel channel,\n                      @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) throws IOException {\n    logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    // 提交消费进度\n    if (message.getId() % 2 == 1) {\n        // ack 确认消息\n        // 第二个参数 multiple ，用于批量确认消息，为了减少网络流量，手动确认可以被批处。\n        // 1. 当 multiple 为 true 时，则可以一次性确认 deliveryTag 小于等于传入值的所有消息\n        // 2. 当 multiple 为 false 时，则只确认当前 deliveryTag 对应的消息\n        channel.basicAck(deliveryTag, false);\n    }\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 在消费方法上，我们增加类型为 [Channel](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java) 的方法参数，和 `deliveryTag` 。通过调用其 `Channel#basicAck(deliveryTag, multiple)` 方法，可以进行消息的确认。这里，艿艿添加了比较详细的注释说明，胖友可以自己瞅瞅噢。\n- 在 `@RabbitListener` 注解的 `ackMode` 属性，我们可以设置自定义的 AcknowledgeMode 模式。\n- 在消费逻辑中，我们故意只提交消费的消息的 `Demo12Message.id` 为**奇数**的消息。😈 这样，我们只需要发送一条 `id=1` ，一条 `id=2` 的消息，如果第二条的消费进度没有被提交，就可以说明手动提交消费进度成功。\n\n## 13.7 简单测试\n\n创建 [Demo12ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo12ProducerTest.java) 测试类，编写单元测试方法，测试手动提交消费进度。代码如下：\n\n\n\n")])])]),r("p",[e._v("// Demo12ProducerTest.java")]),e._v(" "),r("p",[e._v("@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo12ProducerTest {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\n@Autowired\nprivate Demo12Producer producer;\n\n@Test\npublic void testSyncSend() throws InterruptedException {\n    for (int id = 1; id <= 2; id++) {\n        producer.syncSend(id);\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n    }\n\n    // 阻塞等待，保证消费\n    new CountDownLatch(1).await();\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n执行 `#testSyncSend()` 单元测试，输出日志如下：\n\n\n\n")])])]),r("p",[e._v("// Producer 同步发送 2 条消息成功\n2019-12-13 00:19:33.403  INFO 45869 --- [           main] c.i.s.l.r.producer.Demo12ProducerTest    : [testSyncSend][发送编号：[1] 发送成功]\n2019-12-13 00:19:33.406  INFO 45869 --- [           main] c.i.s.l.r.producer.Demo12ProducerTest    : [testSyncSend][发送编号：[2] 发送成功]")]),e._v(" "),r("p",[e._v("// Demo08Consumer 消费 2 条消息成功\n2019-12-13 00:19:33.420  INFO 45869 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo12Consumer        : [onMessage][线程编号:17 消息内容：Demo12Message{id=1}]\n2019-12-13 00:19:33.421  INFO 45869 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo12Consumer        : [onMessage][线程编号:17 消息内容：Demo12Message{id=2}]")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('\n\n\n此时，如果我们使用 [RabbitMQ Management](https://static.iocoder.cn/7c5541295505e7a3be4ac7ab2882feeb) 来查看 `"DEMO_12"` 的该消费者：\n\n\n![](https://raw.githubusercontent.com/lichengcan/images/main/02.png)\n\n- 有 1 条消息的未确认，符合预期~\n\n# 14. 生产者的发送确认\n\n在 RabbitMQ 中，**默认**情况下，Producer 发送消息的方法，只保证将消息写入到 TCP Socket 中成功，并不保证消息发送到 RabbitMQ Broker 成功，并且持久化消息到磁盘成功。\n\n也就是说，我们上述的示例，Producer 在发送消息都不是绝对可靠，是存在丢失消息的可能性。\n\n不过不用担心，在 RabbitMQ 中，Producer 采用 Confirm 模式，实现发送消息的确认机制，以保证消息发送的可靠性。实现原理如下：\n\n- 首先，Producer 通过调用 [`Channel#confirmSelect()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1278-L1283) 方法，将 Channel 设置为 Confirm 模式。\n- 然后，在该 Channel 发送的消息时，需要先通过 [`Channel#getNextPublishSeqNo()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1285-L1290) 方法，给发送的消息分配一个唯一的 ID 编号(`seqNo` 从 1 开始递增)，再发送该消息给 RabbitMQ Broker 。\n- 之后，RabbitMQ Broker 在接收到该消息，并被路由到相应的队列之后，会发送一个包含消息的唯一编号(`deliveryTag`)的确认给 Producer 。\n\n通过 `seqNo` 编号，将 Producer 发送消息的“请求”，和 RabbitMQ Broker 确认消息的“响应”串联在一起。\n\n通过这样的方式，Producer 就可以知道消息是否成功发送到 RabbitMQ Broker 之中，保证消息发送的可靠性。不过要注意，整个执行的过程实际是**异步**，需要我们调用 [`Channel#waitForConfirms()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1293-L1329) 方法，**同步**阻塞等待 RabbitMQ Broker 确认消息的“响应”。\n\n也因此，Producer 采用 Confirm 模式时，有三种编程方式：\n\n- 【同步】普通 Confirm 模式：Producer 每发送一条消息后，调用 `Channel#waitForConfirms()` 方法，等待服务器端 Confirm 。\n\n- 【同步】批量 Confirm 模式：Producer 每发送一批消息后，调用`Channel#waitForConfirms()` 方法，等待服务器端 Confirm 。\n\n  > 本质上，和「普通 Confirm 模式」是一样的。\n\n- 【异步】异步 Confirm 模式：Producer 提供一个回调方法，RabbitMQ Broker 在 Confirm 了一条或者多条消息后，Producer 会回调这个方法。\n\n😈 更多关于 Producer 的 Confirm 模式的内容，胖友可以阅读如下的文章：\n\n- [《Consumer Acknowledgements and Publisher Confirms》](https://www.rabbitmq.com/confirms.html) 的生产者部分的内容，对应中文翻译为 [《消费者应答（ACK）和发布者确认（Confirm）》](https://blog.bossma.cn/rabbitmq/consumer-ack-and-publisher-confirm/) 。\n- [《RabbitMQ 之消息确认机制（事务 + Confirm）》](http://www.iocoder.cn/RabbitMQ/message-confirmation-mechanism-transaction-Confirm/?self) 文章的[「Confirm 模式」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)小节。\n\n在 Spring-AMQP 中，在 [ConfirmType](https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/connection/CachingConnectionFactory.java#L145-L167) 中，定义了三种消息确认的方式：\n\n\n\n')])])]),r("p",[e._v("// CachingConnectionFactory#ConfirmType.java")]),e._v(" "),r("p",[e._v("public enum ConfirmType {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("/**\n * Use {@code RabbitTemplate#waitForConfirms()} (or {@code waitForConfirmsOrDie()}\n * within scoped operations.\n */\nSIMPLE, // 使用同步的 Confirm 模式\n\n/**\n * Use with {@code CorrelationData} to correlate confirmations with sent\n * messsages.\n */\nCORRELATED, // 使用异步的 Confirm 模式\n\n/**\n * Publisher confirms are disabled (default).\n */\nNONE // 不使用 Confirm 模式\n")])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n**在上述的示例中，我们都采用了 Spring-AMQP 默认的 `NONE` 模式**。下面，我们来搭建两个示例：\n\n- 在[「14.1 同步 Confirm 模式」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 中，我们会使用 `SIMPLE` 类型，实现同步的 Confirm 模式。\n- 在[「14.2 异步 Confirm 模式」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 中，我们会使用 `CORRELATED` 类型，使用异步的 Confirm 模式。\n\n## 14.1 同步 Confirm 模式\n\n> 示例代码对应仓库：[lab-04-rabbitmq-demo-confirm](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm) 。\n\n在本小节中，我们会使用 `ConfirmType.SIMPLE` 类型，实现同步的 Confirm 模式。\n\n要注意，这里的**同步**，指的是我们通过调用 [`Channel#waitForConfirms()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1293-L1329) 方法，**同步**阻塞等待 RabbitMQ Broker 确认消息的“响应”。\n\n考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-confirm](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm) 项目。\n\n### 14.1.1 引入依赖\n\n和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/pom.xml) 文件。\n\n### 14.1.2 应用配置文件\n\n在 [`resources`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/resources) 目录下，创建 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/resources/application.yaml) 配置文件。配置如下：\n\n\n\n")])])]),r("p",[e._v("spring:")]),e._v(" "),r("h1",{attrs:{id:"rabbitmq-配置项-对应-rabbitproperties-配置类-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-配置项-对应-rabbitproperties-配置类-2"}},[e._v("#")]),e._v(" RabbitMQ 配置项，对应 RabbitProperties 配置类")]),e._v(" "),r("p",[e._v("rabbitmq:\nhost: 127.0.0.1 # RabbitMQ 服务的地址\nport: 5672 # RabbitMQ 服务的端口\nusername: guest # RabbitMQ 服务的账号\npassword: guest # RabbitMQ 服务的密码\npublisher-confirm-type: simple # 设置 Confirm 类型为 SIMPLE 。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 相比[「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)来说，我们通过**新增** `spring.rabbitmq.publisher-confirm-type=simple` 配置项，设置 Confirm 类型为 `ConfirmType.SIMPLE` 。\n\n在该类型下，Spring-AMQP 在创建完 RabbitMQ Channel 之后，会**自动**调用 [`Channel#confirmSelect()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1278-L1283) 方法，将 Channel 设置为 Confirm 模式。\n\n### 14.1.3 Demo13Message\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message) 包下，创建 [Demo13Message](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo13Message.java) 消息类，提供给当前示例使用。\n\n和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。\n\n### 14.1.4 RabbitConfig\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，配置相关的 Exchange、Queue、Binding 。\n\n和[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。\n\n### 14.1.4 Demo13Producer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo13Producer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。\n\n\n\n")])])]),r("p",[e._v("// Demo13Producer.java")]),e._v(" "),r("p",[e._v("@Component\npublic class Demo13Producer {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\npublic void syncSend(Integer id) {\n    // 创建 Demo13Message 消息\n    Demo13Message message = new Demo13Message();\n    message.setId(id);\n    // 同步发送消息\n    rabbitTemplate.invoke(new RabbitOperations.OperationsCallback<Object>() {\n\n        @Override\n        public Object doInRabbit(RabbitOperations operations) {\n            // 同步发送消息\n            operations.convertAndSend(Demo13Message.EXCHANGE, Demo13Message.ROUTING_KEY, message);\n            logger.info("[doInRabbit][发送消息完成]");\n            // 等待确认\n            operations.waitForConfirms(0); // timeout 参数，如果传递 0 ，表示无限等待\n            logger.info("[doInRabbit][等待 Confirm 完成]");\n            return null;\n        }\n\n    }, new ConfirmCallback() {\n\n        @Override\n        public void handle(long deliveryTag, boolean multiple) throws IOException {\n            logger.info("[handle][Confirm 成功]");\n        }\n\n    }, new ConfirmCallback() {\n\n        @Override\n        public void handle(long deliveryTag, boolean multiple) throws IOException {\n            logger.info("[handle][Confirm 失败]");\n        }\n\n    });\n\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 在 RabbitTemplate 提供的 API 方法中，如果 Producer 要使用同步的 Confirm 模式，需要调用 `#invoke(action, acks, nacks)` 方法。代码如下：\n\n")])])]),r("p",[e._v("// RabbitOperations.java\n// RabbitTemplate 实现了 RabbitOperations 接口")]),e._v(" "),r("p",[e._v("/**")]),e._v(" "),r("ul",[r("li",[e._v("Invoke operations on the same channel.")]),e._v(" "),r("li",[e._v("If callbacks are needed, both callbacks must be supplied.")]),e._v(" "),r("li",[e._v("@param action the callback.")]),e._v(" "),r("li",[e._v("@param acks a confirm callback for acks.")]),e._v(" "),r("li",[e._v("@param nacks a confirm callback for nacks.")]),e._v(" "),r("li",[e._v("@param "),r("T",[e._v(" the return type.")])],1),e._v(" "),r("li",[e._v("@return the result of the action method.")]),e._v(" "),r("li",[e._v("@since 2.1\n*/\n@Nullable\n"),r("T",[e._v(" T invoke(OperationsCallback"),r("T",[e._v(" action, @Nullable com.rabbitmq.client.ConfirmCallback acks,\n@Nullable com.rabbitmq.client.ConfirmCallback nacks);")])],1)],1)]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('\n\n\n- 因为 Confirm 模式需要基于**相同** Channel ，所以我们需要使用该方法。\n- 在方法参数 `action` 中，我们可以自定义操作。\n- 在方法参数 `acks` 中，定义接收到 RabbitMQ Broker 的成功“响应”时的成回调。\n- 在方法参数 `nacks` 中，定义接收到 RabbitMQ Broker 的失败“响应”时的成回调。\n\n> - 当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息。\n> - 如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n- 具体的发送方法的代码，胖友根据艿艿的注释，进行理解下。\n\n### 14.1.5 Demo13Consumer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer) 包下，创建 [Demo13Consumer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo13Consumer.java) 类，消费消息。\n\n和[「3.1.7 Demo01Consumer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)基本一致，差别在于消费的队列是 `"QUEUE_DEMO_13"` 。\n\n### 14.1.6 简单测试\n\n创建 [Demo13ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13ProducerTest.java) 测试类，编写单元测试方法，调用 Demo13Producer 发送消息的方法。代码如下：\n\n\n\n')])])]),r("p",[e._v("// Demo13ProducerTest.java")]),e._v(" "),r("p",[e._v("@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo13ProducerTest {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\n@Autowired\nprivate Demo13Producer producer;\n\n@Test\npublic void testSyncSend() throws InterruptedException {\n    int id = (int) (System.currentTimeMillis() / 1000);\n    producer.syncSend(id);\n    logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n    // 阻塞等待，保证消费\n    new CountDownLatch(1).await();\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n执行 `#testSyncSend()` 单元测试，输出日志如下：\n\n\n\n")])])]),r("p",[e._v("// 主线程，Producer 发送 1 条消息完成。\n2019-12-13 12:49:13.680  INFO 13247 --- [           main] c.i.s.l.r.producer.Demo13Producer        : [doInRabbit][发送消息完成]")]),e._v(" "),r("p",[e._v("// AMQConnection 线程，Producer 确认收到 RabbitMQ Broker 对该消息的成功“响应” 。\n2019-12-13 12:49:13.689  INFO 13247 --- [ 127.0.0.1:5672] c.i.s.l.r.producer.Demo13Producer        : [handle][Confirm 成功]")]),e._v(" "),r("p",[e._v("// 主线程，Producer 等待该消息的 Confirm 完成。\n2019-12-13 12:49:13.689  INFO 13247 --- [           main] c.i.s.l.r.producer.Demo13Producer        : [doInRabbit][等待 Confirm 完成]")]),e._v(" "),r("p",[e._v("// 单元测试，打印下日志，可以忽略\n2019-12-13 12:49:13.694  INFO 13247 --- [           main] c.i.s.l.r.producer.Demo13ProducerTest    :\n[testSyncSend][发送编号：[1576212553] 发送成功]")]),e._v(" "),r("p",[e._v("// 消费者的线程，Consumer 消费到该消息\n2019-12-13 12:49:13.699  INFO 13247 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo13Consumer        : [onMessage][线程编号:17 消息内容：Demo13Message{id=1576212553}]")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。\n\n## 14.2 异步 Confirm 模式\n\n> 示例代码对应仓库：[lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 。\n\n在本小节中，我们会使用 `ConfirmType.SIMPLE` 类型，实现异步的 Confirm 模式。\n\n考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 项目。\n\n### 14.2.1 引入依赖\n\n和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/pom.xml) 文件。\n\n### 14.2.2 应用配置文件\n\n在 [`resources`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/resources) 目录下，创建 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/resources/application.yaml) 配置文件。配置如下：\n\n\n\n")])])]),r("p",[e._v("spring:")]),e._v(" "),r("h1",{attrs:{id:"rabbitmq-配置项-对应-rabbitproperties-配置类-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-配置项-对应-rabbitproperties-配置类-3"}},[e._v("#")]),e._v(" RabbitMQ 配置项，对应 RabbitProperties 配置类")]),e._v(" "),r("p",[e._v("rabbitmq:\nhost: 127.0.0.1 # RabbitMQ 服务的地址\nport: 5672 # RabbitMQ 服务的端口\nusername: guest # RabbitMQ 服务的账号\npassword: guest # RabbitMQ 服务的密码\npublisher-confirm-type: correlated # 设置 Confirm 类型为 CORRELATED 。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 相比[「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)来说，我们通过**新增** `spring.rabbitmq.publisher-confirm-type=correlated` 配置项，设置 Confirm 类型为 `ConfirmType.CORRELATED` 。\n\n在该类型下，Spring-AMQP 在创建完 RabbitMQ Channel 之后，也会**自动**调用 [`Channel#confirmSelect()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1278-L1283) 方法，将 Channel 设置为 Confirm 模式。\n\n### 14.2.3 Demo13Message\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/) 包下，创建 [Demo13Message](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo13Message.java) 消息类，提供给当前示例使用。\n\n和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。\n\n### 14.2.4 RabbitConfig\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，配置相关的 Exchange、Queue、Binding 。\n\n和[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。\n\n### 14.2.5 RabbitProducerConfirmCallback\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.core`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/) 包下，创建 [RabbitProducerConfirmCallback](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitProducerConfirmCallback.java) 类，实现 [RabbitTemplate.ConfirmCallback](https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java#L2712-L2727) 接口，提供 Producer 收到 RabbitMQ 确认消息的“响应”的回调。代码如下：\n\n\n\n")])])]),r("p",[e._v("// RabbitProducerConfirmCallback.java")]),e._v(" "),r("p",[e._v("@Component\npublic class RabbitProducerConfirmCallback implements RabbitTemplate.ConfirmCallback {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\npublic RabbitProducerConfirmCallback(RabbitTemplate rabbitTemplate) {\n    rabbitTemplate.setConfirmCallback(this);\n}\n\n@Override\npublic void confirm(CorrelationData correlationData, boolean ack, String cause) {\n    if (ack) {\n        logger.info("[confirm][Confirm 成功 correlationData: {}]", correlationData);\n    } else {\n        logger.error("[confirm][Confirm 失败 correlationData: {} cause: {}]", correlationData, cause);\n    }\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 在构造方法中，把自己设置到 RabbitTemplate 中，作为 Confirm 的回调。\n- 在 `#confirm(...)` 方法中，根据是否 `ack` 成功，打印不同的日志。\n\n### 14.2.6 Demo13Producer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo13Producer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。\n\n\n\n")])])]),r("p",[e._v("// Demo13Producer.java")]),e._v(" "),r("p",[e._v("@Component\npublic class Demo13Producer {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\npublic void syncSend(Integer id) {\n    // 创建 Demo13Message 消息\n    Demo13Message message = new Demo13Message();\n    message.setId(id);\n    // 同步发送消息\n    rabbitTemplate.convertAndSend(Demo13Message.EXCHANGE, Demo13Message.ROUTING_KEY, message);\n}\n")])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('\n\n\n- 不需要像[「14.1.4 Demo13Producer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一样，而是直接像我们其它示例一样，直接使用 RabbitTemplate 的 `#convertAndSend(...)` 等等方法即可。\n\n### 14.2.7 Demo13Consumer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/) 包下，创建 [Demo13Consumer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo13Consumer.java) 类，消费消息。\n\n和[「3.1.7 Demo01Consumer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)基本一致，差别在于消费的队列是 `"QUEUE_DEMO_13"` 。\n\n### 14.2.8 简单测试\n\n创建 [Demo13ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 测试类，编写单元测试方法，调用 Demo13Producer 发送消息的方法。代码如下：\n\n\n\n')])])]),r("p",[e._v("// Demo13ProducerTest.java")]),e._v(" "),r("p",[e._v("@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo13ProducerTest {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\n@Autowired\nprivate Demo13Producer producer;\n\n@Test\npublic void testSyncSend() throws InterruptedException {\n    int id = (int) (System.currentTimeMillis() / 1000);\n    producer.syncSend(id);\n    logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n    // 阻塞等待，保证消费\n    new CountDownLatch(1).await();\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n执行 `#testSyncSend()` 单元测试，输出日志如下：\n\n\n\n")])])]),r("p",[e._v("// 单元测试，打印下日志，可以忽略\n2019-12-13 17:17:45.849  INFO 69003 --- [           main] c.i.s.l.r.producer.Demo13ProducerTest    :\n[testSyncSend][发送编号：[1576228665] 发送成功]")]),e._v(" "),r("p",[e._v("// RabbitConnectionFactory 线程，Producer 确认收到 RabbitMQ Broker 对该消息的成功“响应” 。\n// 因为我们在 Demo13Producer 发送消息的时候，并未传入 CorrelationData 参数，所以为 null 。\n2019-12-13 17:17:45.859  INFO 69003 --- [nectionFactory1] .i.s.l.r.c.RabbitProducerConfirmCallback : [confirm][Confirm 成功 correlationData: null]")]),e._v(" "),r("p",[e._v("// 消费者的线程，Consumer 消费到该消息\n2019-12-13 17:17:45.873  INFO 69003 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo13Consumer        : [onMessage][线程编号:17 消息内容：Demo13Message{id=1576228665}]")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。\n\n## 14.3 ReturnCallback\n\n> 示例代码对应仓库：[lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 。\n\n当 Producer 成功发送消息到 RabbitMQ Broker 时，但是在通过 Exchange 进行**匹配不到** Queue 时，Broker 会将该消息回退给 Producer 。\n\n下面，我们来创建一个使用示例，继续在 [lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 项目改造。\n\n### 14.3.1 RabbitProducerReturnCallback\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.core`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/) 包下，创建 [RabbitProducerReturnCallback](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitProducerReturnCallback.java) 类，实现 [RabbitTemplate.ReturnCallback](https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java#L2712-L2727) 接口，提供 Producer 收到 RabbitMQ Broker 回退消息的的回调。代码如下：\n\n\n\n")])])]),r("p",[e._v("// RabbitProducerReturnCallback.java")]),e._v(" "),r("p",[e._v("@Component\npublic class RabbitProducerReturnCallback implements RabbitTemplate.ReturnCallback {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\npublic RabbitProducerReturnCallback(RabbitTemplate rabbitTemplate) {\n    rabbitTemplate.setReturnCallback(this);\n}\n\n@Override\npublic void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n    logger.error("[returnedMessage][message: [{}] replyCode: [{}] replyText: [{}] exchange: [{}] routingKey: [{}]]",\n            message, replyCode, replyText, exchange, routingKey);\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 在构造方法中，把自己设置到 RabbitTemplate 中，作为消息 Return 的回调。\n- 在 `#returnedMessage(...)` 方法中，打印错误日志。当然，具体怎么处理，胖友可以根据自己的需要哈。\n\n### 14.3.2 Demo13Producer\n\n修改 [Demo13Producer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13Producer.java) 类，增加一个发送无法匹配到 Queue 的消息的方法。代码如下：\n\n\n\n")])])]),r("p",[e._v("// Demo13Producer.java")]),e._v(" "),r("p",[e._v('public void syncSendReturn(Integer id) {\n// 创建 Demo13Message 消息\nDemo13Message message = new Demo13Message();\nmessage.setId(id);\n// 同步发送消息\nrabbitTemplate.convertAndSend(Demo13Message.EXCHANGE, "error", message);\n}')]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 发送消息的 RoutingKey ，我们故意设置为 `error` ，达到消息无法匹配到 Queue 的效果。\n\n### 14.3.3 简单测试\n\n修改 [Demo13ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13ProducerTest.java) 测试类，增加调用 Demo13Producer 新增的方法。代码如下：\n\n\n\n")])])]),r("p",[e._v("// Demo13ProducerTest.java")]),e._v(" "),r("p",[e._v('@Test\npublic void testSyncSendReturn() throws InterruptedException {\nint id = (int) (System.currentTimeMillis() / 1000);\nproducer.syncSendReturn(id);\nlogger.info("[testSyncSendReturn][发送编号：[{}] 发送成功]", id);')]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("// 阻塞等待，保证消费\nnew CountDownLatch(1).await();\n")])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n执行 `#testSyncSendReturn()` 单元测试，输出日志如下：\n\n\n\n")])])]),r("p",[e._v("// 单元测试，打印下日志，可以忽略\n2019-12-13 17:40:57.130  INFO 74326 --- [           main] c.i.s.l.r.producer.Demo13ProducerTest    : [testSyncSendReturn][发送编号：[1576230057] 发送成功]")]),e._v(" "),r("p",[e._v("// RabbitConnectionFactory 线程，Producer 确认收到 RabbitMQ Broker 对该消息的退回 。\n2019-12-13 17:41:02.817 ERROR 74326 --- [nectionFactory1] c.i.s.l.r.c.RabbitProducerReturnCallback : [returnedMessage][message: [(Body:'[B@4689be61(byte[187])' MessageProperties [headers={}, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0])] replyCode: [312] replyText: [NO_ROUTE] exchange: [EXCHANGE_DEMO_13] routingKey: []]")]),e._v(" "),r("p",[e._v("// RabbitConnectionFactory 线程，Producer 确认收到 RabbitMQ Broker 对该消息的成功“响应” 。\n// 注意，即使存在 RabbitMQ Broker 回退消息的情况，依然会收到对该消息的成功“响应”\n2019-12-13 17:41:02.819  INFO 74326 --- [nectionFactory1] .i.s.l.r.c.RabbitProducerConfirmCallback : [confirm][Confirm 成功 correlationData: null]")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。\n\n# 15. RPC 远程调用\n\n> 示例代码对应仓库：[lab-04-rabbitmq-demo-rpc](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc) 。\n\n在 RabbitMQ 中，我们可以通过 [Direct Reply-to](https://www.rabbitmq.com/direct-reply-to.html) 特性，实现 RPC 远程调用的功能。具体的实现原理，胖友自己看[《RabbitMQ 之 RPC 实现》](http://www.iocoder.cn/RabbitMQ/RPC-implementation/?self)文章，这里艿艿就不赘述了。\n\n下面，我们来搭建一个 RPC 的示例。考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-rpc](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc) 项目。\n\n## 15.1 引入依赖\n\n和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/pom.xml) 文件。\n\n## 15.2 应用配置文件\n\n和 [「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo14ProducerTest.java) 文件。\n\n## 15.3 Demo14Message\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message) 包下，创建 [Demo14Message](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo14Message.java) 消息类，提供给当前示例使用。\n\n和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。\n\n## 15.4 RabbitConfig\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，添加 Direct Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：\n\n\n\n")])])]),r("p",[e._v("// RabbitConfig.java")]),e._v(" "),r("p",[e._v("@Configuration\npublic class RabbitConfig {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("/**\n * Direct Exchange 示例的配置类\n */\npublic static class DirectExchangeDemoConfiguration {\n\n    // 创建 Queue\n    @Bean\n    public Queue demo01Queue() {\n        return new Queue(Demo14Message.QUEUE, // Queue 名字\n                false, // durable: 是否持久化\n                false, // exclusive: 是否排它\n                false); // autoDelete: 是否自动删除\n    }\n\n    // 创建 Direct Exchange\n    @Bean\n    public DirectExchange demo01Exchange() {\n        return new DirectExchange(Demo14Message.EXCHANGE,\n                false,  // durable: 是否持久化\n                false);  // autoDelete: 是否自动删除\n    }\n\n    // 创建 Binding\n    // Exchange：Demo01Message.EXCHANGE\n    // Routing key：Demo01Message.ROUTING_KEY\n    // Queue：Demo01Message.QUEUE\n    @Bean\n    public Binding demo01Binding() {\n        return BindingBuilder.bind(demo01Queue()).to(demo01Exchange()).with(Demo14Message.ROUTING_KEY);\n    }\n\n}\n")])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 不同于[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)的配置，我们设置队列里的消息无需持久化，毕竟 RPC 是个瞬态操作。\n\n## 15.5 Demo14Producer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo14Producer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo14Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现 RPC 操作。代码如下：\n\n\n\n")])])]),r("p",[e._v("// Demo14Producer.java")]),e._v(" "),r("p",[e._v("@Component\npublic class Demo14Producer {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\npublic String syncSend(Integer id) {\n    // 创建 Demo01Message 消息\n    Demo14Message message = new Demo14Message();\n    message.setId(id);\n    // <1> 创建 CorrelationData 对象\n    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());\n    // <2> 同步发送消息，并接收结果\n    return (String) rabbitTemplate.convertSendAndReceive(Demo14Message.EXCHANGE, Demo14Message.ROUTING_KEY, message,\n            correlationData);\n}\n")])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- `<1>` 处，创建 CorrelationData 对象，使用 UUID 作为唯一标识。\n- `<2>` 处，调用 `RabbitTemplate#convertSendAndReceive(exchange, routingKey, message, correlationData)` 方法，Producer 发送消息，并等待结果。该结果，是 Consumer 消费消息，返回的结果。\n\n## 15.6 Demo14Consumer\n\n在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/) 包下，创建 [Demo14Consumer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo14Consumer.java) 类，消费消息。代码如下：\n\n\n\n")])])]),r("p",[e._v("// Demo14Consumer.java")]),e._v(" "),r("p",[e._v("@Component\n@RabbitListener(queues = Demo14Message.QUEUE)\npublic class Demo14Consumer {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\n@RabbitHandler\npublic String onMessage(Demo14Message message) {\n    logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n    // 返回结果\n    return "nicai";\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('\n\n\n- 消费完成后，额外返回了 `"nicai"` 字符串。\n\n## 15.7 简单测试\n\n创建 [Demo14ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo14ProducerTest.java) 测试类，编写单元测试方法，调用 Demo14Producer 的 RPC 的方法。代码如下：\n\n\n\n')])])]),r("p",[e._v("// Demo14ProducerTest.java")]),e._v(" "),r("p",[e._v("@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo14ProducerTest {")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('private Logger logger = LoggerFactory.getLogger(getClass());\n\n@Autowired\nprivate Demo14Producer producer;\n\n@Test\npublic void testSyncSend() throws InterruptedException {\n    int id = (int) (System.currentTimeMillis() / 1000);\n    String result = producer.syncSend(id);\n    logger.info("[testSyncSend][发送编号：[{}] 发送成功 消费结果：[{}]]", id, result);\n\n    // 阻塞等待，保证消费\n    new CountDownLatch(1).await();\n}\n')])])]),r("p",[e._v("}")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n执行 `#testSyncSend()` 单元测试，输出日志如下：\n\n\n\n")])])]),r("h1",{attrs:{id:"demo14consumer-成功消费发送的消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#demo14consumer-成功消费发送的消息"}},[e._v("#")]),e._v(" Demo14Consumer 成功消费发送的消息")]),e._v(" "),r("p",[e._v("2019-12-13 19:13:36.627  INFO 93696 --- [ntContainer#4-1] c.i.s.l.r.consumer.Demo14Consumer        : [onMessage][线程编号:25 消息内容：Demo14Message{id=1576235616}]")]),e._v(" "),r("h1",{attrs:{id:"producer-打印发送消息的消费结果"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#producer-打印发送消息的消费结果"}},[e._v("#")]),e._v(" Producer 打印发送消息的消费结果")]),e._v(" "),r("p",[e._v("2019-12-13 19:13:36.630  INFO 93696 --- [           main] c.i.s.l.r.producer.Demo14ProducerTest    : [testSyncSend][发送编号：[1576235616] 发送成功 消费结果：[nicai]]")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n\n\n- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。\n\n😈 通过 RabbitMQ 来实现 RPC 的功能，看起来是比较酷炫的。不过艿艿暂时没有想到实际的使用场景，有了解的胖友，麻烦告知下艿艿噢，谢谢。\n\n# 16. MessageConverter\n\n> 示例代码对应仓库：[lab-04-rabbitmq-demo-json](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json) 。\n\n在 Spring-AMQP 中，通过 [MessageConverter](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/support/converter/MessageConverter.java) 来作为消息转换器：\n\n- 在 Producer 中，将 Java POJO 转换成 AMQP [Message](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/Message.java) 。\n- 在 Consumer 中，将 AMQP [Message](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/Message.java) 转换成 Java POJO 。\n\n默认情况下，RabbitTemplate 采用 [SimpleMessageConverter](https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/converter/SimpleMessageConverter.java) 。而 SimpleMessageConverter 内部，采用 Java **自带**序列化方式，实现对 Java POJO 对象的序列化和反序列化，所以官方目前不是很推荐。主要缺点如下：\n\n- 无法跨语言\n- 序列化后的字节数组太大\n- 序列化性能太低\n\n因此一般情况下，我们建议采用 [Jackson2JsonMessageConverter](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/support/converter/Jackson2JsonMessageConverter.java) ，使用 **JSON** 实现对 Java POJO 对象的序列化和反序列化。\n\n下面，我们来搭建一个 Jackson2JsonMessageConverter 的使用示例。考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-json](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json) 项目。\n\n## 16.1 引入依赖\n\n在 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/pom.xml) 文件中，引入相关依赖。\n\n\n\n")])])]),e._v('<?xml version="1.0" encoding="UTF-8"?>\n'),r("p",[r("project",{attrs:{xmlns:"http://maven.apache.org/POM/4.0.0","xmlns:xsi":"http://www.w3.org/2001/XMLSchema-instance","xsi:schemaLocation":"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"}},[r("parent",[r("groupId",[e._v("org.springframework.boot")]),e._v(" "),r("artifactId",[e._v("spring-boot-starter-parent")]),e._v(" "),r("version",[e._v("2.2.1.RELEASE")]),e._v(" "),r("relativePath")],1),e._v(" "),r("modelVersion",[e._v("4.0.0")])],1)],1),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("<artifactId>lab-04-rabbitmq-demo-json</artifactId>\n\n<dependencies>\n    \x3c!-- 实现对 RabbitMQ 的自动化配置 --\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-amqp</artifactId>\n    </dependency>\n\n    \x3c!-- Jackson 依赖  --\x3e\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.10.1</version>\n    </dependency>\n\n    \x3c!-- 方便等会写单元测试 --\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n")])])]),e._v("\n```\n"),r("ul",[r("li",[e._v("相比"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v("来说，额外引入 "),r("code",[e._v("jackson-databind")]),e._v(" 依赖。")])]),e._v(" "),r("h2",{attrs:{id:"_16-2-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-2-应用配置文件"}},[e._v("#")]),e._v(" 16.2 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/resources/https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_16-3-demo15message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-3-demo15message"}},[e._v("#")]),e._v(" 16.3 Demo15Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo15Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo15Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_16-4-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-4-rabbitconfig"}},[e._v("#")]),e._v(" 16.4 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，额外添加创建 Jackson2JsonMessageConverter Bean 。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// RabbitConfig.java\n\n@Configuration\npublic class RabbitConfig {\n\n    /**\n     * Direct Exchange 示例的配置类\n     */\n    public static class DirectExchangeDemoConfiguration {\n\n        // 创建 Queue\n        @Bean\n        public Queue demo15Queue() {\n            return new Queue(Demo15Message.QUEUE, // Queue 名字\n                    true, // durable: 是否持久化\n                    false, // exclusive: 是否排它\n                    false); // autoDelete: 是否自动删除\n        }\n\n        // 创建 Direct Exchange\n        @Bean\n        public DirectExchange demo15Exchange() {\n            return new DirectExchange(Demo15Message.EXCHANGE,\n                    true,  // durable: 是否持久化\n                    false);  // exclusive: 是否排它\n        }\n\n        // 创建 Binding\n        // Exchange：Demo15Message.EXCHANGE\n        // Routing key：Demo15Message.ROUTING_KEY\n        // Queue：Demo15Message.QUEUE\n        @Bean\n        public Binding demo15Binding() {\n            return BindingBuilder.bind(demo15Queue()).to(demo15Exchange()).with(Demo15Message.ROUTING_KEY);\n        }\n\n    }\n\n    @Bean\n    public MessageConverter messageConverter() {\n        return new Jackson2JsonMessageConverter();\n    }\n\n}\n")])])]),r("ul",[r("li",[e._v("在 "),r("code",[e._v("#messageConverter()")]),e._v(" 方法，创建 Jackson2JsonMessageConverter Bean 对象。后续，"),r("a",{attrs:{href:"https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitAutoConfiguration.RabbitTemplateConfiguration"),r("OutboundLink")],1),e._v(" 在创建 RabbitTemplate Bean 时，会自动注入它。")])]),e._v(" "),r("h2",{attrs:{id:"_16-5-demo15producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-5-demo15producer"}},[e._v("#")]),e._v(" 16.5 Demo15Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo15Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo15Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、RoutingKey 名字不同。")]),e._v(" "),r("p",[e._v("对于胖友来说，可能最关心的是，消息 Message 是怎么序列化的。")]),e._v(" "),r("ul",[r("li",[e._v("在序列化时，我们使用了 Jackson2JsonMessageConverter 序列化 Message 消息对象，它会在 RabbitMQ 消息 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/MessageProperties.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("MessageProperties"),r("OutboundLink")],1),e._v(" 的 "),r("code",[e._v("__TypeId__")]),e._v(" 上，值为 Message 消息对应的"),r("strong",[e._v("类全名")]),e._v("。")]),e._v(" "),r("li",[e._v("在反序列化时，我们使用了 Jackson2JsonMessageConverter 序列化出 Message 消息对象，它会根据 RabbitMQ 消息 "),r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/MessageProperties.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("MessageProperties"),r("OutboundLink")],1),e._v(" 的 "),r("code",[e._v("__TypeId__")]),e._v(" 的值，反序列化消息内容成该 Message 对象。")])]),e._v(" "),r("h2",{attrs:{id:"_16-6-demo15consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-6-demo15consumer"}},[e._v("#")]),e._v(" 16.6 Demo15Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo15Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo15Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo15Consumer.java\n\n@Component\n@RabbitListener(queues = Demo15Message.QUEUE)\npublic class Demo15Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler(isDefault = true)\n    public void onMessage(Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(),\n                new String(message.getBody()));\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("因为我们希望通过查看具体消息内容，判断是不是真的使用 JSON 格式，所以采用 AMQP Message 接收消息。")])]),e._v(" "),r("h2",{attrs:{id:"_16-7-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_16-7-简单测试"}},[e._v("#")]),e._v(" 16.7 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo15ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo15ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写单元测试方法，调用 Demo15Producer 发送消息的方法。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo15ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo15ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo15Producer producer;\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id);\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("p",[e._v("执行 "),r("code",[e._v("#testSyncSend()")]),e._v(" 单元测试，输出日志如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Producer 同步发送 1 条消息成功\n2019-12-13 20:38:37.311  INFO 4285 --- [           main] c.i.s.l.r.producer.Demo15ProducerTest    : [testSyncSend][发送编号：[1576240717] 发送成功]\n\n// Demo15Consumer 消费 1 条消息成功\n// 从消息内容中，我们可以看到 JSON 格式，说明配置生效，嘿嘿。\n2019-12-13 20:38:37.335  INFO 4285 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo15Consumer        : [onMessage][线程编号:17 消息内容：{"id":1576240717}]\n')])])]),r("ul",[r("li",[e._v("符合预期~")])]),e._v(" "),r("h1",{attrs:{id:"_17-消费异常处理器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-消费异常处理器"}},[e._v("#")]),e._v(" 17. 消费异常处理器")]),e._v(" "),r("blockquote",[r("p",[e._v("示例代码对应仓库："),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-error-handler"),r("OutboundLink")],1),e._v(" 。")])]),e._v(" "),r("p",[e._v("在"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「7. 消费重试」"),r("OutboundLink")],1),e._v("中，我们一起看了下，在 Consumer 消费异常时，Spring-AMQP 提供的"),r("strong",[e._v("消费重试")]),e._v("机制。除此之外，在 Spring-AMQP 中可以自定义消费异常时的处理器。目前有两个接口，可以实现对 Consumer 消费异常的处理：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/api/RabbitListenerErrorHandler.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("org.springframework.amqp.rabbit.listener.api.RabbitListenerErrorHandler")]),r("OutboundLink")],1),e._v(" 接口")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ErrorHandler.java",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("org.springframework.util.ErrorHandler")]),r("OutboundLink")],1),e._v(" 接口")])]),e._v(" "),r("p",[e._v("下面，我们来搭建一个 RabbitListenerErrorHandler 和 ErrorHandler 的使用示例。考虑到不污染上述的示例，我们新建一个 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler",target:"_blank",rel:"noopener noreferrer"}},[e._v("lab-04-rabbitmq-demo-error-handler"),r("OutboundLink")],1),e._v(" 项目。")]),e._v(" "),r("h2",{attrs:{id:"_17-1-rabbitlistenererrorhandlerimpl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-1-rabbitlistenererrorhandlerimpl"}},[e._v("#")]),e._v(" 17.1 RabbitListenerErrorHandlerImpl")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.core")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitListenerErrorHandlerImpl.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitListenerErrorHandlerImpl"),r("OutboundLink")],1),e._v(" 类，实现 RabbitListenerErrorHandler 接口。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// RabbitListenerErrorHandler.java\n\n@Component("rabbitListenerErrorHandler")\npublic class RabbitListenerErrorHandlerImpl implements RabbitListenerErrorHandler {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Override\n    public Object handleError(Message amqpMessage, org.springframework.messaging.Message<?> message,\n                              ListenerExecutionFailedException exception) {\n        // 打印异常日志\n        logger.error("[handleError][amqpMessage:[{}] message:[{}]]", amqpMessage, message, exception);\n\n        // 直接继续抛出异常\n        throw exception;\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在类上，添加 "),r("code",[e._v("@Component")]),e._v(" 注解，并设置其 Bean 名为 "),r("code",[e._v('"rabbitListenerErrorHandler"')]),e._v(" 。稍后，我们会使用到该 Bean 名字。")]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v("#handleError(...)")]),e._v(" 方法中，我们先打印异常日志，并继续抛出 ListenerExecutionFailedException 异常。"),r("strong",[e._v("要注意")]),e._v("，如果此时我们不继续抛出异常，而是 "),r("code",[e._v("return")]),e._v(" 结果，意味着 Consumer 消息成功。如果我们结合"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「7. 消费重试」"),r("OutboundLink")],1),e._v("一起使用的时候，一定要继续抛出该异常，否则消费重试机制将失效。")])]),e._v(" "),r("h2",{attrs:{id:"_17-2-rabbitloggingerrorhandler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-2-rabbitloggingerrorhandler"}},[e._v("#")]),e._v(" 17.2 RabbitLoggingErrorHandler")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.core")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitLoggingErrorHandler.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitLoggingErrorHandler"),r("OutboundLink")],1),e._v(" 类，实现 ErrorHandler 接口。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// RabbitLoggingErrorHandler.java\n\n@Component\npublic class RabbitLoggingErrorHandler implements ErrorHandler {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    public RabbitLoggingErrorHandler(SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) {\n        rabbitListenerContainerFactory.setErrorHandler(this);\n    }\n\n    @Override\n    public void handleError(Throwable t) {\n        logger.error("[handleError][发生异常]]", t);\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在构造方法中，把自己设置到 SimpleRabbitListenerContainerFactory 中，作为其 ErrorHandler 异常处理器。")]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v("#handleError(...)")]),e._v(" 方法中，打印错误日志。当然，具体怎么处理，胖友可以根据自己的需要哈。")])]),e._v(" "),r("p",[e._v("在执行"),r("strong",[e._v("顺序")]),e._v("上，RabbitListenerErrorHandler "),r("strong",[e._v("先")]),e._v("于 ErrorHandler 执行。不过这个需要建立在一个前提上，RabbitListenerErrorHandler 需要继续抛出异常。")]),e._v(" "),r("p",[e._v("另外，RabbitListenerErrorHandler 需要每个 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解上，需要每个手动设置下 "),r("code",[e._v("errorHandler")]),e._v(" 属性。而 ErrorHandler 是相对全局的，所有 SimpleRabbitListenerContainerFactory 创建的 SimpleMessageListenerContainer 都会生效。")]),e._v(" "),r("p",[e._v("具体选择 ErrorHandler 还是 RabbitLoggingErrorHandler ，艿艿暂时没有答案。不过个人感觉，如果不需要对 Consumer 消费的结果（包括成功和异常）做进一步处理，还是考虑 ErrorHandler 即可。在 ErrorHandler 中，我们可以通过判断 Throwable 异常是不是 ListenerExecutionFailedException 异常，从而拿到 Message 相关的信息。")]),e._v(" "),r("h2",{attrs:{id:"_17-3-引入依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-3-引入依赖"}},[e._v("#")]),e._v(" 17.3 引入依赖")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.1 引入依赖」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/pom.xml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("pom.xml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_17-4-应用配置文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-4-应用配置文件"}},[e._v("#")]),e._v(" 17.4 应用配置文件")]),e._v(" "),r("p",[e._v("和 "),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.2 应用配置文件」"),r("OutboundLink")],1),e._v(" 一致，见 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/resources/application.yaml",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("application.yaml")]),r("OutboundLink")],1),e._v(" 文件。")]),e._v(" "),r("h2",{attrs:{id:"_17-5-demo16message"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-5-demo16message"}},[e._v("#")]),e._v(" 17.5 Demo16Message")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.message")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo16Message.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo16Message"),r("OutboundLink")],1),e._v(" 消息类，提供给当前示例使用。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.4 Demo01Message」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_17-6-rabbitconfig"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-6-rabbitconfig"}},[e._v("#")]),e._v(" 17.6 RabbitConfig")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.config")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("RabbitConfig"),r("OutboundLink")],1),e._v(" 配置类，配置相关的 Exchange、Queue、Binding 。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.5 RabbitConfig」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、Queue、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_17-7-demo16producer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-7-demo16producer"}},[e._v("#")]),e._v(" 17.7 Demo16Producer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.producer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo16Producer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo16Producer"),r("OutboundLink")],1),e._v(" 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。")]),e._v(" "),r("p",[e._v("和"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「3.1.6 Demo01Producer」"),r("OutboundLink")],1),e._v("一致，只是 Exchange、RoutingKey 名字不同。")]),e._v(" "),r("h2",{attrs:{id:"_17-8-demo16consumer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-8-demo16consumer"}},[e._v("#")]),e._v(" 17.8 Demo16Consumer")]),e._v(" "),r("p",[e._v("在 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("cn.iocoder.springboot.lab04.rabbitmqdemo.consumer")]),r("OutboundLink")],1),e._v(" 包下，创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo16Consumer.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo16Consumer"),r("OutboundLink")],1),e._v(" 类，消费消息。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo16Consumer.java\n\n@Component\n@RabbitListener(queues = Demo16Message.QUEUE,\n    errorHandler = "rabbitListenerErrorHandler")\npublic class Demo16Consumer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RabbitHandler\n    public void onMessage(Demo16Message message) {\n        logger.info("[onMessage][线程编号:{} 消息内容：{}]", Thread.currentThread().getId(), message);\n        // 模拟消费异常\n        throw new RuntimeException("你猜");\n    }\n\n}\n')])])]),r("ul",[r("li",[e._v("在 "),r("code",[e._v("@RabbitListener")]),e._v(" 注解上，我们通过设置 "),r("code",[e._v("errorHandler")]),e._v(" 属性为"),r("a",{attrs:{href:"https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#",target:"_blank",rel:"noopener noreferrer"}},[e._v("「17.1 RabbitListenerErrorHandlerImpl」"),r("OutboundLink")],1),e._v("的名字。")]),e._v(" "),r("li",[e._v("在 "),r("code",[e._v("#onMessage(...)")]),e._v(" 方法中，我们通过抛出 RuntimeException 异常，模拟消费异常。")])]),e._v(" "),r("h2",{attrs:{id:"_17-9-简单测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-9-简单测试"}},[e._v("#")]),e._v(" 17.9 简单测试")]),e._v(" "),r("p",[e._v("创建 "),r("a",{attrs:{href:"https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo16ProducerTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Demo16ProducerTest"),r("OutboundLink")],1),e._v(" 测试类，编写单元测试方法，调用 Demo16Producer 发送消息的方法。代码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// Demo16ProducerTest.java\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class Demo16ProducerTest {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private Demo16Producer producer;\n\n    @Test\n    public void testSyncSend() throws InterruptedException {\n        int id = (int) (System.currentTimeMillis() / 1000);\n        producer.syncSend(id);\n        logger.info("[testSyncSend][发送编号：[{}] 发送成功]", id);\n\n        // 阻塞等待，保证消费\n        new CountDownLatch(1).await();\n    }\n\n}\n')])])]),r("p",[e._v("执行 "),r("code",[e._v("#testSyncSend()")]),e._v(" 单元测试，输出日志如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Producer 同步发送 1 条消息成功\n2019-12-13 22:35:54.459  INFO 22515 --- [           main] c.i.s.l.r.producer.Demo16ProducerTest    : [testSyncSend][发送编号：[1576247754] 发送成功]\n\n// Demo08Consumer 消费 1 条消息成功\n2019-12-13 22:35:57.254  INFO 22515 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo16Consumer        : [onMessage][线程编号:18 消息内容：Demo16Message{id=1576247754}]\n\n// RabbitListenerErrorHandler 先处理异常\n2019-12-13 22:35:57.263 ERROR 22515 --- [ntContainer#0-1] i.s.l.r.c.RabbitListenerErrorHandlerImpl : [handleError][amqpMessage:[(Body:'[B@401abc48(byte[187])' MessageProperties [headers={}, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=EXCHANGE_DEMO_16, receivedRoutingKey=ROUTING_KEY_16, deliveryTag=1, consumerTag=amq.ctag-tUY94gzefw73JvHtgqwMnQ, consumerQueue=QUEUE_DEMO_16])] message:[GenericMessage [payload=Demo16Message{id=1576247754}, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=ROUTING_KEY_16, amqp_receivedExchange=EXCHANGE_DEMO_16, amqp_deliveryTag=1, amqp_consumerQueue=QUEUE_DEMO_16, amqp_channel=Cached Rabbit Channel: AMQChannel(amqp://guest@127.0.0.1:5672/,1), conn: Proxy@10bd9df0 Shared Rabbit Connection: SimpleConnection@68217d41 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 56809], amqp_redelivered=false, id=34327625-9ef4-0433-3514-a6633bfad100, amqp_consumerTag=amq.ctag-tUY94gzefw73JvHtgqwMnQ, amqp_lastInBatch=false, contentType=application/x-java-serialized-object, timestamp=1576247757255}]]]\n\norg.springframework.amqp.rabbit.support.ListenerExecutionFailedException: Listener method 'public void cn.iocoder.springboot.lab04.rabbitmqdemo.consumer.Demo16Consumer.onMessage(cn.iocoder.springboot.lab04.rabbitmqdemo.message.Demo16Message)' threw exception\n// ... 省略异常堆栈\n\n// ErrorHandler 再处理器异常\n2019-12-13 22:36:00.175 ERROR 22515 --- [ntContainer#0-1] c.i.s.l.r.c.RabbitLoggingErrorHandler    : [handleError][发生异常]]\n\norg.springframework.amqp.rabbit.support.ListenerExecutionFailedException: Listener method 'public void cn.iocoder.springboot.lab04.rabbitmqdemo.consumer.Demo16Consumer.onMessage(cn.iocoder.springboot.lab04.rabbitmqdemo.message.Demo16Message)' threw exception\n// ... 省略异常堆栈\n")])])]),r("ul",[r("li",[e._v("符合预期~")])])])}),[],!1,null,null,null);r.default=t.exports}}]);