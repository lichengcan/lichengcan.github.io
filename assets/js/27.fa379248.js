(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{447:function(_,v,e){"use strict";e.r(v);var t=e(2),r=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"_1-aqs-abstractqueuedsynchronizer-队列同步器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-aqs-abstractqueuedsynchronizer-队列同步器"}},[_._v("#")]),_._v(" 1 AQS AbstractQueuedSynchronizer 队列同步器")]),_._v(" "),v("p",[v("strong",[_._v("AQS")]),_._v("（AbstractQueuedSynchronizer）是Java中的一个重要的同步框架，它提供了一种基础框架来实现各种类型的同步器，如锁、信号量、倒计时门闩等。AQS是Java并发包（java.util.concurrent）的核心组件之一，它用于支持构建自定义的同步工具和数据结构。")]),_._v(" "),v("p",[_._v("AQS的核心思想是使用一个FIFO（先进先出）的等待队列来管理线程的竞争和等待。")]),_._v(" "),v("p",[_._v("AQS内部维护了一个状态变量，线程在尝试获取锁或执行某个操作时，首先会尝试修改这个状态，如果修改成功（比如从0修改为1），则表示线程获得了锁或操作权限；如果修改失败，则线程会被加入到等待队列中，等待状态变为满足某个条件时再次尝试获取锁或操作权限。")]),_._v(" "),v("p",[_._v("AQS的两个主要子类是"),v("code",[_._v("ReentrantLock")]),_._v("（可重入锁）和"),v("code",[_._v("CountDownLatch")]),_._v("（倒计时门闩）。"),v("code",[_._v("ReentrantLock")]),_._v("是一个可重入的互斥锁，而"),v("code",[_._v("CountDownLatch")]),_._v("是一个同步工具，它允许一个或多个线程等待其他线程完成一组操作。")]),_._v(" "),v("p",[_._v("自定义同步器时，通常需要继承"),v("code",[_._v("AbstractQueuedSynchronizer")]),_._v("并实现以下两个主要方法：")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("tryAcquire")]),_._v("：尝试获取锁或执行某个操作的逻辑。如果返回true，表示操作成功；如果返回false，表示操作失败，线程会被加入到等待队列中。")]),_._v(" "),v("li",[v("code",[_._v("tryRelease")]),_._v("：尝试释放锁或完成某个操作的逻辑。这个方法通常用于释放资源并唤醒等待队列中的线程。")])]),_._v(" "),v("p",[_._v("AQS的设计使得实现各种自定义的同步器变得相对容易，开发者可以根据具体的需求来编写自己的"),v("code",[_._v("tryAcquire")]),_._v("和"),v("code",[_._v("tryRelease")]),_._v("方法，从而构建出高性能的同步工具。")]),_._v(" "),v("p",[_._v("总之，AQS（AbstractQueuedSynchronizer）是Java并发包中的一个核心组件，用于支持构建自定义的同步工具和数据结构，它通过等待队列和状态变量的方式实现了多线程的协作和同步。")]),_._v(" "),v("h3",{attrs:{id:"_2-优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-优势"}},[_._v("#")]),_._v(" 2 优势")]),_._v(" "),v("blockquote",[v("p",[_._v("AQS 解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO 同步队列。基于 AQS 来构建同步器可以带来"),v("strong",[_._v("很多好处")]),_._v("。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。")]),_._v(" "),v("p",[_._v("在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中，所有基于 AQS 构建的同步器均可以获得这个优势。")])]),_._v(" "),v("h3",{attrs:{id:"_3-同步状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-同步状态"}},[_._v("#")]),_._v(" 3 同步状态")]),_._v(" "),v("p",[_._v("AQS 的主要使用方式是"),v("strong",[_._v("继承")]),_._v("，子类通过继承同步器，并实现它的"),v("strong",[_._v("抽象方法")]),_._v("来管理同步状态。")]),_._v(" "),v("p",[_._v("AQS 使用一个 "),v("code",[_._v("int")]),_._v(" 类型的成员变量 "),v("code",[_._v("state")]),_._v(" 来"),v("strong",[_._v("表示同步状态")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("当 "),v("code",[_._v("state > 0")]),_._v(" 时，表示已经获取了锁。")]),_._v(" "),v("li",[_._v("当 "),v("code",[_._v("state = 0")]),_._v(" 时，表示释放了锁。")])]),_._v(" "),v("p",[_._v("它提供了三个方法，来对同步状态 "),v("code",[_._v("state")]),_._v(" 进行操作，并且 AQS 可以确保对 "),v("code",[_._v("state")]),_._v(" 的操作是"),v("strong",[_._v("安全")]),_._v("的：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("#getState()")])]),_._v(" "),v("li",[v("code",[_._v("#setState(int newState)")])]),_._v(" "),v("li",[v("code",[_._v("#compareAndSetState(int expect, int update)")])])]),_._v(" "),v("h3",{attrs:{id:"_4-同步队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-同步队列"}},[_._v("#")]),_._v(" 4 同步队列")]),_._v(" "),v("p",[_._v("AQS 通过内置的 FIFO 同步队列来完成资源获取线程的"),v("strong",[_._v("排队工作")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程")]),_._v(" "),v("li",[_._v("当同步状态"),v("strong",[_._v("释放")]),_._v("时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。")])]),_._v(" "),v("h3",{attrs:{id:"_5-主要内置方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-主要内置方法"}},[_._v("#")]),_._v(" 5. 主要内置方法")]),_._v(" "),v("p",[_._v("AQS 主要提供了如下"),v("strong",[_._v("方法")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("#getState()")]),_._v("：返回同步状态的当前值。")]),_._v(" "),v("li",[v("code",[_._v("#setState(int newState)")]),_._v("：设置当前同步状态。")]),_._v(" "),v("li",[v("code",[_._v("#compareAndSetState(int expect, int update)")]),_._v("：使用 CAS 设置当前状态，该方法能够保证状态设置的原子性。")]),_._v(" "),v("li",[_._v("【可重写】"),v("code",[_._v("#tryAcquire(int arg)")]),_._v("：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态。")]),_._v(" "),v("li",[_._v("【可重写】"),v("code",[_._v("#tryRelease(int arg)")]),_._v("：独占式释放同步状态。")]),_._v(" "),v("li",[_._v("【可重写】"),v("code",[_._v("#tryAcquireShared(int arg)")]),_._v("：共享式获取同步状态，返回值大于等于 0 ，则表示获取成功；否则，获取失败。")]),_._v(" "),v("li",[_._v("【可重写】"),v("code",[_._v("#tryReleaseShared(int arg)")]),_._v("：共享式释放同步状态。")]),_._v(" "),v("li",[_._v("【可重写】"),v("code",[_._v("#isHeldExclusively()")]),_._v("：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占。")]),_._v(" "),v("li",[v("code",[_._v("acquire(int arg)")]),_._v("：独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回；否则，将会进入同步队列等待。该方法将会调用"),v("strong",[_._v("可重写")]),_._v("的 "),v("code",[_._v("#tryAcquire(int arg)")]),_._v(" 方法；")]),_._v(" "),v("li",[v("code",[_._v("#acquireInterruptibly(int arg)")]),_._v("：与 "),v("code",[_._v("#acquire(int arg)")]),_._v(" 相同，但是该方法响应中断。当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException 异常并返回。")]),_._v(" "),v("li",[v("code",[_._v("#tryAcquireNanos(int arg, long nanos)")]),_._v("：超时获取同步状态。如果当前线程在 nanos 时间内没有获取到同步状态，那么将会返回 false ，已经获取则返回 true 。")]),_._v(" "),v("li",[v("code",[_._v("#acquireShared(int arg)")]),_._v("：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；")]),_._v(" "),v("li",[v("code",[_._v("#acquireSharedInterruptibly(int arg)")]),_._v("：共享式获取同步状态，响应中断。")]),_._v(" "),v("li",[v("code",[_._v("#tryAcquireSharedNanos(int arg, long nanosTimeout)")]),_._v("：共享式获取同步状态，增加超时限制。")]),_._v(" "),v("li",[v("code",[_._v("#release(int arg)")]),_._v("：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。")]),_._v(" "),v("li",[v("code",[_._v("#releaseShared(int arg)")]),_._v("：共享式释放同步状态。")])]),_._v(" "),v("p",[_._v("从上面的方法看下来，基本上可以分成 "),v("strong",[_._v("3")]),_._v(" 类：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("独占式")]),_._v("获取与释放同步状态")]),_._v(" "),v("li",[v("strong",[_._v("共享式")]),_._v("获取与释放同步状态")]),_._v(" "),v("li",[_._v("查询"),v("strong",[_._v("同步队列")]),_._v("中的等待线程情况")])])])}),[],!1,null,null,null);v.default=r.exports}}]);