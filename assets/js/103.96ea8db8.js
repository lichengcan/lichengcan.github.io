(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{520:function(e,t,n){"use strict";n.r(t);var s=n(2),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"什么是分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是分布式锁"}},[e._v("#")]),e._v(" "),t("strong",[e._v("什么是分布式锁")])]),e._v(" "),t("p",[e._v("要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。")]),e._v(" "),t("p",[t("strong",[e._v("1.线程锁")])]),e._v(" "),t("p",[e._v("主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如Synchronized、Lock等。")]),e._v(" "),t("p",[t("strong",[e._v("2.进程锁")])]),e._v(" "),t("p",[e._v("为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。")]),e._v(" "),t("p",[t("strong",[e._v("3.分布式锁")])]),e._v(" "),t("p",[e._v("当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。")]),e._v(" "),t("h2",{attrs:{id:"分布式锁的由来"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的由来"}},[e._v("#")]),e._v(" "),t("strong",[e._v("分布式锁的由来")])]),e._v(" "),t("p",[e._v("在传统单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。")]),e._v(" "),t("p",[e._v("但是在分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁的由来。")]),e._v(" "),t("p",[e._v("当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问。")]),e._v(" "),t("h2",{attrs:{id:"分布式锁的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的特点"}},[e._v("#")]),e._v(" "),t("strong",[e._v("分布式锁的特点")])]),e._v(" "),t("p",[e._v("首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：")]),e._v(" "),t("p",[e._v("1、"),t("strong",[e._v("互斥性")]),e._v("：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。")]),e._v(" "),t("p",[e._v("2、"),t("strong",[e._v("安全性")]),e._v("：锁只能被持有该锁的客户端删除，不能由其它客户端删除。")]),e._v(" "),t("p",[e._v("3、"),t("strong",[e._v("死锁")]),e._v("：获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。")]),e._v(" "),t("p",[e._v("4、"),t("strong",[e._v("容错")]),e._v("：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁。")]),e._v(" "),t("h2",{attrs:{id:"分布式锁的具体实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的具体实现"}},[e._v("#")]),e._v(" "),t("strong",[e._v("分布式锁的具体实现")])]),e._v(" "),t("p",[t("strong",[e._v("分布式锁一般有三种实现方式：")])]),e._v(" "),t("p",[e._v("\\1. 数据库乐观锁；")]),e._v(" "),t("p",[e._v("\\2. 基于ZooKeeper的分布式锁;")]),e._v(" "),t("p",[e._v("3.基于Redis的分布式锁；")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class DistributedLock {\n\n    private JedisPool jedisPool;\n\n    public DistributedLock(JedisPool jedisPool) {\n        this.jedisPool = jedisPool;\n    }\n    //获取锁\n\n    public boolean acquireLock(String lockKey, String clientId, int expireTime) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            String result = jedis.set(lockKey, clientId, "NX", "EX", expireTime);\n            return "OK".equals(result);\n        } catch (JedisException e) {\n            // Handle the exception\n            return false;\n        }\n    }\n\n//释放锁\n    public boolean releaseLock(String lockKey, String clientId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            String currentClient = jedis.get(lockKey);\n            if (clientId.equals(currentClient)) {\n                return jedis.del(lockKey) == 1;\n            } else {\n                return false;\n            }\n        } catch (JedisException e) {\n            // Handle the exception\n            return false;\n        }\n    }\n}\n\n')])])]),t("p",[t("strong",[e._v("这个set()方法一共有五个形参：")])]),e._v(" "),t("p",[e._v("第一个为key，我们使用key来当锁，因为key是唯一的。")]),e._v(" "),t("p",[e._v("第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。")]),e._v(" "),t("p",[e._v("第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；")]),e._v(" "),t("p",[e._v("第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。")]),e._v(" "),t("p",[e._v("第五个为time，与第四个参数相呼应，代表key的过期时间。")])])}),[],!1,null,null,null);t.default=r.exports}}]);