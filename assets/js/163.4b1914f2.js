(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{579:function(_,v,s){"use strict";s.r(v);var a=s(2),t=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"_1-自我介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-自我介绍"}},[_._v("#")]),_._v(" 1.自我介绍")]),_._v(" "),v("p",[_._v("面试官您好，我叫李承灿，今年24岁，学历本科，从事Java后端开发已有两年，最近在独立负责一个数据可视化项目的后端，其中有一个主要的模块叫 实时位置信息 模块。。。。。。。。")]),_._v(" "),v("h5",{attrs:{id:"_1-介绍模块是干啥的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-介绍模块是干啥的"}},[_._v("#")]),_._v(" 1.介绍模块是干啥的")]),_._v(" "),v("h5",{attrs:{id:"_2-数据来源-对接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据来源-对接"}},[_._v("#")]),_._v(" 2.数据来源，对接")]),_._v(" "),v("h5",{attrs:{id:"_3-设计数据库存储数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-设计数据库存储数据"}},[_._v("#")]),_._v(" 3.设计数据库存储数据")]),_._v(" "),v("h3",{attrs:{id:"_2-讲讲你的这个模块的数据库表设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-讲讲你的这个模块的数据库表设计"}},[_._v("#")]),_._v(" 2.讲讲你的这个模块的数据库表设计")]),_._v(" "),v("h3",{attrs:{id:"_3-独立开发项目遇到的难题-如何解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-独立开发项目遇到的难题-如何解决"}},[_._v("#")]),_._v(" 3.独立开发项目遇到的难题，如何解决")]),_._v(" "),v("p",[_._v("需求。架构。代码实现")]),_._v(" "),v("h3",{attrs:{id:"_4-spring讲讲-核心模块和你对他的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-spring讲讲-核心模块和你对他的理解"}},[_._v("#")]),_._v(" 4.spring讲讲，核心模块和你对他的理解")]),_._v(" "),v("p",[_._v("1.IOC 控制反转,")]),_._v(" "),v("p",[_._v("2.APO切面，使用场景（日志，防抖具体使用到的地方）,")]),_._v(" "),v("p",[_._v("3.DI依赖注入方法 构造器，注解，set")]),_._v(" "),v("h3",{attrs:{id:"_5-springmvc的流程-优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-springmvc的流程-优缺点"}},[_._v("#")]),_._v(" 5.springmvc的流程？优缺点")]),_._v(" "),v("p",[_._v("dispatchservlet->controller->model and view 渲染解析")]),_._v(" "),v("h3",{attrs:{id:"_6-你对hashmap的理解-是如何使用的-怎么更高效的使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-你对hashmap的理解-是如何使用的-怎么更高效的使用"}},[_._v("#")]),_._v(" 6.你对hashmap的理解，是如何使用的？怎么更高效的使用？")]),_._v(" "),v("p",[_._v("1.键值对的数据结构，")]),_._v(" "),v("p",[_._v("2。初始化大小，减少扩容，确定类型，减少类型转换。")]),_._v(" "),v("p",[_._v("3.hash冲突 hash算法有关，")]),_._v(" "),v("p",[_._v("4。遍历时使用迭代器或增强for ，")]),_._v(" "),v("p",[_._v("5.尽量减少add del，这个会容易resize，")]),_._v(" "),v("p",[_._v("6.还需要考虑线程安全的问题。curranthashmap")]),_._v(" "),v("p",[v("strong",[_._v("HashMap 的理解：")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("键值对存储")]),_._v("：HashMap 存储数据的方式是通过键值对，其中每个键都是唯一的。这意味着您可以使用键来检索相应的值。")]),_._v(" "),v("li",[v("strong",[_._v("哈希表")]),_._v("：HashMap 的内部实现是一个哈希表，它允许在 O(1) 的平均时间复杂度内查找值。这是 HashMap 的一个关键特性，使其非常高效。")]),_._v(" "),v("li",[v("strong",[_._v("不保证顺序")]),_._v("：HashMap 不保证元素的顺序。元素存储的顺序可能与插入顺序不同。如果需要按顺序存储元素，可以考虑使用 LinkedHashMap。")]),_._v(" "),v("li",[v("strong",[_._v("线程不安全")]),_._v("：HashMap 是非线程安全的，如果在多线程环境下使用，需要进行额外的同步处理，或者可以考虑使用线程安全的 ConcurrentHashMap。")])]),_._v(" "),v("p",[v("strong",[_._v("如何更高效使用 HashMap：")])]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("选择合适的初始容量和负载因子")]),_._v("：\n"),v("ul",[v("li",[_._v("在创建 HashMap 时，可以指定初始容量和负载因子。合理的选择可以减少扩容次数，提高性能。")])])]),_._v(" "),v("li",[v("strong",[_._v("选择正确的哈希函数")]),_._v("：\n"),v("ul",[v("li",[_._v("如果可能，自定义对象的哈希函数，以确保散列均匀。默认情况下，Java 会使用对象的 "),v("code",[_._v("hashCode()")]),_._v(" 方法来计算哈希值。")])])]),_._v(" "),v("li",[v("strong",[_._v("注意键的不可变性")]),_._v("：\n"),v("ul",[v("li",[_._v("使用不可变对象作为键，以确保哈希值不会发生变化。如果键的哈希值发生变化，可能导致无法正确检索值。")])])]),_._v(" "),v("li",[v("strong",[_._v("避免哈希冲突")]),_._v("：\n"),v("ul",[v("li",[_._v("哈希冲突是指不同的键具有相同的哈希值。当发生冲突时，HashMap 使用链表或红黑树（JDK 8+）来解决。为了提高性能，尽量避免哈希冲突。可以通过选择好的哈希函数和适当的容量来减少冲突的发生。")])])]),_._v(" "),v("li",[v("strong",[_._v("遍历 HashMap")]),_._v("：\n"),v("ul",[v("li",[_._v("遍历 HashMap 时，使用迭代器或增强 for 循环，而不是通过键集合或值集合来遍历，因为直接遍历键值对更高效。")])])]),_._v(" "),v("li",[v("strong",[_._v("尽量减少 resize 操作")]),_._v("：\n"),v("ul",[v("li",[_._v("HashMap 在扩容时需要重新计算哈希值和重新分配存储空间，这是一个昂贵的操作。因此，尽量避免频繁插入和删除操作，以减少 resize 次数。")])])]),_._v(" "),v("li",[v("strong",[_._v("了解时间复杂度")]),_._v("：\n"),v("ul",[v("li",[_._v("理解 HashMap 各种操作的时间复杂度，例如，查找操作是 O(1)，但在发生哈希冲突时可能是 O(n)。这有助于优化数据结构和算法的设计。")])])])]),_._v(" "),v("h3",{attrs:{id:"_7-redis做缓存-如果遇到缓存击穿、穿透怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-redis做缓存-如果遇到缓存击穿、穿透怎么解决"}},[_._v("#")]),_._v(" 7.redis做缓存，如果遇到缓存击穿、穿透怎么解决？")]),_._v(" "),v("p",[_._v("1.击穿：某个时间点缓存失效，又来了大量的请求。")]),_._v(" "),v("p",[_._v("互斥锁、限制并发访问请求数量、提高数据库查询速度，redis哨兵模式，主从数据库")]),_._v(" "),v("p",[_._v("2.穿透：查询的key在缓存中都没有")]),_._v(" "),v("p",[_._v("1.布隆过滤器：如果发现缓存中没有这个key，去数据库查询后再把它缓存进去")]),_._v(" "),v("p",[_._v("2.二级缓存，一级缓存key 二级缓存value")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("使用互斥锁")]),_._v("：在缓存失效的情况下，可以使用互斥锁来确保只有一个请求去查询数据库并更新缓存，其他请求会等待互斥锁的释放。这可以减少同时查询数据库的并发请求数量。")]),_._v(" "),v("li",[v("strong",[_._v("使用分布式缓存")]),_._v("：使用分布式缓存系统，如Redis，它们通常具有内置的原子性操作，可以确保只有一个请求成功地从数据库中加载数据并更新缓存。其他请求会等待缓存的更新，而不会重复查询数据库。")]),_._v(" "),v("li",[v("strong",[_._v("缓存预热")]),_._v("：在应用程序启动或低峰时段，可以执行缓存预热操作，将热门数据加载到缓存中，以减少在高峰时段大量请求同时发生缓存失效的情况。")]),_._v(" "),v("li",[v("strong",[_._v("限制并发查询")]),_._v("：可以设置并发查询的限制，当达到一定的并发查询数时，拒绝新的查询请求或返回一个默认值。这可以避免数据库被过多的查询请求压垮。")]),_._v(" "),v("li",[v("strong",[_._v("数据库优化")]),_._v("：确保数据库的性能和查询效率是高的，通过索引、查询优化和缓存数据库查询结果来减少数据库的负载。")])]),_._v(" "),v("h3",{attrs:{id:"_8-redis有没有遇到查错数据的情况"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-redis有没有遇到查错数据的情况"}},[_._v("#")]),_._v(" 8.redis有没有遇到查错数据的情况")]),_._v(" "),v("p",[_._v("1.缓存一致性")]),_._v(" "),v("p",[_._v("2.穿透（查询不存在的key")]),_._v(" "),v("p",[_._v("3.雪崩（击穿，缓存失效")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("缓存一致性问题")]),_._v("：Redis 是一种内存缓存系统，它将数据存储在内存中以提供快速访问。但由于内存有限，数据需要定期从磁盘加载到内存中，并且可能会因为内存不足或其他原因导致数据被淘汰。这可能导致从 Redis 中获取的数据不一定是最新的。")]),_._v(" "),v("p",[_._v("解决方案：可以使用适当的缓存策略，如设置合适的过期时间、使用LRU（最近最少使用）算法等，以确保缓存中的数据保持相对一致性。另外，Redis 也支持持久化机制，可以将数据定期写入磁盘，以便在重启后恢复数据。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("缓存穿透问题")]),_._v("：缓存穿透是指恶意或异常请求访问缓存中不存在的数据，导致大量请求直接访问后端数据源，从而增加数据库负载。")]),_._v(" "),v("p",[_._v("解决方案：可以使用布隆过滤器等机制来预先过滤无效的请求，以减少对数据库的查询。此外，可以在缓存中存储“空”结果，即表示某个键对应的数据确实不存在，从而避免重复查询数据库。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("缓存雪崩问题")]),_._v("：缓存雪崩是指缓存中的大量数据在同一时间失效，导致大量请求直接访问数据库。这通常发生在某个时刻，例如缓存的过期时间同步设置。")]),_._v(" "),v("p",[_._v("解决方案：可以使用随机的过期时间或分布式锁来避免缓存数据同时失效。另外，定期监控缓存状态并及时重建缓存也可以减轻雪崩问题。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("缓存数据不一致问题")]),_._v("：在分布式系统中，多个节点上的缓存数据可能不一致。例如，在写操作发生时，可能需要更新多个节点上的缓存，但某些节点可能更新成功，而其他节点失败。")]),_._v(" "),v("p",[_._v("解决方案：使用分布式缓存解决方案，如Redis集群或Redis Sentinel，可以在多个节点之间复制和同步数据，以确保一致性。此外，可以使用事务来确保多个操作的原子性，或者使用分布式锁来协调多个节点的数据更新操作。")])])]),_._v(" "),v("h3",{attrs:{id:"_9-实时点位qps有多高"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-实时点位qps有多高"}},[_._v("#")]),_._v(" 9.实时点位qps有多高？")]),_._v(" "),v("p",[_._v("不超过100，但是一直会处于这种状态，实时的数据")]),_._v(" "),v("h3",{attrs:{id:"_10-如果在某一个高峰期qps特别高-你的服务是否支撑的住-为什么-或是怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-如果在某一个高峰期qps特别高-你的服务是否支撑的住-为什么-或是怎么解决"}},[_._v("#")]),_._v(" 10.如果在某一个高峰期qps特别高，你的服务是否支撑的住？为什么？或是怎么解决")]),_._v(" "),v("p",[_._v("1.水平扩展，把压力分散到不同服务器上。")]),_._v(" "),v("p",[_._v("2.代码逻辑优化，优化查询速度。")]),_._v(" "),v("p",[_._v("3.数据库查询优化。")]),_._v(" "),v("p",[_._v("4.缓存。")]),_._v(" "),v("p",[_._v("5.异步。根据不同的需求具体的场景来优化")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("优化代码和算法")]),_._v("：对系统进行代码和算法的优化，以提高处理效率。这可能包括减少冗余计算、使用更高效的数据结构、缓存结果等。")]),_._v(" "),v("li",[v("strong",[_._v("水平扩展")]),_._v("：将负载分散到多个服务器上，以增加系统的容量。这可以通过负载均衡器实现，它可以将请求分发到多个后端服务器上。")]),_._v(" "),v("li",[v("strong",[_._v("使用缓存")]),_._v("：缓存可以减轻数据库或其他后端服务的压力。常见的缓存技术包括内存缓存、CDN（内容分发网络）和分布式缓存。")]),_._v(" "),v("li",[v("strong",[_._v("数据库优化")]),_._v("：如果应用程序涉及数据库访问，可以通过索引、查询优化和数据库分片等方法来优化数据库性能。")]),_._v(" "),v("li",[v("strong",[_._v("异步处理")]),_._v("：将一些处理任务异步化，以减少请求的响应时间。例如，将长时间运行的任务放入消息队列中，然后异步处理它们。")]),_._v(" "),v("li",[v("strong",[_._v("负载测试")]),_._v("：进行负载测试，模拟高负载情况，以确定系统的性能极限，并找出瓶颈。")]),_._v(" "),v("li",[v("strong",[_._v("自动化扩展")]),_._v("：设置自动扩展机制，以根据负载自动增加或减少服务器资源。云服务提供商通常提供这种功能。")]),_._v(" "),v("li",[v("strong",[_._v("监控和日志")]),_._v("：建立全面的监控系统，实时监视系统性能，并记录日志以进行故障排除。")]),_._v(" "),v("li",[v("strong",[_._v("灾难恢复计划")]),_._v("：制定灾难恢复计划，以应对可能的系统故障和服务中断。")]),_._v(" "),v("li",[v("strong",[_._v("CDN使用")]),_._v("：如果应用程序依赖于传输大量静态资源（如图像、CSS和JavaScript文件），可以考虑使用CDN来分发这些资源，以降低服务器负载。")]),_._v(" "),v("li",[v("strong",[_._v("分布式架构")]),_._v("：在系统设计中采用分布式架构，可以提高系统的可伸缩性，使其更容易处理高负载。")]),_._v(" "),v("li",[v("strong",[_._v("容灾设计")]),_._v("：设计容灾和高可用性解决方案，以确保系统在故障情况下仍然可用。")])]),_._v(" "),v("h3",{attrs:{id:"_11-ddd模式了解过吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-ddd模式了解过吗"}},[_._v("#")]),_._v(" 11.ddd模式了解过吗？")]),_._v(" "),v("p",[_._v("领域驱动设计是一种软件开发方法，旨在帮助开发团队更好地理解业务领域并将这种理解映射到软件设计中，以构建复杂业务系统。")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("领域模型")]),_._v("：领域模型是对业务领域的抽象表示，包括业务实体、值对象、聚合根、仓储等概念。领域模型应该反映业务领域的实际情况，并且应该在代码中得以体现。")]),_._v(" "),v("li",[v("strong",[_._v("聚合和聚合根")]),_._v("：聚合是一组相关的领域对象，它们一起被视为一个单元，由聚合根负责维护和管理。聚合根是聚合中的一个特殊对象，用于控制聚合内的操作和维护聚合的一致性。")]),_._v(" "),v("li",[v("strong",[_._v("领域驱动设计语言")]),_._v("：DDD 引入了一种通用的领域专业语言，用于开发团队和领域专家之间的沟通。这种语言帮助各方更好地理解业务需求和解决方案。")]),_._v(" "),v("li",[v("strong",[_._v("限界上下文")]),_._v("：DDD 强调将系统划分为不同的限界上下文，每个上下文都有自己的领域模型和语言。限界上下文之间通过明确定义的接口进行通信。")]),_._v(" "),v("li",[v("strong",[_._v("领域事件")]),_._v("：领域事件是对领域中发生的重要事情的描述。它们可以用于触发其他操作或通知其他上下文。")]),_._v(" "),v("li",[v("strong",[_._v("仓储")]),_._v("：仓储是用于访问领域对象的机制，它隐藏了数据访问的细节，使领域层可以独立于数据存储层变化。")])]),_._v(" "),v("h3",{attrs:{id:"_12-spring事务-你是如何使用事务的-是否遇到过事务失效-如何解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-spring事务-你是如何使用事务的-是否遇到过事务失效-如何解决"}},[_._v("#")]),_._v(" 12.spring事务，你是如何使用事务的？是否遇到过事务失效？如何解决？")]),_._v(" "),v("p",[_._v("使用注解Transational rollback 没有")]),_._v(" "),v("p",[v("strong",[_._v("编程式事务管理")]),_._v("则是通过编写代码来手动控制事务的开启、提交和回滚。虽然不常见，但在某些情况下也会使用编程式事务。")]),_._v(" "),v("p",[_._v("事务失效可能由于各种原因引起，例如：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("异常未被捕获")]),_._v("：如果在事务内部发生了未捕获的异常，事务可能不会回滚，导致数据不一致。")]),_._v(" "),v("li",[v("strong",[_._v("嵌套事务问题")]),_._v("：如果使用了嵌套事务，并且内层事务没有正确传播到外层事务，可能会导致事务失效。")]),_._v(" "),v("li",[v("strong",[_._v("不支持的方法调用")]),_._v("：在事务方法内部调用了不支持事务的方法，可能会导致事务失效。")])]),_._v(" "),v("h3",{attrs:{id:"_13-怎么理解视图-创建视图后-查询数据-这个数据从哪来"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-怎么理解视图-创建视图后-查询数据-这个数据从哪来"}},[_._v("#")]),_._v(" 13.怎么理解视图？创建视图后，查询数据，这个数据从哪来")]),_._v(" "),v("p",[_._v("是从表里来的，")]),_._v(" "),v("p",[_._v("视图（View）是数据库中的一种虚拟表，它是基于一个或多个表的查询结果构建的，具有与表类似的结构，但不存储实际数据。创建视图后，查询数据时，数据来自于视图对应的查询结果。")]),_._v(" "),v("p",[_._v("以下是对视图的理解以及视图的工作方式：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("视图是虚拟的表")]),_._v("：视图不存储数据，它是一个虚拟的表结构，可以被视为一个查询的结果集。视图的定义通常包括了一个 SQL 查询，该查询可以访问一个或多个表，并定义了视图中包含的列。")]),_._v(" "),v("li",[v("strong",[_._v("数据来自于基础表")]),_._v("：当您查询视图时，实际的数据来自于视图查询中使用的基础表（或其他视图）。视图本身只是一个定义，它会动态地根据查询规则从基础表中提取数据。")]),_._v(" "),v("li",[v("strong",[_._v("视图的用途")]),_._v("：视图有多种用途，其中之一是简化复杂查询。通过创建视图，您可以将常用的查询封装为一个视图，然后在应用程序中直接查询视图而不必编写复杂的 SQL 查询。视图还可以用于安全性，允许用户只能访问特定的数据子集，而不是整个表。")]),_._v(" "),v("li",[v("strong",[_._v("更新视图")]),_._v("：视图通常是可读的，但在某些情况下也可以更新。更新视图时，实际上是在更新基础表中的数据。但要注意，不是所有的视图都可以进行更新，具体取决于视图的定义以及支持视图更新的数据库系统。")])]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("CREATE VIEW high_value_orders AS\nSELECT * FROM orders WHERE total_amount > 100;\n")])])]),v("h3",{attrs:{id:"_14-在线做题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-在线做题"}},[_._v("#")]),_._v(" 14.在线做题")]),_._v(" "),v("p",[_._v("//实现个税的计算，输入一个金额，返回要缴多少税")]),_._v(" "),v("p",[_._v("//下面是各个档位的一个当前税率 :如果工资10000，那么前面5000不用交税，3000-3%，2000-10% 以此类推")]),_._v(" "),v("p",[_._v("//1~5000 税率 0")]),_._v(" "),v("p",[_._v("//5001~8000 3%")]),_._v(" "),v("p",[_._v("//8001~17000 10%")]),_._v(" "),v("p",[_._v(".................")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("function calculateTax(income) {\n    if (income <= 5000) {\n        return 0;\n    } else if (income <= 8000) {\n        return (income - 5000) * 0.03;\n    } else if (income <= 17000) {\n        return 3000 + (income - 8000) * 0.1;\n    } else {\n        // 如果超过17000，可以继续添加更高税率的条件\n        // 例如：elseif (income <= 30000) { return 3000 + 9000 + (income - 17000) * 0.2; }\n        // 否则返回适用的最高税率\n    }\n}\n")])])])])}),[],!1,null,null,null);v.default=t.exports}}]);