<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CCNAIVE</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="小灿的学习日记">
    
    <link rel="preload" href="/assets/css/0.styles.ac0ba637.css" as="style"><link rel="preload" href="/assets/js/app.9ff2d364.js" as="script"><link rel="preload" href="/assets/js/3.531b82cf.js" as="script"><link rel="preload" href="/assets/js/1.66bfa7cb.js" as="script"><link rel="preload" href="/assets/js/132.eeae6af5.js" as="script"><link rel="prefetch" href="/assets/js/10.bbcc4f2b.js"><link rel="prefetch" href="/assets/js/100.7aa78320.js"><link rel="prefetch" href="/assets/js/101.be1a84ed.js"><link rel="prefetch" href="/assets/js/102.e54a66c3.js"><link rel="prefetch" href="/assets/js/103.96ea8db8.js"><link rel="prefetch" href="/assets/js/104.1843f7ee.js"><link rel="prefetch" href="/assets/js/105.5cb7f1d0.js"><link rel="prefetch" href="/assets/js/106.d0836c05.js"><link rel="prefetch" href="/assets/js/107.ac03de3a.js"><link rel="prefetch" href="/assets/js/108.050b9491.js"><link rel="prefetch" href="/assets/js/109.77d90976.js"><link rel="prefetch" href="/assets/js/11.7cbe3508.js"><link rel="prefetch" href="/assets/js/110.d8921d36.js"><link rel="prefetch" href="/assets/js/111.e834d261.js"><link rel="prefetch" href="/assets/js/112.fc17c22f.js"><link rel="prefetch" href="/assets/js/113.4a13e794.js"><link rel="prefetch" href="/assets/js/114.a0fc2dc4.js"><link rel="prefetch" href="/assets/js/115.c52d7495.js"><link rel="prefetch" href="/assets/js/116.18b15740.js"><link rel="prefetch" href="/assets/js/117.d5961bc5.js"><link rel="prefetch" href="/assets/js/118.ae8cd8e7.js"><link rel="prefetch" href="/assets/js/119.dbabe50a.js"><link rel="prefetch" href="/assets/js/12.03e80136.js"><link rel="prefetch" href="/assets/js/120.0a552300.js"><link rel="prefetch" href="/assets/js/121.0b55973d.js"><link rel="prefetch" href="/assets/js/122.a2372c82.js"><link rel="prefetch" href="/assets/js/123.9a1ed746.js"><link rel="prefetch" href="/assets/js/124.81c9bce0.js"><link rel="prefetch" href="/assets/js/125.9cc747cb.js"><link rel="prefetch" href="/assets/js/126.63641e51.js"><link rel="prefetch" href="/assets/js/127.afa36756.js"><link rel="prefetch" href="/assets/js/128.c3a0bafc.js"><link rel="prefetch" href="/assets/js/129.626bef76.js"><link rel="prefetch" href="/assets/js/13.98d91332.js"><link rel="prefetch" href="/assets/js/130.718e36e5.js"><link rel="prefetch" href="/assets/js/131.2f866590.js"><link rel="prefetch" href="/assets/js/133.5f7161d3.js"><link rel="prefetch" href="/assets/js/134.d370c48c.js"><link rel="prefetch" href="/assets/js/135.cb4d88e1.js"><link rel="prefetch" href="/assets/js/136.49c2b181.js"><link rel="prefetch" href="/assets/js/137.4d5d406c.js"><link rel="prefetch" href="/assets/js/138.35297bdc.js"><link rel="prefetch" href="/assets/js/139.4cde83dd.js"><link rel="prefetch" href="/assets/js/14.5f24a2ff.js"><link rel="prefetch" href="/assets/js/140.1fba8365.js"><link rel="prefetch" href="/assets/js/141.cb4421c0.js"><link rel="prefetch" href="/assets/js/142.ea1fe29a.js"><link rel="prefetch" href="/assets/js/143.b21df084.js"><link rel="prefetch" href="/assets/js/144.a5450651.js"><link rel="prefetch" href="/assets/js/145.4a9f1b6c.js"><link rel="prefetch" href="/assets/js/146.032cd6ee.js"><link rel="prefetch" href="/assets/js/147.0ee0cf1b.js"><link rel="prefetch" href="/assets/js/148.3954607b.js"><link rel="prefetch" href="/assets/js/149.550f7938.js"><link rel="prefetch" href="/assets/js/15.1dd4d056.js"><link rel="prefetch" href="/assets/js/150.6b5ff9f8.js"><link rel="prefetch" href="/assets/js/151.7435d46f.js"><link rel="prefetch" href="/assets/js/152.4bb838b9.js"><link rel="prefetch" href="/assets/js/153.13d7f61b.js"><link rel="prefetch" href="/assets/js/154.c2c89d66.js"><link rel="prefetch" href="/assets/js/155.28853989.js"><link rel="prefetch" href="/assets/js/156.d207ca7c.js"><link rel="prefetch" href="/assets/js/157.9f4a887f.js"><link rel="prefetch" href="/assets/js/158.56a32b96.js"><link rel="prefetch" href="/assets/js/159.ccff2e00.js"><link rel="prefetch" href="/assets/js/16.9df877bb.js"><link rel="prefetch" href="/assets/js/160.1ce908c3.js"><link rel="prefetch" href="/assets/js/161.db87a48e.js"><link rel="prefetch" href="/assets/js/162.da596968.js"><link rel="prefetch" href="/assets/js/163.4b1914f2.js"><link rel="prefetch" href="/assets/js/164.d1428de2.js"><link rel="prefetch" href="/assets/js/165.3555dd76.js"><link rel="prefetch" href="/assets/js/166.3ec9c434.js"><link rel="prefetch" href="/assets/js/167.e1c89e9e.js"><link rel="prefetch" href="/assets/js/168.0a520b94.js"><link rel="prefetch" href="/assets/js/169.4122d818.js"><link rel="prefetch" href="/assets/js/17.cd29530c.js"><link rel="prefetch" href="/assets/js/170.0ac3b66b.js"><link rel="prefetch" href="/assets/js/171.a3a64b2d.js"><link rel="prefetch" href="/assets/js/172.7ac6a10c.js"><link rel="prefetch" href="/assets/js/173.4be2f7b1.js"><link rel="prefetch" href="/assets/js/174.0dfc7fdb.js"><link rel="prefetch" href="/assets/js/175.32ead0bc.js"><link rel="prefetch" href="/assets/js/176.209b5dbb.js"><link rel="prefetch" href="/assets/js/177.11adbb39.js"><link rel="prefetch" href="/assets/js/178.037a7502.js"><link rel="prefetch" href="/assets/js/18.097816ce.js"><link rel="prefetch" href="/assets/js/19.187e5563.js"><link rel="prefetch" href="/assets/js/20.6deb3fe1.js"><link rel="prefetch" href="/assets/js/21.9d82a949.js"><link rel="prefetch" href="/assets/js/22.0edad57f.js"><link rel="prefetch" href="/assets/js/23.b9c5f664.js"><link rel="prefetch" href="/assets/js/24.897f1420.js"><link rel="prefetch" href="/assets/js/25.1311359f.js"><link rel="prefetch" href="/assets/js/26.17a94cd7.js"><link rel="prefetch" href="/assets/js/27.fa379248.js"><link rel="prefetch" href="/assets/js/28.f6aab20b.js"><link rel="prefetch" href="/assets/js/29.d9c56383.js"><link rel="prefetch" href="/assets/js/30.8dba19c8.js"><link rel="prefetch" href="/assets/js/31.10a83a0f.js"><link rel="prefetch" href="/assets/js/32.edae26a7.js"><link rel="prefetch" href="/assets/js/33.72f0a131.js"><link rel="prefetch" href="/assets/js/34.5a0fb7ca.js"><link rel="prefetch" href="/assets/js/35.9f28286e.js"><link rel="prefetch" href="/assets/js/36.ae243faa.js"><link rel="prefetch" href="/assets/js/37.381ff339.js"><link rel="prefetch" href="/assets/js/38.17ebee17.js"><link rel="prefetch" href="/assets/js/39.876319cd.js"><link rel="prefetch" href="/assets/js/4.979f9922.js"><link rel="prefetch" href="/assets/js/40.b2cec200.js"><link rel="prefetch" href="/assets/js/41.91b3553a.js"><link rel="prefetch" href="/assets/js/42.80320f96.js"><link rel="prefetch" href="/assets/js/43.783075f8.js"><link rel="prefetch" href="/assets/js/44.5b01350d.js"><link rel="prefetch" href="/assets/js/45.95d4d094.js"><link rel="prefetch" href="/assets/js/46.96cea9c3.js"><link rel="prefetch" href="/assets/js/47.23ced73b.js"><link rel="prefetch" href="/assets/js/48.04da13e7.js"><link rel="prefetch" href="/assets/js/49.2b134421.js"><link rel="prefetch" href="/assets/js/5.dda74e2f.js"><link rel="prefetch" href="/assets/js/50.cbbc36b3.js"><link rel="prefetch" href="/assets/js/51.c1a47ca0.js"><link rel="prefetch" href="/assets/js/52.36261b66.js"><link rel="prefetch" href="/assets/js/53.4d53e570.js"><link rel="prefetch" href="/assets/js/54.13e1603f.js"><link rel="prefetch" href="/assets/js/55.809c8ddc.js"><link rel="prefetch" href="/assets/js/56.5df2380e.js"><link rel="prefetch" href="/assets/js/57.2194d408.js"><link rel="prefetch" href="/assets/js/58.2c620696.js"><link rel="prefetch" href="/assets/js/59.34ee045d.js"><link rel="prefetch" href="/assets/js/6.5eed2fc3.js"><link rel="prefetch" href="/assets/js/60.3f617150.js"><link rel="prefetch" href="/assets/js/61.92698d83.js"><link rel="prefetch" href="/assets/js/62.0bfecc40.js"><link rel="prefetch" href="/assets/js/63.8da717e4.js"><link rel="prefetch" href="/assets/js/64.200fd49a.js"><link rel="prefetch" href="/assets/js/65.72a58cca.js"><link rel="prefetch" href="/assets/js/66.2985426d.js"><link rel="prefetch" href="/assets/js/67.8862ebfb.js"><link rel="prefetch" href="/assets/js/68.6f5b02a9.js"><link rel="prefetch" href="/assets/js/69.aa496fb1.js"><link rel="prefetch" href="/assets/js/7.8f40985b.js"><link rel="prefetch" href="/assets/js/70.b26013d6.js"><link rel="prefetch" href="/assets/js/71.1b1ae916.js"><link rel="prefetch" href="/assets/js/72.3035363e.js"><link rel="prefetch" href="/assets/js/73.eca6d0df.js"><link rel="prefetch" href="/assets/js/74.d4240c34.js"><link rel="prefetch" href="/assets/js/75.4dcd7ab1.js"><link rel="prefetch" href="/assets/js/76.e0675e49.js"><link rel="prefetch" href="/assets/js/77.edf24e37.js"><link rel="prefetch" href="/assets/js/78.552224f2.js"><link rel="prefetch" href="/assets/js/79.be7a41b6.js"><link rel="prefetch" href="/assets/js/8.e3dca3e1.js"><link rel="prefetch" href="/assets/js/80.147a04c7.js"><link rel="prefetch" href="/assets/js/81.3ecd3a95.js"><link rel="prefetch" href="/assets/js/82.b647894f.js"><link rel="prefetch" href="/assets/js/83.200bc3a6.js"><link rel="prefetch" href="/assets/js/84.a15d5403.js"><link rel="prefetch" href="/assets/js/85.75a34ef2.js"><link rel="prefetch" href="/assets/js/86.6b4e2beb.js"><link rel="prefetch" href="/assets/js/87.b15ce75c.js"><link rel="prefetch" href="/assets/js/88.507b99bb.js"><link rel="prefetch" href="/assets/js/89.b5d5b184.js"><link rel="prefetch" href="/assets/js/9.a4890a44.js"><link rel="prefetch" href="/assets/js/90.40064807.js"><link rel="prefetch" href="/assets/js/91.5cab932b.js"><link rel="prefetch" href="/assets/js/92.8682710e.js"><link rel="prefetch" href="/assets/js/93.78582e33.js"><link rel="prefetch" href="/assets/js/94.48896994.js"><link rel="prefetch" href="/assets/js/95.b637124b.js"><link rel="prefetch" href="/assets/js/96.07d46f7c.js"><link rel="prefetch" href="/assets/js/97.c24e0b91.js"><link rel="prefetch" href="/assets/js/98.d6a95e55.js"><link rel="prefetch" href="/assets/js/99.9330a585.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ac0ba637.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>CCNAIVE</h3> <p class="description" data-v-59e6cb88>小灿的学习日记</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">CCNAIVE</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      小灿的学习日记
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lichengcan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/lichengcan0228/lichengcan0228" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>160</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>6</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      小灿的学习日记
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lichengcan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/lichengcan0228/lichengcan0228" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">CCNAIVE</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/Java/面向对象/多态" class="sidebar-heading clickable"><span>Java 从入门到放弃</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/数据结构与算法/排序/排序" class="sidebar-heading clickable"><span>数据结构与算法</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/网络/基础篇/TCP-IP" class="sidebar-heading clickable"><span>网络</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Spring/Spring/Spring" class="sidebar-heading clickable"><span>Spring 全家桶</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/数据库/MySQL/CommonUseSQL" class="sidebar-heading clickable"><span>数据库</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/技术框架/rabbitmq/rabbitmq" class="sidebar-heading clickable active"><span>技术框架</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/Linux/LinuxCommand" class="sidebar-heading clickable"><span>Linux 服务器相关</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/杂/一些网站/website" class="sidebar-heading clickable"><span>杂</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title"></h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>承灿</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2023/12/12</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><blockquote><p>转载：https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github</p></blockquote> <h1 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1. 概述</h1> <p>考虑这是 RabbitMQ 如何在 Spring Boot 整合与使用的文章，所以还是简单介绍下 RabbitMQ 是什么？</p> <blockquote><p>FROM <a href="https://www.oschina.net/p/rabbitmq" target="_blank" rel="noopener noreferrer">《AMQP 消息服务器 RabbitMQ》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>RabbitMQ 是由 LShift 提供的一个 Advanced Message Queuing Protocol (AMQP) 的开源实现，由以高性能、健壮以及可伸缩性出名的 Erlang 写成，因此也是继承了这些优点。</p> <p><img src="https://raw.githubusercontent.com/lichengcan/images/main/991c599424d61e17aea8eb76571715c9.jpg" alt=""></p> <ul><li>AMQP 里主要要说两个组件：Exchange 和 Queue ，绿色的 X 就是 Exchange ，红色的是 Queue ，这两者都在 Server 端，又称作 Broker ，这部分是 RabbitMQ 实现的。</li> <li>而蓝色的则是客户端，通常有 Producer 和 Consumer 两种类型（角色）。</li></ul></blockquote> <p>在本文中，提供更多的生产者 Producer 和消费者 Consumer 的使用示例。例如说：</p> <ul><li>四种类型的交换机( Exchange )</li> <li>Producer 发送<strong>顺序</strong>消息，Consumer <strong>顺序</strong>消费消息。</li> <li>Producer 发送<strong>定时</strong>消息。</li> <li>Producer <strong>批量</strong>发送消息。</li> <li>Producer 发送<strong>事务</strong>消息。</li> <li>Consumer <strong>广播</strong>和<strong>集群</strong>消费消息。</li> <li>Consumer 批量消费消息。</li></ul> <h1 id="_2-spring-amqp"><a href="#_2-spring-amqp" class="header-anchor">#</a> 2. Spring-AMQP</h1> <p>在 Spring 生态中，提供了 <a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener noreferrer">Spring-AMQP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目，让我们更简便的使用 AMQP 。其官网介绍如下：</p> <blockquote><p>The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions. Spring-AMQP 项目将 Spring 核心概念应用于基于 AMQP 的消息传递解决方案的开发。</p> <p>It provides a &quot;template&quot; as a high-level abstraction for sending and receiving messages. 它提供了一个“模板”作为发送消息的高级抽象。</p> <p>It also provides support for Message-driven POJOs with a &quot;listener container&quot;. 它还通过“侦听器容器”为消息驱动的 POJO 提供支持。</p> <p>These libraries facilitate management of AMQP resources while promoting the use of dependency injection and declarative configuration. 这些库促进 AMQP 资源的管理，同时促进使用依赖注入和声明性配置。</p> <p>In all of these cases, you will see similarities to the JMS support in the Spring Framework. 在所有这些情况下，您将看到与 Spring 框架中的 JMS 支持的相似之处。</p> <p>The project consists of two parts; spring-amqp is the base abstraction, and spring-rabbit is the RabbitMQ implementation. 该项目包括两个部分：</p> <ul><li><a href="https://mvnrepository.com/artifact/org.springframework.amqp/spring-amqp" target="_blank" rel="noopener noreferrer"><code>spring-amqp</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是 AMQP 的基础抽象。</li> <li><a href="https://mvnrepository.com/artifact/org.springframework.amqp/spring-rabbit" target="_blank" rel="noopener noreferrer"><code>spring-rabbit</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是基于 RabbitMQ 对 AMQP 的具体实现。</li></ul></blockquote> <ul><li>其实重点是最后一段内容，相信胖友能够明白意思的。</li></ul> <blockquote><p>Features(功能特性)</p> <ul><li>Listener container for asynchronous processing of inbound messages 监听器容器：异步处理接收到的消息</li> <li><a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java" target="_blank" rel="noopener noreferrer">RabbitTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for sending and receiving messages RabbitTemplate：发送和接收消息</li> <li><a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java" target="_blank" rel="noopener noreferrer">RabbitAdmin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for automatically declaring queues, exchanges and bindings RabbitAdmin：自动创建队列，交换器，绑定器。</li></ul></blockquote> <p>在 <a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener noreferrer">Spring-Boot<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目中，提供了 AMQP 和 RabbitMQ 的自动化配置，所以我们仅需引入 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp" target="_blank" rel="noopener noreferrer"><code>spring-boot-starter-amqp</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 依赖，即可愉快的使用。</p> <h1 id="_3-快速入门"><a href="#_3-快速入门" class="header-anchor">#</a> 3. 快速入门</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p></blockquote> <p>在 AMQP 中，Producer 将消息发送到 Exchange ，再由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。</p> <blockquote><p>概念的讲解，引用自 <a href="http://www.iocoder.cn/RabbitMQ/Detailed-understanding-of-the-basic-concepts-of-RabbitMQ/?self" target="_blank" rel="noopener noreferrer">《RabbitMQ 基础概念详解》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文章。</p></blockquote> <p>Exchange 根据 Routing Key 和 Binding Key 将消息路由到 Queue 。目前提供了 Direct、Topic、Fanout、Headers 四种类型。</p> <h2 id="_3-1-direct-exchange"><a href="#_3-1-direct-exchange" class="header-anchor">#</a> 3.1 Direct Exchange</h2> <p>Direct 类型的 Exchange 路由规则比较简单，它会把消息路由到那些 binding key 与 routing key 完全匹配的 Queue 中。以下图的配置为例：</p> <p><img src="https://raw.githubusercontent.com/lichengcan/images/main/aeb33c91bbf83726c24ba1dae9dc4e00.jpg" alt=""></p> <ul><li>我们以 <code>routingKey=&quot;error&quot;</code> 发送消息到 Exchange ，则消息会路由到 Queue1(<code>amqp.gen-S9b…</code>) 。</li> <li>我们以 <code>routingKey=&quot;info&quot;</code> 或 <code>routingKey=&quot;warning&quot;</code> 来发送消息，则消息只会路由到 Queue2(<code>amqp.gen-Agl…</code>) 。</li> <li>如果我们以其它 routingKey 发送消息，则消息不会路由到这两个 Queue 中。</li> <li>总结来说，指定 Exchange + routing key ，有且仅会路由到至多一个 Queue 中。😈 极端情况下，如果没有匹配，消息就发送到“空气”中，不会进入任何 Queue 中。</li></ul> <blockquote><p>注：Queue 名字 <code>amqp.gen-S9b…</code> 和 <code>amqp.gen-Agl…</code> 自动生成的。</p></blockquote> <p>下面，我们来创建一个 Direct Exchange 的使用示例，对应 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h3 id="_3-1-1-引入依赖"><a href="#_3-1-1-引入依赖" class="header-anchor">#</a> 3.1.1 引入依赖</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件中，引入相关依赖。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;lab-04-rabbitmq-demo&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!-- 实现对 RabbitMQ 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 方便等会写单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre></div><p>具体每个依赖的作用，胖友自己认真看下艿艿添加的所有注释噢。</p> <h3 id="_3-1-2-应用配置文件"><a href="#_3-1-2-应用配置文件" class="header-anchor">#</a> 3.1.2 应用配置文件</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/resources" target="_blank" rel="noopener noreferrer"><code>resources</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 目录下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置文件。配置如下：</p> <div class="language- extra-class"><pre class="language-text"><code>spring:
  # RabbitMQ 配置项，对应 RabbitProperties 配置类
  rabbitmq:
    host: 127.0.0.1 # RabbitMQ 服务的地址
    port: 5672 # RabbitMQ 服务的端口
    username: guest # RabbitMQ 服务的账号
    password: guest # RabbitMQ 服务的密码
</code></pre></div><ul><li>在 <code>spring.rabbitmq</code> 配置项，设置 RabbitMQ 的配置，对应 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java" target="_blank" rel="noopener noreferrer">RabbitProperties<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类。这里咱暂时最小化添加，更多的配置项，我们在下文的示例中，一点点抽丝剥茧。</li> <li>Spring Boot 提供的 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.java" target="_blank" rel="noopener noreferrer">RabbitAutoConfiguration<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 自动化配置类，实现 RabbitMQ 的自动配置，创建相应的 Producer 和 Consumer 。</li></ul> <h3 id="_3-1-3-application"><a href="#_3-1-3-application" class="header-anchor">#</a> 3.1.3 Application</h3> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/Application.java" target="_blank" rel="noopener noreferrer"><code>Application.java</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，配置 <code>@SpringBootApplication</code> 注解即可。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Application.java

@SpringBootApplication
@EnableAsync // 开启异步
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
</code></pre></div><ul><li>我们额外添加了 <code>@EnableAsync</code> 注解，因为我们稍后要使用 Spring 提供的异步调用的功能。不了解这块的胖友，可以看看艿艿写的 <a href="http://www.iocoder.cn/Spring-Boot/Async-Job/?self" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 异步任务入门》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文章。</li></ul> <h3 id="_3-1-4-demo01message"><a href="#_3-1-4-demo01message" class="header-anchor">#</a> 3.1.4 Demo01Message</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo01Message.java" target="_blank" rel="noopener noreferrer">Demo01Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo01Message.java

public class Demo01Message implements Serializable {

    public static final String QUEUE = &quot;QUEUE_DEMO_01&quot;;

    public static final String EXCHANGE = &quot;EXCHANGE_DEMO_01&quot;;

    public static final String ROUTING_KEY = &quot;ROUTING_KEY_01&quot;;

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>注意，要实现 Java Serializable 序列化接口。因为 RabbitTemplate 默认使用 Java 自带的序列化方式，进行序列化 POJO 类型的消息。</li> <li>在消息类里，我们枚举了 Exchange、Queue、RoutingKey 的名字。</li></ul> <h3 id="_3-1-5-rabbitconfig"><a href="#_3-1-5-rabbitconfig" class="header-anchor">#</a> 3.1.5 RabbitConfig</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加 Direct Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

import org.springframework.amqp.core.Queue;

@Configuration
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo01Queue() {
            return new Queue(Demo01Message.QUEUE, // Queue 名字
                    true, // durable: 是否持久化
                    false, // exclusive: 是否排它
                    false); // autoDelete: 是否自动删除
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo01Exchange() {
            return new DirectExchange(Demo01Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        // Exchange：Demo01Message.EXCHANGE
        // Routing key：Demo01Message.ROUTING_KEY
        // Queue：Demo01Message.QUEUE
        @Bean
        public Binding demo01Binding() {
            return BindingBuilder.bind(demo01Queue()).to(demo01Exchange()).with(Demo01Message.ROUTING_KEY);
        }

    }

}
</code></pre></div><ul><li>在 DirectExchangeDemoConfiguration 内部静态类中，我们创建了 Exchange、Queue、Binding 三个 Bean ，后续 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java" target="_blank" rel="noopener noreferrer">RabbitAdmin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 会自动创建交换器、队列、绑定器。感兴趣的胖友，可以看看 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitAdmin.java#L555-L612" target="_blank" rel="noopener noreferrer"><code>RabbitAdmin#initialize()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法，或 <a href="https://my.oschina.net/huaxian8812/blog/782300" target="_blank" rel="noopener noreferrer">《RabbitMQ 自动创建队列/交换器/绑定》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文章。</li></ul> <h3 id="_3-1-6-demo01producer"><a href="#_3-1-6-demo01producer" class="header-anchor">#</a> 3.1.6 Demo01Producer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo01Producer.java" target="_blank" rel="noopener noreferrer">Demo01Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo01Producer.java

@Component
public class Demo01Producer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id) {
        // 创建 Demo01Message 消息
        Demo01Message message = new Demo01Message();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(Demo01Message.EXCHANGE, Demo01Message.ROUTING_KEY, message);
    }

    public void syncSendDefault(Integer id) {
        // 创建 Demo01Message 消息
        Demo01Message message = new Demo01Message();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(Demo01Message.QUEUE, message);
    }

    @Async
    public ListenableFuture&lt;Void&gt; asyncSend(Integer id) {
        try {
            // 发送消息
            this.syncSend(id);
            // 返回成功的 Future
            return AsyncResult.forValue(null);
        } catch (Throwable ex) {
            // 返回异常的 Future
            return AsyncResult.forExecutionException(ex);
        }
    }

}
</code></pre></div><ul><li><p>RabbitTemplate 是 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/AmqpTemplate.java" target="_blank" rel="noopener noreferrer">AmqpTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 接口的实现类，所以此时使用 AmqpTemplate 亦可。不过又因为 RabbitTemplate 还实现了其它接口，所以操作会更为丰富。因此，这里我们选择了注入 RabbitTemplate 属性。</p></li> <li><p><code>#syncSend(Integer id)</code> 方法，调用 RabbitTemplate 的同步发送消息方法。方法定义如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// AmqpTemplate.java

void convertAndSend(String exchange, String routingKey, Object message) throws AmqpException;
</code></pre></div><ul><li>指定 Exchange + RoutingKey ，从而路由到一个 Queue 中。</li></ul></li> <li><p><code>#syncSendDefault(Integer id)</code> 方法，也调用 RabbitTemplate 的同步发送消息方法。方法定义如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// AmqpTemplate.java

void convertAndSend(String routingKey, Object message) throws AmqpException;
</code></pre></div><ul><li>是不是觉得有点奇怪，这里我们传入的 RoutingKey 为队列名？！因为 RabbitMQ 有一条默认的 <a href="https://emacsist.github.io/2015/12/06/rabbitmq%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#default-exchange-%E9%BB%98%E8%AE%A4%E4%BA%A4%E6%8D%A2%E6%9C%BA" target="_blank" rel="noopener noreferrer">Exchange: (AMQP default)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 规则：<code>The default exchange is implicitly bound to every queue, with a routing key equal to the queue name. It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted</code> 。</li> <li>翻译过来的意思：默认交换器，隐式地绑定到每个队列，路由键等于队列名称。</li> <li>所以，此处即使我们传入的 RoutingKey 为队列名，一样可以发到对应队列。</li></ul></li> <li><p><code>#asyncSend(Integer id)</code> 方法，通过 <code>@Async</code> 注解，声明异步调用该方法，从而实现异步消息到 RabbitMQ 中。因为 RabbitTemplate 并未像 <a href="https://github.com/spring-projects/spring-kafka/blob/master/spring-kafka/src/main/java/org/springframework/kafka/core/KafkaTemplate.java" target="_blank" rel="noopener noreferrer">KafkaTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或 <a href="https://github.com/apache/rocketmq-spring/blob/master/rocketmq-spring-boot/src/main/java/org/apache/rocketmq/spring/core/RocketMQTemplate.java" target="_blank" rel="noopener noreferrer">RocketMQTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 直接提供了异步发送消息的方法，所以我们需要结合 Spring 异步调用来实现。</p> <blockquote><p>在写完本文之后，发现还存在 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/AsyncRabbitTemplate.java" target="_blank" rel="noopener noreferrer">AsyncRabbitTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，提供一部的 RabbitMQ 操作。😈</p></blockquote></li></ul> <h3 id="_3-1-7-demo01consumer"><a href="#_3-1-7-demo01consumer" class="header-anchor">#</a> 3.1.7 Demo01Consumer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo01Consumer.java" target="_blank" rel="noopener noreferrer">Demo01Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo01Consumer.java

@Component
@RabbitListener(queues = Demo01Message.QUEUE)
public class Demo01Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo01Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

//    @RabbitHandler(isDefault = true)
//    public void onMessage(org.springframework.amqp.core.Message message) {
//        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
//    }

}
</code></pre></div><ul><li>在类上，添加了 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitListener.java" target="_blank" rel="noopener noreferrer"><code>@RabbitListener</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 注解，声明了消费的队列是 <code>&quot;QUEUE_DEMO_01&quot;</code> 。</li> <li>在方法上，添加了 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitHandler.java" target="_blank" rel="noopener noreferrer"><code>@RabbitHandler</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 注解，申明了处理消息的方法。同时，方法入参为消息的类型。这里，我们设置了<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</li> <li>如果我们想要获得消费消息的更多信息，例如说，RoutingKey、创建时间等等信息，则可以考虑使用艿艿<strong>注释掉的那段代码</strong>，通过方法入参为 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/Message.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.amqp.core.Message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类型。不过绝大多数情况下，我们并不需要这么做。</li></ul> <h3 id="_3-1-8-简单测试"><a href="#_3-1-8-简单测试" class="header-anchor">#</a> 3.1.8 简单测试</h3> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo01ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo01ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写三个单元测试方法，调用 Demo01Producer 三个发送消息的方式。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo01ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo01ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo01Producer producer;

    @Test
    public void testSyncSend() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

    @Test
    public void tesSyncSendDefault() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSendDefault(id);
        logger.info(&quot;[tesSyncSendDefault][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

    @Test
    public void testAsyncSend() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.asyncSend(id).addCallback(new ListenableFutureCallback&lt;Void&gt;() {

            @Override
            public void onFailure(Throwable e) {
                logger.info(&quot;[testASyncSend][发送编号：[{}] 发送异常]]&quot;, id, e);
            }

            @Override
            public void onSuccess(Void aVoid) {
                logger.info(&quot;[testASyncSend][发送编号：[{}] 发送成功，发送成功]&quot;, id);
            }

        });
        logger.info(&quot;[testASyncSend][发送编号：[{}] 调用完成]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><ul><li>比较简单，胖友自己看下三个单元测试方法。</li></ul> <p>我们来执行 <code>#testSyncSend()</code> 方法，测试同步发送消息。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 同步发送消息成功。
2019-12-15 00:19:18.736  INFO 87164 --- [           main] c.i.s.l.r.producer.Demo01ProducerTest    : [testSyncSend][发送编号：[1575908358] 发送成功]

# Demo01Consumer 成功消费了该消息
2019-12-15 00:19:18.751  INFO 87164 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo01Consumer        : [onMessage][线程编号:17 消息内容：Demo01Message{id=1575908358}]
</code></pre></div><ul><li>同步发送的消息，成功被消费。</li></ul> <p>我们再来执行 <code>#tesSyncSendDefault()</code> 方法，测试另一个同步发送消息。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 同步发送消息成功。
2019-12-15 00:20:50.226  INFO 87515 --- [           main] c.i.s.l.r.producer.Demo01ProducerTest    : [tesSyncSendDefault][发送编号：[1575908450] 发送成功]

# Demo01Consumer 成功消费了该消息
2019-12-15 00:20:50.240  INFO 87515 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo01Consumer        : [onMessage][线程编号:17 消息内容：Demo01Message{id=1575908450}]
</code></pre></div><ul><li>同步发送的消息，成功也被消费。</li></ul> <p>我们最后来执行 <code>#testAsyncSend()</code> 方法，测试异步发送消息。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 异步发送消息的调用完成。
2019-12-15 00:22:48.891  INFO 88018 --- [           main] c.i.s.l.r.producer.Demo01ProducerTest    : [testASyncSend][发送编号：[1575908568] 调用完成]

# Producer 异步发送消息成功。【回调】
2019-12-15 00:22:48.905  INFO 88018 --- [         task-1] c.i.s.l.r.producer.Demo01ProducerTest    : [testASyncSend][发送编号：[1575908568] 发送成功，发送成功]

# Demo01Consumer 成功消费了该消息
2019-12-15 00:22:48.918  INFO 88018 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo01Consumer        : [onMessage][线程编号:17 消息内容：Demo01Message{id=1575908568}]
</code></pre></div><ul><li>异步发送的消息，成功也被消费。</li></ul> <h2 id="_3-2-topic-exchange"><a href="#_3-2-topic-exchange" class="header-anchor">#</a> 3.2 Topic Exchange</h2> <p>前面讲到 Direct Exchange路由规则，是完全匹配 binding key 与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。</p> <p>Topic Exchange 在匹配规则上进行了扩展，它与 Direct 类型的Exchange <strong>相似</strong>，也是将消息路由到 binding key 与 routing key 相匹配的 Queue 中，但这里的匹配规则有些不同，它约定：</p> <ul><li>routing key 为一个句点号 <code>&quot;.&quot;</code> 分隔的字符串。我们将被句点号<code>&quot;.&quot;</code>分隔开的每一段独立的字符串称为一个单词，例如 &quot;stock.usd.nyse&quot;、&quot;nyse.vmw&quot;、&quot;quick.orange.rabbit&quot;</li> <li>binding key 与 routing key 一样也是句点号 <code>&quot;.&quot;</code> 分隔的字符串。</li> <li>binding key 中可以存在两种特殊字符 <code>&quot;*&quot;</code> 与 <code>&quot;#&quot;</code>，用于做模糊匹配。其中 <code>&quot;*&quot;</code> 用于匹配一个单词，<code>&quot;#&quot;</code> 用于匹配多个单词（可以是零个）。</li></ul> <p>以下图中的配置为例：</p> <p><img src="https://raw.githubusercontent.com/lichengcan/images/main/d343228b9d7606ac673ccd0028d4e424.jpg" alt=""></p> <ul><li><code>routingKey=&quot;quick.orange.rabbit&quot;</code> 的消息会同时路由到 Q1 与 Q2 。</li> <li><code>routingKey=&quot;lazy.orange.fox&quot;</code> 的消息会路由到 Q1 。</li> <li><code>routingKey=&quot;lazy.brown.fox&quot;</code> 的消息会路由到 Q2 。</li> <li><code>routingKey=&quot;lazy.pink.rabbit&quot;</code> 的消息会路由到Q2（只会投递给 Q2 一次，虽然这个 routingKey 与 Q2 的两个 bindingKey 都匹配）。</li> <li><code>routingKey=&quot;quick.brown.fox&quot;</code>、<code>routingKey=&quot;orange&quot;</code>、<code>routingKey=&quot;quick.orange.male.rabbit&quot;</code> 的消息将会被丢弃，因为它们没有匹配任何 bindingKey 。</li></ul> <p>下面，我们来创建一个 Topic Exchange 的使用示例，继续在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h3 id="_3-2-1-demo02message"><a href="#_3-2-1-demo02message" class="header-anchor">#</a> 3.2.1 Demo02Message</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo02Message.java" target="_blank" rel="noopener noreferrer">Demo02Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo02Message.java

public class Demo02Message implements Serializable {

    public static final String QUEUE = &quot;QUEUE_DEMO_02&quot;;

    public static final String EXCHANGE = &quot;EXCHANGE_DEMO_02&quot;;

    public static final String ROUTING_KEY = &quot;#.yu.nai&quot;;

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>在消息类里，我们枚举了 Exchange、Queue、RoutingKey 的名字。</li> <li>重点看我们新定义的路由键 <code>ROUTING_KEY = &quot;#.yu.nai&quot;</code> ，我们要匹配以 <code>&quot;yu.nai&quot;</code> 结尾，开头可以是任意个单词的。</li></ul> <h3 id="_3-2-2-rabbitconfig"><a href="#_3-2-2-rabbitconfig" class="header-anchor">#</a> 3.2.2 RabbitConfig</h3> <p>修改 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加 Topic Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

/**
 * Topic Exchange 示例的配置类
 */
public static class TopicExchangeDemoConfiguration {

    // 创建 Queue
    @Bean
    public Queue demo02Queue() {
        return new Queue(Demo02Message.QUEUE, // Queue 名字
                true, // durable: 是否持久化
                false, // exclusive: 是否排它
                false); // autoDelete: 是否自动删除
    }

    // 创建 Topic Exchange
    @Bean
    public TopicExchange demo02Exchange() {
        return new TopicExchange(Demo02Message.EXCHANGE,
                true,  // durable: 是否持久化
                false);  // exclusive: 是否排它
    }

    // 创建 Binding
    // Exchange：Demo02Message.EXCHANGE
    // Routing key：Demo02Message.ROUTING_KEY
    // Queue：Demo02Message.QUEUE
    @Bean
    public Binding demo02Binding() {
        return BindingBuilder.bind(demo02Queue()).to(demo02Exchange()).with(Demo02Message.ROUTING_KEY);
    }

}
</code></pre></div><ul><li>在 TopicExchangeDemoConfiguration 内部静态类中，我们<strong>也是</strong>创建了 Exchange、Queue、Binding 三个 Bean 。有差异点的是，这次我们创建的是 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/TopicExchange.java" target="_blank" rel="noopener noreferrer">TopicExchange<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</li></ul> <h3 id="_3-2-3-demo02producer"><a href="#_3-2-3-demo02producer" class="header-anchor">#</a> 3.2.3 Demo02Producer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo02Producer.java" target="_blank" rel="noopener noreferrer">Demo02Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo02Producer.java

@Component
public class Demo02Producer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id, String routingKey) {
        // 创建 Demo02Message 消息
        Demo02Message message = new Demo02Message();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(Demo02Message.EXCHANGE, routingKey, message);
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 <code>#syncSend(Integer id)</code> 方法大体相似，差异点在于新增了方法参数 <code>routingKey</code> ，方便我们传入不同的路由键。</li></ul> <h3 id="_3-2-4-demo02consumer"><a href="#_3-2-4-demo02consumer" class="header-anchor">#</a> 3.2.4 Demo02Consumer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo02Consumer.java" target="_blank" rel="noopener noreferrer">Demo02Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.7 Demo01Consumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>基本一致，差别在于消费的队列是 <code>&quot;QUEUE_DEMO_02&quot;</code> 。</p> <h3 id="_3-2-5-简单测试"><a href="#_3-2-5-简单测试" class="header-anchor">#</a> 3.2.5 简单测试</h3> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo02ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo02ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写两个单元测试方法，调用 Demo02Producer 发送消息的方法。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo02ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo02ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo02Producer producer;

    @Test
    public void testSyncSendSuccess() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id, &quot;da.yu.nai&quot;);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

    @Test
    public void testSyncSendFailure() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id, &quot;yu.nai.shuai&quot;);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><ul><li><code>#testSyncSendSuccess()</code> 方法，发送消息的 RoutingKey 是 <code>&quot;da.yu.nai&quot;</code> ，可以匹配到 <code>&quot;DEMO_QUEUE_02&quot;</code> 。</li> <li><code>#testSyncSendFailure()</code> 方法，发送消息的 RoutingKey 是 <code>&quot;yu.nai.shuai&quot;</code> ，无法匹配到 <code>&quot;DEMO_QUEUE_02&quot;</code> 。</li></ul> <p>我们先来执行 <code>#testSyncSendSuccess()</code> 方法，可以匹配到 <code>&quot;DEMO_QUEUE_02&quot;</code> 的情况。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 同步发送消息成功。
2019-12-15 09:35:54.924  INFO 6894 --- [           main] c.i.s.l.r.producer.Demo02ProducerTest    : [testSyncSend][发送编号：[1575941754] 发送成功]

# Demo02Consumer 成功消费了该消息
2019-12-15 09:35:54.941  INFO 6894 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo02Consumer        : [onMessage][线程编号:19 消息内容：Demo02Message{id=1575941754}]
</code></pre></div><ul><li>符合预期。</li></ul> <p>我们再来执行 <code>#testSyncSendFailure()</code> 方法，无法匹配到 <code>&quot;DEMO_QUEUE_02&quot;</code> 的情况。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 同步发送消息成功。
2019-12-15 09:37:11.353  INFO 7186 --- [           main] c.i.s.l.r.producer.Demo02ProducerTest    : [testSyncSend][发送编号：[1575941831] 发送成功]
</code></pre></div><ul><li>符合预期。因为 无法匹配到 <code>&quot;DEMO_QUEUE_02&quot;</code> ，自然 Demo02Consumer 无法进行消费。</li></ul> <h2 id="_3-3-fanout-exchange"><a href="#_3-3-fanout-exchange" class="header-anchor">#</a> 3.3 Fanout Exchange</h2> <p>Fanout Exchange 路由规则非常简单，它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中。如下图：</p> <p><img src="https://raw.githubusercontent.com/lichengcan/images/main/203b64e17bd9e398cf619acb5df98e6b.jpg" alt=""></p> <ul><li>生产者（P）发送到 Exchange（X）的所有消息都会路由到图中的两个 Queue，并最终被两个消费者（C1 与 C2）消费。</li> <li>总结来说，指定 Exchange ，会路由到<strong>多个</strong>绑定的 Queue 中。</li></ul> <p>下面，我们来创建一个 Fanout Exchange 的使用示例，继续在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h3 id="_3-3-1-demo03message"><a href="#_3-3-1-demo03message" class="header-anchor">#</a> 3.3.1 Demo03Message</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo03Message.java" target="_blank" rel="noopener noreferrer">Demo03Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo03Message.java

public class Demo03Message implements Serializable {

    public static final String QUEUE_A = &quot;QUEUE_DEMO_03_A&quot;;
    public static final String QUEUE_B = &quot;QUEUE_DEMO_03_B&quot;;

    public static final String EXCHANGE = &quot;EXCHANGE_DEMO_03&quot;;

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>我们<strong>未</strong>定意思 RoutingKey 的名字。因为，Fanout Exchange 仅需要 Exchange 即可。</li> <li>我们定义<strong>两个</strong> Queue 的名字。因为，我们要测试 Fanout Exchange 投递到多个 Queue 的效果。</li></ul> <h3 id="_3-3-2-rabbitconfig"><a href="#_3-3-2-rabbitconfig" class="header-anchor">#</a> 3.3.2 RabbitConfig</h3> <p>修改 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加 Fanout Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

/**
 * Fanout Exchange 示例的配置类
 */
public static class FanoutExchangeDemoConfiguration {

    // 创建 Queue A
    @Bean
    public Queue demo03QueueA() {
        return new Queue(Demo03Message.QUEUE_A, // Queue 名字
                true, // durable: 是否持久化
                false, // exclusive: 是否排它
                false); // autoDelete: 是否自动删除
    }

    // 创建 Queue B
    @Bean
    public Queue demo03QueueB() {
        return new Queue(Demo03Message.QUEUE_B, // Queue 名字
                true, // durable: 是否持久化
                false, // exclusive: 是否排它
                false); // autoDelete: 是否自动删除
    }

    // 创建 Fanout Exchange
    @Bean
    public FanoutExchange demo03Exchange() {
        return new FanoutExchange(Demo03Message.EXCHANGE,
                true,  // durable: 是否持久化
                false);  // exclusive: 是否排它
    }

    // 创建 Binding A
    // Exchange：Demo03Message.EXCHANGE
    // Queue：Demo03Message.QUEUE_A
    @Bean
    public Binding demo03BindingA() {
        return BindingBuilder.bind(demo03QueueA()).to(demo03Exchange());
    }

    // 创建 Binding B
    // Exchange：Demo03Message.EXCHANGE
    // Queue：Demo03Message.QUEUE_B
    @Bean
    public Binding demo03BindingB() {
        return BindingBuilder.bind(demo03QueueB()).to(demo03Exchange());
    }

}
</code></pre></div><ul><li>在 FanoutExchangeDemoConfiguration 内部静态类中，我们<strong>也是</strong>创建了 Exchange、Queue、Binding 三个 Bean 。有差异点的是，这次我们创建的是 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/FanoutExchange.java" target="_blank" rel="noopener noreferrer">FanoutExchange<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</li> <li>同时，因为我们要投递到两个 Queue 中，所以我们创建了两个 Binding 。</li></ul> <h3 id="_3-3-3-demo03producer"><a href="#_3-3-3-demo03producer" class="header-anchor">#</a> 3.3.3 Demo03Producer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo03Producer.java" target="_blank" rel="noopener noreferrer">Demo03Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo03Producer.java

@Component
public class Demo03Producer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id) {
        // 创建 Demo03Message 消息
        Demo03Message message = new Demo03Message();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(Demo03Message.EXCHANGE, null, message);
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 <code>#syncSend(Integer id)</code> 方法大体相似，差异点在于传入 <code>routingKey = null</code> ，因为不需要。</li></ul> <h3 id="_3-3-4-demo03consumer"><a href="#_3-3-4-demo03consumer" class="header-anchor">#</a> 3.3.4 Demo03Consumer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo03ConsumerA.java" target="_blank" rel="noopener noreferrer">Demo03ConsumerA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo03ConsumerB.java" target="_blank" rel="noopener noreferrer">Demo03ConsumerB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <strong>两个</strong>类，消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo03ConsumerA.java
@Component
@RabbitListener(queues = Demo03Message.QUEUE_A)
public class Demo03ConsumerA {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo03Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}

// Demo03ConsumerB.java
@Component
@RabbitListener(queues = Demo03Message.QUEUE_B)
public class Demo03ConsumerB {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo03Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}
</code></pre></div><ul><li>两个消费者，分别消费 <code>&quot;QUEUE_DEMO_03_A&quot;</code>、<code>&quot;QUEUE_DEMO_03_B&quot;</code> 队列。</li></ul> <h3 id="_3-3-5-简单测试"><a href="#_3-3-5-简单测试" class="header-anchor">#</a> 3.3.5 简单测试</h3> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo03ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo03ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写一个单元测试方法，调用 Demo03Producer 发送消息的方法。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo03ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo03ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo03Producer producer;

    @Test
    public void testSyncSend() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><p>我们先来执行 <code>#testSyncSend()</code> 方法，确认下 Fanout Exchange 的效果。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 同步发送消息成功。
2019-12-15 13:42:51.794  INFO 50616 --- [           main] c.i.s.l.r.producer.Demo03ProducerTest    : [testSyncSend][发送编号：[1575956571] 发送成功]

# Demo03ConsumerA 成功消费了该消息
2019-12-15 13:42:51.811  INFO 50616 --- [ntContainer#2-1] c.i.s.l.r.consumer.Demo03ConsumerA       : [onMessage][线程编号:22 消息内容：Demo03Message{id=1575956571}]

# Demo03ConsumerB 也成功消费了该消息
2019-12-15 13:42:51.811  INFO 50616 --- [ntContainer#3-1] c.i.s.l.r.consumer.Demo03ConsumerB       : [onMessage][线程编号:24 消息内容：Demo03Message{id=1575956571}]
</code></pre></div><ul><li>符合预期。</li> <li>发送的消息，成功投递到了两个队列中，所以被两个消费者都消费到了。</li></ul> <h2 id="_3-4-headers-exchange"><a href="#_3-4-headers-exchange" class="header-anchor">#</a> 3.4 Headers Exchange</h2> <p>Headers Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</p> <ul><li>在绑定 Queue 与 Exchange 时指定一组 headers 键值对。</li> <li>当消息发送到 Exchange 时，RabbitMQ 会取到该消息的 headers（也是一个键值对的形式），对比其中的键值对是否完全匹配 Queue 与 Exchange 绑定时指定的键值对；如果完全匹配则消息会路由到该 Queue ，否则不会路由到该 Queue 。</li></ul> <p>不过艿艿在查询资料的时候，有资料说 Headers Exchange 性能很差，实际场景也使用比较少。所以本小节的内容，胖友可以选择性看。</p> <p>下面，我们来创建一个 Headers Exchange 的使用示例，继续在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h3 id="_3-4-1-demo04message"><a href="#_3-4-1-demo04message" class="header-anchor">#</a> 3.4.1 Demo04Message</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo04Message.java" target="_blank" rel="noopener noreferrer">Demo04Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo03Message.java

public class Demo04Message implements Serializable {

    public static final String QUEUE = &quot;QUEUE_DEMO_04_A&quot;;

    public static final String EXCHANGE = &quot;EXCHANGE_DEMO_04&quot;;

    public static final String HEADER_KEY = &quot;color&quot;;
    public static final String HEADER_VALUE = &quot;red&quot;;

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>我们<strong>未</strong>定意思 RoutingKey 的名字。因为，Headers Exchange 是通过 Exchange + Headers 的组合。</li> <li>我们定义<strong>一个</strong> Headers 键值对，<code>color = red</code> 。</li></ul> <h3 id="_3-4-2-rabbitconfig"><a href="#_3-4-2-rabbitconfig" class="header-anchor">#</a> 3.4.2 RabbitConfig</h3> <p>修改 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加 Headers Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

/**
 * Headers Exchange 示例的配置类
 */
public static class HeadersExchangeDemoConfiguration {

    // 创建 Queue
    @Bean
    public Queue demo04Queue() {
        return new Queue(Demo04Message.QUEUE, // Queue 名字
                true, // durable: 是否持久化
                false, // exclusive: 是否排它
                false); // autoDelete: 是否自动删除
    }

    // 创建 Headers Exchange
    @Bean
    public HeadersExchange demo04Exchange() {
        return new HeadersExchange(Demo04Message.EXCHANGE,
                true,  // durable: 是否持久化
                false);  // exclusive: 是否排它
    }

    // 创建 Binding
    // Exchange：Demo04Message.EXCHANGE
    // Queue：Demo04Message.QUEUE
    // Headers: Demo04Message.HEADER_KEY + Demo04Message.HEADER_VALUE
    @Bean
    public Binding demo4Binding() {
        return BindingBuilder.bind(demo04Queue()).to(demo04Exchange())
                .where(Demo04Message.HEADER_KEY).matches(Demo04Message.HEADER_VALUE); // 配置 Headers 匹配
    }

}
</code></pre></div><ul><li>在 TopicExchangeDemoConfiguration 内部静态类中，我们<strong>也是</strong>创建了 Exchange、Queue、Binding 三个 Bean 。有差异点的是，这次我们创建的是 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/HeadersExchange.java" target="_blank" rel="noopener noreferrer">HeadersExchange<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</li> <li>同时，我们创建的 Binding 是基于 Headers 匹配。</li></ul> <h3 id="_3-4-3-demo04producer"><a href="#_3-4-3-demo04producer" class="header-anchor">#</a> 3.4.3 Demo04Producer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo04Producer.java" target="_blank" rel="noopener noreferrer">Demo04Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo02Producer.java

@Component
public class Demo04Producer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id, String headerValue) {
        // 创建 MessageProperties 属性
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setHeader(Demo04Message.HEADER_KEY, headerValue); // 设置 header
        // 创建 Message 消息
        Message message = rabbitTemplate.getMessageConverter().toMessage(
                new Demo04Message().setId(id), messageProperties);
        // 同步发送消息
        rabbitTemplate.send(Demo04Message.EXCHANGE, null, message);
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 <code>#syncSend(Integer id)</code> 方法大体相似，差异点在于新增了方法参数 <code>headerValue</code> ，方便我们传入不同的 Headers 值。</li> <li>因为 RabbitTemplate 会提供很方便的传递 Headers 的 API 方法，所以我们只好自己构建，当然也比较简单哈。</li></ul> <h3 id="_3-4-4-demo04consumer"><a href="#_3-4-4-demo04consumer" class="header-anchor">#</a> 3.4.4 Demo04Consumer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo04Consumer.java" target="_blank" rel="noopener noreferrer">Demo04Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.7 Demo01Consumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>基本一致，差别在于消费的队列是 <code>&quot;QUEUE_DEMO_04&quot;</code> 。</p> <h3 id="_3-4-5-简单测试"><a href="#_3-4-5-简单测试" class="header-anchor">#</a> 3.4.5 简单测试</h3> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo04ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo04ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写两个单元测试方法，调用 Demo04Producer 发送消息的方法。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo04ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo04ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo04Producer producer;

    @Test
    public void testSyncSendSuccess() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id, Demo04Message.HEADER_VALUE);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

    @Test
    public void testSyncSendFailure() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id, &quot;error&quot;);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><ul><li><code>#testSyncSendSuccess()</code> 方法，发送消息的 Headers 的值 <code>&quot;red&quot;</code> ，可以匹配到 <code>&quot;DEMO_QUEUE_04&quot;</code> 。</li> <li><code>#testSyncSendFailure()</code> 方法，发送消息的 Headers 的值 <code>&quot;error&quot;</code> ，无法匹配到 <code>&quot;DEMO_QUEUE_04&quot;</code> 。</li></ul> <p>我们先来执行 <code>#testSyncSendSuccess()</code> 方法，可以匹配到 <code>&quot;DEMO_QUEUE_04&quot;</code> 的情况。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 同步发送消息成功。
2019-12-15 14:30:05.872  INFO 61498 --- [           main] c.i.s.l.r.producer.Demo04ProducerTest    : [testSyncSend][发送编号：[1575959405] 发送成功]

# Demo04Consumer 成功消费了该消息
2019-12-15 14:30:05.888  INFO 61498 --- [ntContainer#4-1] c.i.s.l.r.consumer.Demo04Consumer        : [onMessage][线程编号:25 消息内容：Demo04Message{id=1575959405}]
</code></pre></div><ul><li>符合预期。</li></ul> <p>我们再来执行 <code>#testSyncSendFailure()</code> 方法，无法匹配到 <code>&quot;DEMO_QUEUE_04&quot;</code> 的情况。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 同步发送消息成功。
2019-12-15 14:30:47.090  INFO 61664 --- [           main] c.i.s.l.r.producer.Demo04ProducerTest    : [testSyncSend][发送编号：[1575959447] 发送成功]
</code></pre></div><ul><li>符合预期。因为 无法匹配到 <code>&quot;DEMO_QUEUE_04&quot;</code> ，自然 Demo04Consumer 无法进行消费。</li></ul> <h1 id="_4-批量发送消息"><a href="#_4-批量发送消息" class="header-anchor">#</a> 4. 批量发送消息</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-batch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p></blockquote> <p>在一些业务场景下，我们希望使用 Producer 批量发送消息，提高发送性能。不同于我们在<a href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 消息队列 RocketMQ 入门》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4. 批量发送消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 功能，RocketMQ 是提供了一个可以批量发送多条消息的 API 。而 Spring-AMQP 提供的批量发送消息，它提供了一个 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/MessageBatch.java" target="_blank" rel="noopener noreferrer">MessageBatch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息收集器，将发送给<strong>相同 Exchange + RoutingKey 的消息们</strong>，“<strong>偷偷</strong>”收集在一起，当满足条件时候，一次性批量发送提交给 RabbitMQ Broker 。</p> <p>Spring-AMQP 通过 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/BatchingRabbitTemplate.java" target="_blank" rel="noopener noreferrer">BatchingRabbitTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 提供批量发送消息的功能。如下是三个条件，满足<strong>任一</strong>即会批量发送：</p> <ul><li>【数量】<code>batchSize</code> ：超过收集的消息数量的最大条数。</li> <li>【空间】<code>bufferLimit</code> ：超过收集的消息占用的最大内存。</li> <li>【时间】<code>timeout</code> ：超过收集的时间的最大等待时长，单位：毫秒。😈 不过要注意，这里的超时开始计时的时间，是<strong>以最后一次发送时间为起点</strong>。也就说，每调用一次发送消息，都以当前时刻开始计时，重新到达 <code>timeout</code> 毫秒才算超时。</li></ul> <p>另外，BatchingRabbitTemplate 提供的批量发送消息的能力<strong>比较弱</strong>。对于同一个 BatchingRabbitTemplate 对象来说，<strong>同一时刻只能有一个批次(保证 Exchange + RoutingKey 相同)</strong>，否则会报错。</p> <p>下面，我们来实现一个 Producer 批量发送消息的示例。考虑到不污染<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3. 快速入门」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-batch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_4-1-引入依赖"><a href="#_4-1-引入依赖" class="header-anchor">#</a> 4.1 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_4-2-应用配置文件"><a href="#_4-2-应用配置文件" class="header-anchor">#</a> 4.2 应用配置文件</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_4-3-demo05message"><a href="#_4-3-demo05message" class="header-anchor">#</a> 4.3 Demo05Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo05Message.java" target="_blank" rel="noopener noreferrer">Demo05Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_4-4-rabbitconfig"><a href="#_4-4-rabbitconfig" class="header-anchor">#</a> 4.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加 BatchingRabbitTemplate 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Configuration
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo05Queue() {
            return new Queue(Demo05Message.QUEUE, // Queue 名字
                    true, // durable: 是否持久化
                    false, // exclusive: 是否排它
                    false); // autoDelete: 是否自动删除
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo05Exchange() {
            return new DirectExchange(Demo05Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        // Exchange：Demo05Message.EXCHANGE
        // Routing key：Demo05Message.ROUTING_KEY
        // Queue：Demo05Message.QUEUE
        @Bean
        public Binding demo05Binding() {
            return BindingBuilder.bind(demo05Queue()).to(demo05Exchange()).with(Demo05Message.ROUTING_KEY);
        }

    }

    @Bean
    public BatchingRabbitTemplate batchRabbitTemplate(ConnectionFactory connectionFactory) {
        // 创建 BatchingStrategy 对象，代表批量策略
        int batchSize = 16384; // 超过收集的消息数量的最大条数。
        int bufferLimit = 33554432; // 每次批量发送消息的最大内存
        int timeout = 30000; // 超过收集的时间的最大等待时长，单位：毫秒
        BatchingStrategy batchingStrategy = new SimpleBatchingStrategy(batchSize, bufferLimit, timeout);

        // 创建 TaskScheduler 对象，用于实现超时发送的定时器
        TaskScheduler taskScheduler = new ConcurrentTaskScheduler();

        // 创建 BatchingRabbitTemplate 对象
        BatchingRabbitTemplate batchTemplate = new BatchingRabbitTemplate(batchingStrategy, taskScheduler);
        batchTemplate.setConnectionFactory(connectionFactory);
        return batchTemplate;
    }

}
</code></pre></div><ul><li><p>DirectExchangeDemoConfiguration 配置类，用于定义 Queue、Exchange、Binding 的配置。</p></li> <li><div class="language- extra-class"><pre class="language-text"><code>#batchRabbitTemplate(ConnectionFactory connectionFactory)
</code></pre></div><p>方法，创建 BatchingRabbitTemplate Bean 对象。</p> <ul><li>具体的 <code>batchSize</code>、<code>bufferLimit</code>、<code>timeout</code> 数值配置多少，根据自己的应用来。这里，我们故意将 <code>timeout</code> 配置成了 30 秒，主要为了演示之用。</li> <li>创建 BatchingRabbitTemplate 对象的代码，艿艿已经添加注释，可以自己阅读理解下噢。</li></ul></li></ul> <h2 id="_4-5-demo05producer"><a href="#_4-5-demo05producer" class="header-anchor">#</a> 4.5 Demo05Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo05Producer.java" target="_blank" rel="noopener noreferrer">Demo05Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 BatchingRabbitTemplate ，实现批量发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo05Producer.java

@Component
public class Demo05Producer {

    @Autowired
    private BatchingRabbitTemplate batchingRabbitTemplate;

    public void syncSend(Integer id) {
        // 创建 Demo05Message 消息
        Demo05Message message = new Demo05Message();
        message.setId(id);
        // 同步发送消息
        batchingRabbitTemplate.convertAndSend(Demo05Message.EXCHANGE, Demo05Message.ROUTING_KEY, message);
    }

}
</code></pre></div><ul><li>看起来和我们在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>提供的发送消息的方法，除了换成了 BatchingRabbitTemplate 来发送消息，其它都是一致的。😈 对的，这也是为什么艿艿在上文说到，Spring-AMQP 是“<strong>偷偷</strong>”收集来实现批量发送，对于我们使用发送消息的方法，还是一致的。</li></ul> <p>BatchingRabbitTemplate 通过重写 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/BatchingRabbitTemplate.java#L76-L99" target="_blank" rel="noopener noreferrer"><code>#send(String exchange, String routingKey, Message message, CorrelationData correlationData)</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <strong>核心</strong>方法，实现批量发送的功能。感兴趣的胖友，可以自己去研究下源码，不复杂哈~</p> <h2 id="_4-6-demo05consumer"><a href="#_4-6-demo05consumer" class="header-anchor">#</a> 4.6 Demo05Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo05Consumer.java" target="_blank" rel="noopener noreferrer">Demo05Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo05Consumer.java

@Component
@RabbitListener(queues = Demo05Message.QUEUE)
public class Demo05Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo05Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.7 Demo01Consumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>基本一致，差别在于消费的队列是 <code>&quot;QUEUE_DEMO_02&quot;</code> 。</li></ul> <h2 id="_4-7-简单测试"><a href="#_4-7-简单测试" class="header-anchor">#</a> 4.7 简单测试</h2> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo05ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo05ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写单元测试方法，测试 Producer 批量发送消息的效果。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo05ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo05ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo05Producer producer;

    @Test
    public void testSyncSend() throws InterruptedException {
        for (int i = 0; i &lt; 3; i++) {
            // 同步发送消息
            int id = (int) (System.currentTimeMillis() / 1000);
            producer.syncSend(id);

            // 故意每条消息之间，隔离 10 秒
            logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);
            Thread.sleep(10 * 1000L);
        }

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><ul><li>同步发送三条消息，每次发送消息之间，都故意 sleep 10 秒。😈 目的是，恰好满足我们配置的 <code>timeout</code> 最大等待时长。</li></ul> <p>我们来执行 <code>#testASyncSend()</code> 方法，测试批量发送消息。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 成功同步发送了 3 条消息，每条间隔 10 秒。
2019-12-15 16:50:15.419  INFO 94085 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575967815] 发送成功]
2019-12-15 16:50:25.426  INFO 94085 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575967825] 发送成功]
2019-12-15 16:50:35.427  INFO 94085 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575967835] 发送成功]

// Demo05Consumer 在最后一条消息发送成功后果的 30 秒，消费到这 3 条消息。
2019-12-15 16:51:05.449  INFO 94085 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息内容：Demo05Message{id=1575967815}]
2019-12-15 16:51:05.450  INFO 94085 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息内容：Demo05Message{id=1575967825}]
2019-12-15 16:51:05.450  INFO 94085 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息内容：Demo05Message{id=1575967835}]
</code></pre></div><ul><li>因为使用 BatchingRabbitTemplate 批量发送消息，所以在 Producer 成功发送完第一条消息后，Consumer 并未消费到这条消息。</li> <li>又因为 BatchingRabbitTemplate 是按照每次发送后，都重新计时，所以在最后一条消息成功发送后的 30 秒，Consumer 才消费到批量发送的 3 条消息。</li></ul> <h1 id="_5-批量消费消息"><a href="#_5-批量消费消息" class="header-anchor">#</a> 5. 批量消费消息</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-batch-consume<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4. 批量发送消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>小节，我们已经实现批量发送消息到 RabbitMQ Broker 中。那么，我们来思考一个问题，这批消息在 RabbitMQ Broker 到底是存储<strong>一条</strong>消息，还是<strong>多条</strong>消息？</p> <ul><li>如果胖友使用过 Kafka、RocketMQ 这两个消息队列，那么判断肯定会是<strong>多条</strong>消息。</li> <li>从<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4.6 Demo05Consumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，我们可以看到<strong>逐条</strong>消息的消费，也会认为是<strong>多条</strong>消息。</li></ul> <p>😭 实际上，RabbitMQ Broker 存储的是<strong>一条</strong>消息。又或者说，<strong>RabbitMQ 并没有提供批量接收消息的 API 接口</strong>。</p> <p>那么，为什么我们在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4. 批量发送消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>能够实现呢？答案是批量发送消息是 Spring-AMQP 的 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java" target="_blank" rel="noopener noreferrer">SimpleBatchingStrategy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 所封装提供：</p> <ul><li>在 Producer 最终批量发送消息时，SimpleBatchingStrategy 会通过 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java#L141-L156" target="_blank" rel="noopener noreferrer"><code>#assembleMessage()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法，将批量发送的<strong>多条</strong>消息<strong>组装</strong>成一条“批量”消息，然后进行发送。</li> <li>在 Consumer 拉取到消息时，会根据<a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java#L158-L163" target="_blank" rel="noopener noreferrer"><code>#canDebatch(MessageProperties properties)</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法，判断该消息是否为一条“批量”消息？如果是，则调用<a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/batch/SimpleBatchingStrategy.java#L165-L194" target="_blank" rel="noopener noreferrer"><code># deBatch(Message message, Consumer fragmentConsumer)</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法，将一条“批量”消息<strong>拆开</strong>，变成<strong>多条</strong>消息。</li></ul> <blockquote><p>这个操作，是不是略微有点骚气？！艿艿在这里卡了很久！！！莫名其妙的~一直以为，RabbitMQ 提供了批量发送消息的 API 接口啊。</p> <p>OK ，虽然很悲伤，但是我们还是回到这个小节的主题。</p></blockquote> <p>在一些业务场景下，我们希望使用 Consumer 批量消费消息，提高消费速度。在 Spring-AMQP 中，提供了两种批量消费消息的方式。本小节，我们先来看第一种，它需要基于<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4. 批量发送消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>之上实现。</p> <p>在 SimpleBatchingStrategy 将一条“批量”消息拆开，变成多条消息后，直接<strong>批量</strong>交给 Consumer 进行消费处理。</p> <p>下面，我们来实现一个 Consumer 批量消费消息的示例。考虑到不污染<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4. 批量发送消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的示例，我们在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-batch<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目的基础上，复制出一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-batch-consume<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。😈 酱紫，我们也能少写点代码，哈哈哈~</p> <h2 id="_5-1-rabbitconfig"><a href="#_5-1-rabbitconfig" class="header-anchor">#</a> 5.1 RabbitConfig</h2> <p>修改 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加自定义的 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/config/SimpleRabbitListenerContainerFactory.java" target="_blank" rel="noopener noreferrer">SimpleRabbitListenerContainerFactory<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Bean ，支持用于创建<strong>支持批量消费</strong>的 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java" target="_blank" rel="noopener noreferrer">SimpleRabbitListenerContainer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Bean(name = &quot;consumerBatchContainerFactory&quot;)
public SimpleRabbitListenerContainerFactory consumerBatchContainerFactory(
        SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {
    // 创建 SimpleRabbitListenerContainerFactory 对象
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    configurer.configure(factory, connectionFactory);
    // &lt;X&gt; 额外添加批量消费的属性
    factory.setBatchListener(true);
    return factory;
}
</code></pre></div><ul><li>在 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAnnotationDrivenConfiguration.java" target="_blank" rel="noopener noreferrer">RabbitAnnotationDrivenConfiguration<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 自动化配置类中，它会默认创建一个名字为 <code>&quot;rabbitListenerContainerFactory&quot;</code> 的 SimpleRabbitListenerContainerFactory Bean ，可用于消费者的监听器是<strong>单个</strong>消费消费的。</li> <li>我们自定义创建的一个名字为<code>&quot;consumerBatchContainerFactory&quot;</code> 的 SimpleRabbitListenerContainerFactory Bean ，可用于消费者的监听器是<strong>批量</strong>消费消费的。重点是 <code>&lt;X&gt;</code> 处，配置消费者的监听器是<strong>批量</strong>消费消息的类型，其它的可以暂时不用理解。</li></ul> <h2 id="_5-2-demo05consumer"><a href="#_5-2-demo05consumer" class="header-anchor">#</a> 5.2 Demo05Consumer</h2> <p>修改 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo05Consumer.java" target="_blank" rel="noopener noreferrer">Demo05Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，<strong>批量</strong>消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo05Consumer.java

@Component
@RabbitListener(queues = Demo05Message.QUEUE,
    containerFactory = &quot;consumerBatchContainerFactory&quot;)
public class Demo05Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(List&lt;Demo05Message&gt; messages) {
        logger.info(&quot;[onMessage][线程编号:{} 消息数量：{}]&quot;, Thread.currentThread().getId(), messages.size());
    }

}
</code></pre></div><ul><li>在类上的 <code>@@RabbitListener</code> 注解的 <code>containerFactory</code> 属性，设置了我们在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「5.1 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>创建的 SimpleRabbitListenerContainerFactory Bean ，表示它要批量消费消息。</li> <li>在 <code>#onMessage(...)</code> 消费方法上，修改方法入参的类型为 List 数组。</li></ul> <h2 id="_5-3-简单测试"><a href="#_5-3-简单测试" class="header-anchor">#</a> 5.3 简单测试</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4.7 简单测试」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo05ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo05ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 单元测试类。</p> <p>我们来执行 <code>#testASyncSend()</code> 方法，测试批量消费消息。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 成功同步发送了 3 条消息，每条间隔 10 秒。
2019-12-15 22:42:08.755  INFO 60216 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575988928] 发送成功]
2019-12-15 22:42:18.757  INFO 60216 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575988938] 发送成功]
2019-12-15 22:42:28.758  INFO 60216 --- [           main] c.i.s.l.r.producer.Demo05ProducerTest    : [testSyncSend][发送编号：[1575988948] 发送成功]

// Demo05Consumer 在最后一条消息发送成功后果的 30 秒，一次性批量消费了这 3 条消息。
2019-12-15 22:42:58.775  INFO 60216 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo05Consumer        : [onMessage][线程编号:17 消息数量：3]
</code></pre></div><ul><li>符合预期，Demo05Consumer 批量消费了 3 条消息。</li></ul> <h1 id="_6-批量消费消息-第二弹"><a href="#_6-批量消费消息-第二弹" class="header-anchor">#</a> 6. 批量消费消息（第二弹）</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-batch-consume-02<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「5. 批量消费消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>小节，我们已经学习了一种批量消费消息的方式。因为其依赖<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「4. 批量发送消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的功能，有点过于苛刻。所以，Spring-AMQP 提供了第二种批量消费消息的方式。</p> <p>其实现方式是，阻塞等待最多 <code>receiveTimeout</code> 秒，拉取 <code>batchSize</code> 条消息，进行批量消费。</p> <ul><li>如果在 <code>receiveTimeout</code> 秒内已经成功拉取到 <code>batchSize</code> 条消息，则直接进行批量消费消息。</li> <li>如果在 <code>receiveTimeout</code> 秒还没拉取到 <code>batchSize</code> 条消息，不再等待，而是进行批量消费消息。</li></ul> <p>不过 Spring-AMQP 的阻塞等待时长 <code>receiveTimeout</code> 的设计有点“神奇”。</p> <ul><li>它代表的是，每次拉取一条消息，最多阻塞等待 <code>receiveTimeout</code> 时长。如果等待不到下一条消息，则进入已获取到的消息的批量消费。😈 也就是说，极端情况下，可能等待 <code>receiveTimeout * batchSize</code> 时长，才会进行批量消费。</li> <li>感兴趣的朋友，可以点击 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java#L922" target="_blank" rel="noopener noreferrer"><code>SimpleMessageListenerContainer#doReceiveAndExecute(BlockingQueueConsumer consumer)</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法，简单阅读源码，即可快速理解。</li></ul> <p>下面，我们来实现一个 Consumer 批量消费消息的示例。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-batch-consume-02<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_6-1-引入依赖"><a href="#_6-1-引入依赖" class="header-anchor">#</a> 6.1 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_6-2-应用配置文件"><a href="#_6-2-应用配置文件" class="header-anchor">#</a> 6.2 应用配置文件</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_6-3-demo06message"><a href="#_6-3-demo06message" class="header-anchor">#</a> 6.3 Demo06Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo06Message.java" target="_blank" rel="noopener noreferrer">Demo06Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_6-4-rabbitconfig"><a href="#_6-4-rabbitconfig" class="header-anchor">#</a> 6.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加自定义的 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/config/SimpleRabbitListenerContainerFactory.java" target="_blank" rel="noopener noreferrer">SimpleRabbitListenerContainerFactory<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Bean ，支持用于创建<strong>支持批量消费</strong>的 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java" target="_blank" rel="noopener noreferrer">SimpleRabbitListenerContainer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Configuration
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo06Queue() {
            return new Queue(Demo06Message.QUEUE, // Queue 名字
                    true, // durable: 是否持久化
                    false, // exclusive: 是否排它
                    false); // autoDelete: 是否自动删除
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo06Exchange() {
            return new DirectExchange(Demo06Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        // Exchange：Demo06Message.EXCHANGE
        // Routing key：Demo06Message.ROUTING_KEY
        // Queue：Demo06Message.QUEUE
        @Bean
        public Binding demo06Binding() {
            return BindingBuilder.bind(demo06Queue()).to(demo06Exchange()).with(Demo06Message.ROUTING_KEY);
        }

    }

    @Bean(name = &quot;consumerBatchContainerFactory&quot;)
    public SimpleRabbitListenerContainerFactory consumerBatchContainerFactory(
            SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {
        // 创建 SimpleRabbitListenerContainerFactory 对象
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        // 额外添加批量消费的属性
        factory.setBatchListener(true);
        // &lt;X&gt;
        factory.setBatchSize(10);
        factory.setReceiveTimeout(30 * 1000L);
        factory.setConsumerBatchEnabled(true);
        return factory;
    }

}
</code></pre></div><ul><li>DirectExchangeDemoConfiguration 配置类，用于定义 Queue、Exchange、Binding 的配置。</li> <li>相比<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「5.1 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来说，额外增加了 <code>batchSize = 10</code>、<code>receiveTimeout = 30 * 1000L</code>、<code>consumerBatchEnabled = 30 * 1000L</code> 属性。😈 严格意义上来说，<strong>本小节才是真正意义上的批量消费消息</strong>。</li></ul> <h2 id="_6-5-demo06producer"><a href="#_6-5-demo06producer" class="header-anchor">#</a> 6.5 Demo06Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo06Producer.java" target="_blank" rel="noopener noreferrer">Demo06Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、RoutingKey 名字不同。</p> <h2 id="_6-6-demo06consumer"><a href="#_6-6-demo06consumer" class="header-anchor">#</a> 6.6 Demo06Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo05Consumer.java" target="_blank" rel="noopener noreferrer">Demo05Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，<strong>批量</strong>消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo06Consumer.java

@Component
@RabbitListener(queues = Demo06Message.QUEUE,
    containerFactory = &quot;consumerBatchContainerFactory&quot;)
public class Demo06Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(List&lt;Demo06Message&gt; messages) {
        logger.info(&quot;[onMessage][线程编号:{} 消息数量：{}]&quot;, Thread.currentThread().getId(), messages.size());
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「5.2 Demo05Consumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只差在消费不同的队列。</li></ul> <h2 id="_6-7-简单测试"><a href="#_6-7-简单测试" class="header-anchor">#</a> 6.7 简单测试</h2> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo06ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo06ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写单元测试方法，测试 Consumer 批量消费消息的效果。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo06ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo06ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo06Producer producer;

    @Test
    public void testSyncSend01() throws InterruptedException {
        // 发送 3 条消息
        this.testSyncSend(3);
    }

    @Test
    public void testSyncSen02() throws InterruptedException {
        // 发送 10 条消息
        this.testSyncSend(10);
    }

    private void testSyncSend(int n) throws InterruptedException {
        for (int i = 0; i &lt; n; i++) {
            // 同步发送消息
            int id = (int) (System.currentTimeMillis() / 1000);
            producer.syncSend(id);
            logger.info(&quot;[testSyncSendMore][发送编号：[{}] 发送成功]&quot;, id);
        }

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><ul><li><code>#testSyncSend01()</code> 方法，发送 3 条消息，测试 Demo06Consumer 获取数量为 <code>batchSize = 10</code> 消息，<strong>超时</strong>情况下的批量消费。</li> <li><code>#testSyncSend02()</code> 方法，发送 10 条消息，测试 Demo06Consumer 获取数量为 <code>batchSize = 10</code> 消息，<strong>未超时</strong>情况下的批量消费。</li></ul> <p>我们来执行 <code>#testSyncSend01()</code> 方法，<strong>超时</strong>情况下的批量消费。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 成功同步发送了 3 条消息
2019-12-15 00:01:18.097  INFO 78389 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993678] 发送成功]
2019-12-15 00:01:18.099  INFO 78389 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993678] 发送成功]
2019-12-15 00:01:18.099  INFO 78389 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993678] 发送成功]

// Consumer 30 秒超时等待后，批量消费到 3 条消息
2019-12-15 00:01:48.116  INFO 78389 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo06Consumer        : [onMessage][线程编号:17 消息数量：3]
</code></pre></div><ul><li>符合预期。具体胖友看下日志上的注释说明。</li></ul> <p>我们来执行 <code>#testSyncSend02()</code> 方法，<strong>未超时</strong>情况下的批量消费。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 成功同步发送了 10 条消息
2019-12-15 00:03:50.406  INFO 78997 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993830] 发送成功]
// ... 省略 8 条消息
2019-12-15 00:03:50.410  INFO 78997 --- [           main] c.i.s.l.r.producer.Demo06ProducerTest    : [testSyncSendMore][发送编号：[1575993830] 发送成功]

// Consumer 拉取到 10 条消息后，立即批量消费到 10 条消息
2019-12-15 00:03:50.429  INFO 78997 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo06Consumer        : [onMessage][线程编号:17 消息数量：10
</code></pre></div><ul><li>符合预期。具体胖友看下日志上的注释说明。</li></ul> <p>😈 至此，我们已经完成了两种 Spring-AMQP 的批量消费消费的方法。更多的内容，可以看看 <a href="https://docs.spring.io/spring-amqp/docs/current/reference/html/#receiving-batch" target="_blank" rel="noopener noreferrer">《Spring-AMQP 官方文档 —— @RabbitListener with Batching》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文档。</p> <h2 id="有个小坑"><a href="#有个小坑" class="header-anchor">#</a> 有个小坑</h2> <p>RabbitMQ 批量消费是基于缓冲区的，且需要在同一线程下。</p> <p>经过测试当发送的数据是10条时，mq分了两个线程去消费：28号线程消费5个，25号线程消费5个，这个时候不会触发BatchSize，也就是仍然需要等到超时了才会消费。</p> <p><img src="https://raw.githubusercontent.com/lichengcan/images/main/image-20231213145544351.png" alt=""></p> <p><img src="https://raw.githubusercontent.com/lichengcan/images/main/image-20231213145556000.png" alt=""></p> <h1 id="_7-消费重试"><a href="#_7-消费重试" class="header-anchor">#</a> 7. 消费重试</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-consume-retry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>在开始本小节之前，胖友首先要对 RabbitMQ 的<a href="https://www.rabbitmq.com/dlx.html" target="_blank" rel="noopener noreferrer">死信队列<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的机制，有一定的了解。不了解的胖友，可以看看<a href="http://www.iocoder.cn/RabbitMQ/dead-letter-queue/?self" target="_blank" rel="noopener noreferrer">《RabbitMQ 之死信队列》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文章。</p> <p>在消息<strong>消费失败</strong>的时候，Spring-AMQP 会通过<strong>消费重试</strong>机制，重新投递该消息给 Consumer ，让 Consumer 有机会重新消费消息，实现消费成功。</p> <p>当然，Spring-AMQP 并不会无限重新投递消息给 Consumer 重新消费，而是在默认情况下，达到 N 次重试次数时，Consumer 还是消费失败时，该消息就会进入到<strong>死信队列</strong>。后续，我们可以通过对死信队列中的消息进行重发，来使得消费者实例再次进行消费。</p> <ul><li>在<a href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 消息队列 RocketMQ 入门》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「6. 消费重试」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>小节中，我们可以看到，消费重试和死信队列，是 RocketMQ 自带的功能。</li> <li>而在 RabbitMQ 中，消费重试是由 Spring-AMQP 所封装提供的，死信队列是 RabbitMQ 自带的功能。</li></ul> <p>那么消费失败到达最大次数的消息，是怎么进入到死信队列的呢？Spring-AMQP 在消息到达最大消费次数的时候，会将该消息进行否定(<code>basic.nack</code>)，并且 <code>requeue=false</code> ，这样后续就可以利用 RabbitMQ 的<a href="https://www.rabbitmq.com/dlx.html" target="_blank" rel="noopener noreferrer">死信队列<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的机制，将该消息转发到死信队列。</p> <p>另外，每条消息的失败重试，是可以配置一定的<strong>间隔时间</strong>。具体，我们在示例的代码中，来进行具体的解释。</p> <p>下面，我们来实现一个 Consumer 消费重试的示例。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-consume-retry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_7-1-引入依赖"><a href="#_7-1-引入依赖" class="header-anchor">#</a> 7.1 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_7-2-应用配置文件"><a href="#_7-2-应用配置文件" class="header-anchor">#</a> 7.2 应用配置文件</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/resources" target="_blank" rel="noopener noreferrer"><code>resources</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 目录下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置文件。配置如下：</p> <div class="language- extra-class"><pre class="language-text"><code>spring:
  # RabbitMQ 配置项，对应 RabbitProperties 配置类
  rabbitmq:
    host: 127.0.0.1 # RabbitMQ 服务的地址
    port: 5672 # RabbitMQ 服务的端口
    username: guest # RabbitMQ 服务的账号
    password: guest # RabbitMQ 服务的密码
    listener:
      simple:
        # 对应 RabbitProperties.ListenerRetry 类
        retry:
          enabled: true # 开启消费重试机制
          max-attempts: 3 # 最大重试次数。默认为 3 。
          initial-interval: 1000 # 重试间隔，单位为毫秒。默认为 1000 。
</code></pre></div><ul><li><p>相比<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来说，我们通过<strong>新增</strong> <code>spring.rabbitmq.simple.retry.enable=true</code> 配置项，来开启 Spring-AMQP 的消费重试的功能。同时，通过<strong>新增</strong> <code>max-attempts</code> 和 <code>initial-interval</code> 配置项，设置重试次数和间隔。</p> <blockquote><p><code>max-attempts</code> 配置项要注意，是一条消息一共尝试消费总共 <code>max-attempts</code> 次，包括首次的正常消费。</p></blockquote></li> <li><p>另外，胖友可以通过添加 <code>spring.rabbitmq.listener.simple.retry.multiplier</code> 配置项来实现<strong>递乘</strong>的时间间隔，添加 <code>spring.rabbitmq.listener.simple.retry.max-interval</code> 配置项来实现<strong>最大</strong>的时间间隔。</p></li></ul> <p>在 Spring-AMQP 的消费重试机制中，在消费失败到达最大次数后，会<strong>自动</strong>抛出 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/AmqpRejectAndDontRequeueException.java" target="_blank" rel="noopener noreferrer">AmqpRejectAndDontRequeueException<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 异常，从而结束该消息的消费重试。这意味着什么呢？如果我们在消费消息的逻辑中，<strong>主动</strong>抛出 AmqpRejectAndDontRequeueException 异常，也能结束该消息的消费重试。😈 结束的方式，Spring-AMQP 是通过我们在上文中提到的 <code>basic.nack</code> + <code>requeue=false</code> ，从而实现转发该消息到死信队列中。</p> <p>另外，默认情况下，<code>spring.rabbitmq.simple.retry.enable=false</code> ，关闭 Spring-AMQP 的消费重试功能。但是实际上，消费发生异常的消息，还是会一直<strong>重新消费</strong>。这是为什么呢？Spring-AMQP 会将该消息通过 <code>basic.nack</code> + <code>requeue=true</code> ，重新投递回<strong>原队列的尾巴</strong>。如此，我们便会不断拉取到该消息，不断“重试”消费该消息。当然在这种情况下，我们一样可以<strong>主动</strong>抛出 AmqpRejectAndDontRequeueException 异常，也能结束该消息的消费重试。😈 结束的方式，Spring-AMQP 也是通过我们在上文中提到的 <code>basic.nack</code> + <code>requeue=false</code> ，从而实现转发该消息到死信队列中。</p> <p>这里，我们再来简单说说 Spring-AMQP 是怎么提供<strong>消费重试</strong>的功能的。</p> <ul><li><p>Spring-AMQP 基于 <a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="noopener noreferrer">spring-retry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目提供的 <a href="https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/support/RetryTemplate.java" target="_blank" rel="noopener noreferrer">RetryTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，实现重试功能。Spring-AMQP 在获取到消息时，会交给 RetryTemplate 来调用消费者 Consumer 的监听器 Listener(就是我们实现的)，实现该消息的<strong>多次</strong>消费重试。</p></li> <li><p>在该消息的<strong>每次消费失败</strong>后，RetryTemplate 会通过 <a href="https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/backoff/BackOffPolicy.java" target="_blank" rel="noopener noreferrer">BackOffPolicy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来进行计算，该消息的<strong>下一次重新消费的时间</strong>，通过 <code>Thread#sleep(...)</code> 方法，实现重新消费的时间间隔。到达时间间隔后，RetryTemplate 又会调用消费者 Consumer 的监听器 Listener 来消费该消息。</p></li> <li><p>当该消息的重试消费到达<strong>上限</strong>后，RetryTemplate 会调用 <a href="https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/interceptor/MethodInvocationRecoverer.java" target="_blank" rel="noopener noreferrer">MethodInvocationRecoverer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 回调来实现恢复。而 Spring-AMQP 自定义实现了 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/retry/RejectAndDontRequeueRecoverer.java" target="_blank" rel="noopener noreferrer">RejectAndDontRequeueRecoverer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来<strong>自动</strong>抛出 AmqpRejectAndDontRequeueException 异常，从而结束该消息的消费重试。😈 结束的方式，Spring-AMQP 是通过我们在上文中提到的 <code>basic.nack</code> + <code>requeue=false</code> ，从而实现转发该消息到死信队列中。</p></li> <li><p>有一点需要注意，Spring-AMQP 提供的消费重试的<strong>计数</strong>是<strong>客户端</strong>级别的，重启 JVM 应用后，计数是会丢失的。所以，如果想要计数进行持久化，需要自己重新实现下。</p> <blockquote><p>😈 RocketMQ 提供的消费重试的计数，目前是<strong>服务端</strong>级别，已经进行持久化。</p></blockquote></li></ul> <blockquote><p>😜 瞎哔哔了好长一段，涉及到的信息量可能比较大，如果艿艿有解释不清晰或者错误的地方，又或者哪里不了解，可以给艿艿留言，乐意之至为胖友解答。</p> <p>同时，也可以调试下整个过程涉及到的源码，更加具象下。「源码之前，了无秘密」。</p></blockquote> <h2 id="_7-3-demo07message"><a href="#_7-3-demo07message" class="header-anchor">#</a> 7.3 Demo07Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo07Message.java" target="_blank" rel="noopener noreferrer">Demo07Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo07Message.java


    public static final String QUEUE = &quot;QUEUE_DEMO_07&quot;; // 正常队列
    public static final String DEAD_QUEUE = &quot;DEAD_QUEUE_DEMO_07&quot;; // 死信队列

    public static final String EXCHANGE = &quot;EXCHANGE_DEMO_07&quot;;

    public static final String ROUTING_KEY = &quot;ROUTING_KEY_07&quot;; // 正常路由键
    public static final String DEAD_ROUTING_KEY = &quot;DEAD_ROUTING_KEY_07&quot;; // 死信路由键


    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>相比<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来说，额外增加了死信队列会用到的 Queue 和 RoutingKey ，而 Exchange 我们先复用 <code>EXCHANGE = &quot;EXCHANGE_DEMO_07&quot;</code> 。</li></ul> <h2 id="_7-4-rabbitconfig"><a href="#_7-4-rabbitconfig" class="header-anchor">#</a> 7.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，额外添加<strong>死信队列</strong>的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Configuration
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo07Queue() {
            return QueueBuilder.durable(Demo07Message.QUEUE) // durable: 是否持久化
                    .exclusive() // exclusive: 是否排它
                    .autoDelete() // autoDelete: 是否自动删除
                    .deadLetterExchange(Demo07Message.EXCHANGE)
                    .deadLetterRoutingKey(Demo07Message.DEAD_ROUTING_KEY)
                    .build();
        }

        // 创建 Dead Queue
        @Bean
        public Queue demo07DeadQueue() {
            return new Queue(Demo07Message.DEAD_QUEUE, // Queue 名字
                    true, // durable: 是否持久化
                    false, // exclusive: 是否排它
                    false); // autoDelete: 是否自动删除
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo07Exchange() {
            return new DirectExchange(Demo07Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        // Exchange：Demo07Message.EXCHANGE
        // Routing key：Demo07Message.ROUTING_KEY
        // Queue：Demo07Message.QUEUE
        @Bean
        public Binding demo07Binding() {
            return BindingBuilder.bind(demo07Queue()).to(demo07Exchange()).with(Demo07Message.ROUTING_KEY);
        }

        // 创建 Dead Binding
        // Exchange：Demo07Message.EXCHANGE
        // Routing key：Demo07Message.DEAD_ROUTING_KEY
        // Queue：Demo07Message.DEAD_QUEUE
        @Bean
        public Binding demo07DeadBinding() {
            return BindingBuilder.bind(demo07DeadQueue()).to(demo07Exchange()).with(Demo07Message.DEAD_ROUTING_KEY);
        }

    }

}
</code></pre></div><ul><li>相比<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.5 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来说，主要有<strong>两个</strong>差异点。</li> <li>第一点，创建的正常 Queue 额外设置了，当消息成为死信时，RabbitMQ 自动转发到 Exchange 为 <code>Demo07Message.EXCHANGE</code>，RoutingKey 为 <code>Demo07Message.DEAD_ROUTING_KEY</code> 的死信队列中。</li> <li>第二点，通过 <code>#demo07DeadQueue()</code> 方法来创建死信队列的 Queue ，通过 <code>#demo07DeadBinding()</code> 方法来创建死信队列的 Binding 。😈 因为我们重用了 Exchange 为 <code>Demo07Message.EXCHANGE</code> ，所以无需创建。当然，胖友也可以根据自己的需要，创建死信队列的 Exchange 。</li></ul> <h2 id="_7-5-demo07producer"><a href="#_7-5-demo07producer" class="header-anchor">#</a> 7.5 Demo07Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-batch-consume-02/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo07Producer.java" target="_blank" rel="noopener noreferrer">Demo07Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、RoutingKey 名字不同。</p> <h2 id="_7-6-demo07consumer"><a href="#_7-6-demo07consumer" class="header-anchor">#</a> 7.6 Demo07Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo07Consumer.java" target="_blank" rel="noopener noreferrer">Demo07Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo07Consumer.java

@Component
@RabbitListener(queues = Demo07Message.QUEUE)
public class Demo07Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo07Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
        // &lt;X&gt; 注意，此处抛出一个 RuntimeException 异常，模拟消费失败
        throw new RuntimeException(&quot;我就是故意抛出一个异常&quot;);
    }

}
</code></pre></div><ul><li>在 <code>&lt;X&gt;</code> 处，我们在消费消息时候，抛出一个 RuntimeException 异常，模拟消费失败。</li></ul> <h2 id="_7-7-demo07deadconsumer"><a href="#_7-7-demo07deadconsumer" class="header-anchor">#</a> 7.7 Demo07DeadConsumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo07DeadConsumer.java" target="_blank" rel="noopener noreferrer">Demo07DeadConsumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费<strong>死信队列</strong>的消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo07DeadConsumer.java

@Component
@RabbitListener(queues = Demo07Message.DEAD_QUEUE)
public class Demo07DeadConsumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo07Message message) {
        logger.info(&quot;[onMessage][【死信队列】线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}
</code></pre></div><ul><li>在类上，添加了 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitListener.java" target="_blank" rel="noopener noreferrer"><code>@RabbitListener</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 注解，声明了消费的队列是 <code>&quot;DEAD_QUEUE_DEMO_07&quot;</code> 这个<strong>死信队列</strong>。</li></ul> <p>这里的消费逻辑，仅仅是示例，实现逻辑胖友根据自己的需要，自己来具体实现，嘿嘿。</p> <h2 id="_7-8-简单测试"><a href="#_7-8-简单测试" class="header-anchor">#</a> 7.8 简单测试</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.8 简单测试」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 大体一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-consume-retry/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo07ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo05ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 单元测试类。</p> <p>我们来执行 <code>#testSyncSend()</code> 方法，测试 Consumer 消费重试的效果。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 成功同步发送了 1 条消息
2019-12-15 14:21:40.424  INFO 66569 --- [           main] c.i.s.l.r.producer.Demo07ProducerTest    : [testSyncSend][发送编号：[1576045300] 发送成功]

# Demo07Consumer 第 1 次消费
2019-12-15 14:21:40.442  INFO 66569 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo07Consumer        : [onMessage][线程编号:17 消息内容：Demo07Message{id=1576045300}]
# 一秒后，Consumer 第 2 次消费
2019-12-15 14:21:41.446  INFO 66569 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo07Consumer        : [onMessage][线程编号:17 消息内容：Demo07Message{id=1576045300}]
# 一秒后，Consumer 第 3 次消费
2019-12-15 14:21:42.450  INFO 66569 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo07Consumer        : [onMessage][线程编号:17 消息内容：Demo07Message{id=1576045300}]

# RejectAndDontRequeueRecoverer 打印该消息消费重试到达上限，同时打印异常堆栈
2019-12-15 14:21:42.457  WARN 66569 --- [ntContainer#0-1] o.s.a.r.r.RejectAndDontRequeueRecoverer  : Retries exhausted for message (Body:'[B@514e3b1c(byte[187])' MessageProperties [headers={}, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=EXCHANGE_DEMO_07, receivedRoutingKey=ROUTING_KEY_07, deliveryTag=1, consumerTag=amq.ctag-UpkeXbl-7TYRNt_LuYDZJQ, consumerQueue=QUEUE_DEMO_07])
// ... 省略一大堆异常堆栈

# Demo07DeadConsumer 消费死信队列的该条消息
2019-12-15 14:21:42.463  INFO 66569 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo07DeadConsumer    : [onMessage][【死信队列】线程编号:19 消息内容：Demo07Message{id=1576045300}]
</code></pre></div><ul><li>Demo07Consumer 重试消费消息 3 次，每次间隔 1 秒，全部都失败，最终该消息转发到死信队列中。</li> <li>Demo07DeadConsumer 消费死信队列中的该消息。</li></ul> <h2 id="_7-9-发送重试"><a href="#_7-9-发送重试" class="header-anchor">#</a> 7.9 发送重试</h2> <p>在 Spring-AMQP 也提供了消息发送失败时的重试机制，也是基于 <a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="noopener noreferrer">spring-retry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目提供的 <a href="https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/support/RetryTemplate.java" target="_blank" rel="noopener noreferrer">RetryTemplate<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来实现。在 <code>application.yaml</code> 配置如下即可：</p> <div class="language- extra-class"><pre class="language-text"><code>spring:
  # RabbitMQ 配置项，对应 RabbitProperties 配置类
  rabbitmq:
    host: 127.0.0.1 # RabbitMQ 服务的地址
    port: 5672 # RabbitMQ 服务的端口
    username: guest # RabbitMQ 服务的账号
    password: guest # RabbitMQ 服务的密码
    template:
      # 对应 RabbitProperties.Retry 类
      retry:
        enabled: true # 开启发送机制
        max-attempts: 3 # 最大重试次数。默认为 3 。
        initial-interval: 1000 # 重试间隔，单位为毫秒。默认为 1000 。
</code></pre></div><ul><li><p><code>spring.rabbitmq.template.enable=true</code> 配置项，来开启 Spring-AMQP 的发送重试的功能。同时，通过<strong>新增</strong> <code>max-attempts</code> 和 <code>initial-interval</code> 配置项，设置重试次数和间隔。</p> <blockquote><p><code>max-attempts</code> 配置项要注意，是一条消息一共尝试消费总共 <code>max-attempts</code> 次，包括首次的正常消费。</p></blockquote></li> <li><p>另外，胖友可以通过添加 <code>spring.rabbitmq.template.retry.multiplier</code> 配置项来实现<strong>递乘</strong>的时间间隔，添加 <code>spring.rabbitmq.template.retry.max-interval</code> 配置项来实现<strong>最大</strong>的时间间隔。</p></li></ul> <p>这里艿艿就暂时不拓展开来讲，胖友可以自己尝试下哈。</p> <h1 id="_8-定时消息"><a href="#_8-定时消息" class="header-anchor">#</a> 8. 定时消息</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-delay<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「7. 消费重试」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>小节中，我们看到 Spring-AMQP 基于 RabbitMQ 提供的<strong>死信队列</strong>，通过 <code>basic.nack</code> + <code>requeue=false</code> 的方式，将重试消费到达上限次数的消息，投递到死信队列中。</p> <p>本小节，我们还是基于 RabbitMQ 的<strong>死信队列</strong>，实现<strong>定时消息</strong>的功能。RabbitMQ 提供了过期时间 <a href="https://www.rabbitmq.com/ttl.html" target="_blank" rel="noopener noreferrer">TTL<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 机制，可以设置消息在队列中的存活时长。在消息到达过期时间时，会从当前队列中删除，并被 RabbitMQ 自动转发到对应的死信队列中。</p> <p>那么，如果我们创建消费者 Consumer ，来消费该死信队列，是不是就实现了<strong>延迟队列</strong>的效果。😈 如此，我们便实现了定时消息的功能。</p> <p>下面，我们来实现一个定时消息的示例。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-delay<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_8-1-引入依赖"><a href="#_8-1-引入依赖" class="header-anchor">#</a> 8.1 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_8-2-应用配置文件"><a href="#_8-2-应用配置文件" class="header-anchor">#</a> 8.2 应用配置文件</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_8-3-demo08message"><a href="#_8-3-demo08message" class="header-anchor">#</a> 8.3 Demo08Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo08Message.java" target="_blank" rel="noopener noreferrer">Demo08Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo08Message.java

public class Demo08Message implements Serializable {

    public static final String QUEUE = &quot;QUEUE_DEMO_08&quot;; // 正常队列
    public static final String DELAY_QUEUE = &quot;DELAY_QUEUE_DEMO_08&quot;; // 延迟队列（死信队列）

    public static final String EXCHANGE = &quot;EXCHANGE_DEMO_08&quot;;

    public static final String ROUTING_KEY = &quot;ROUTING_KEY_08&quot;; // 正常路由键
    public static final String DELAY_ROUTING_KEY = &quot;DELAY_ROUTING_KEY_08&quot;; // 延迟路由键（死信路由键）

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>相比<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「8.3 Demo07Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来说，基本一致，只是换了下命名，将 <code>DEAD</code> 改成 <code>DELAY</code> 来方便胖友理解。</li></ul> <h2 id="_8-4-rabbitconfig"><a href="#_8-4-rabbitconfig" class="header-anchor">#</a> 8.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，额外添加<strong>延迟队列</strong>（死信队列）的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Configuration
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo08Queue() {
            return QueueBuilder.durable(Demo08Message.QUEUE) // durable: 是否持久化
                    .exclusive() // exclusive: 是否排它
                    .autoDelete() // autoDelete: 是否自动删除
                    .ttl(10 * 1000) // 设置队列里的默认过期时间为 10 秒
                    .deadLetterExchange(Demo08Message.EXCHANGE)
                    .deadLetterRoutingKey(Demo08Message.DELAY_ROUTING_KEY)
                    .build();
        }

        // 创建 Delay Queue
        @Bean
        public Queue demo08DelayQueue() {
            return new Queue(Demo08Message.DELAY_QUEUE, // Queue 名字
                    true, // durable: 是否持久化
                    false, // exclusive: 是否排它
                    false); // autoDelete: 是否自动删除
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo08Exchange() {
            return new DirectExchange(Demo08Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        // Exchange：Demo08Message.EXCHANGE
        // Routing key：Demo08Message.ROUTING_KEY
        // Queue：Demo08Message.QUEUE
        @Bean
        public Binding demo08Binding() {
            return BindingBuilder.bind(demo08Queue()).to(demo08Exchange()).with(Demo08Message.ROUTING_KEY);
        }

        // 创建 Delay Binding
        // Exchange：Demo08Message.EXCHANGE
        // Routing key：Demo08Message.DELAY_ROUTING_KEY
        // Queue：Demo08Message.DELAY_QUEUE
        @Bean
        public Binding demo08DelayBinding() {
            return BindingBuilder.bind(demo08DelayQueue()).to(demo08Exchange()).with(Demo08Message.DELAY_ROUTING_KEY);
        }

    }

}
</code></pre></div><ul><li>相比<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「7.4 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来说，主要有<strong>一个</strong>差异点。在 <code>#demo08Queue()</code> 方法来创建的 Queue ，我们设置了该队列的消息的默认过期时间为 10 秒。</li></ul> <h2 id="_8-5-demo08producer"><a href="#_8-5-demo08producer" class="header-anchor">#</a> 8.5 Demo08Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo08Producer.java" target="_blank" rel="noopener noreferrer">Demo08Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo08Producer.java

@Component
public class Demo08Producer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id, Integer delay) {
        // 创建 Demo07Message 消息
        Demo08Message message = new Demo08Message();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(Demo08Message.EXCHANGE, Demo08Message.ROUTING_KEY, message, new MessagePostProcessor() {

            @Override
            public Message postProcessMessage(Message message) throws AmqpException {
                // 设置消息的 TTL 过期时间
                if (delay != null &amp;&amp; delay &gt; 0) {
                    message.getMessageProperties().setExpiration(String.valueOf(delay)); // Spring-AMQP API 设计有问题，所以传入了 String = =
                }
                return message;
            }

        });
    }

}
</code></pre></div><ul><li>调用 <code>#syncSend(Integer id, Integer delay)</code> 方法来发送消息时，如果传递了方法参数 <code>delay</code> ，则我们会设置消息的 TTL 过期时间。</li></ul> <h2 id="_8-6-demo08consumer"><a href="#_8-6-demo08consumer" class="header-anchor">#</a> 8.6 Demo08Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo08Consumer.java" target="_blank" rel="noopener noreferrer">Demo08Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费<strong>延迟队列</strong>（死信队列）的消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>@Component
@RabbitListener(queues = Demo08Message.DELAY_QUEUE)
public class Demo08Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo08Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}
</code></pre></div><ul><li>在类上，添加了 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/RabbitListener.java" target="_blank" rel="noopener noreferrer"><code>@RabbitListener</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 注解，声明了消费的队列是 <code>&quot;DELAY_QUEUE_DEMO_08&quot;</code> 这个<strong>延迟队列（死信队列）</strong></li> <li>在消费逻辑中，我们正常消费该消息即可，实现自己需要的业务逻辑。</li></ul> <h2 id="_8-7-简单测试"><a href="#_8-7-简单测试" class="header-anchor">#</a> 8.7 简单测试</h2> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-delay/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo08ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo08ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写单元测试方法，测试<strong>定时消息</strong>的效果。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo08ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo08ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo08Producer producer;

    @Test
    public void testSyncSend01() throws InterruptedException {
        // 不设置消息的过期时间，使用队列默认的消息过期时间
        this.testSyncSendDelay(null);
    }

    @Test
    public void testSyncSend02() throws InterruptedException {
        // 设置发送消息的过期时间为 5000 毫秒
        this.testSyncSendDelay(5000);
    }

    private void testSyncSendDelay(Integer delay) throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id, delay);
        logger.info(&quot;[testSyncSendDelay][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><ul><li><code>#testSyncSend01()</code> 方法，不设置消息的过期时间，使用队列<strong>默认的消息过期</strong>时间。</li> <li><code>#testSyncSend02()</code> 方法，发送消息的<strong>过期时间为 5000 毫秒</strong>。</li></ul> <p>我们先来执行 <code>#testSyncSend01()</code> 方法，不设置消息的过期时间，使用队列<strong>默认的消息过期</strong>时间。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 同步发送消息成功。
2019-12-15 15:44:34.571  INFO 85481 --- [           main] c.i.s.l.r.producer.Demo08ProducerTest    : [testSyncSendDelay][发送编号：[1576050274] 发送成功]

# Consumer 10 秒后，消费到该消息
2019-12-15 15:44:44.588  INFO 85481 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo08Consumer        : [onMessage][线程编号:17 消息内容：Demo08Message{id=1576050274}]
</code></pre></div><ul><li>符合预期。</li></ul> <p>我们再来执行 <code>#testSyncSend02()</code> 方法，发送消息的<strong>过期时间为 5000 毫秒</strong>。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># Producer 同步发送消息成功。
2019-12-15 15:45:41.076  INFO 85735 --- [           main] c.i.s.l.r.producer.Demo08ProducerTest    : [testSyncSendDelay][发送编号：[1576050341] 发送成功]

# Consumer 5 秒后，消费到该消息
2019-12-15 15:45:46.090  INFO 85735 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo08Consumer        : [onMessage][线程编号:17 消息内容：Demo08Message{id=1576050341}]
</code></pre></div><ul><li>符合预期。</li></ul> <h2 id="_8-8-rabbitmq-delayed-message-plugin"><a href="#_8-8-rabbitmq-delayed-message-plugin" class="header-anchor">#</a> 8.8 RabbitMQ Delayed Message Plugin</h2> <p>RabbitMQ 目前提供了 <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener noreferrer">RabbitMQ Delayed Message Plugin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 插件，提供更加<strong>通用</strong>的定时消息的功能。</p> <p>使用起来比较简单，艿艿这里先暂时不提供示例。感兴趣的胖友，可以看看 <a href="http://www.iocoder.cn/Fight/Spring-Boot-RabbitMQ-deferred-message-implementation-full-version/?self" target="_blank" rel="noopener noreferrer">《Spring Boot RabbitMQ 延迟消息实现完整版》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文章。</p> <p>这两种方案，生产环境下，还是<strong>推荐直接使用 RabbitMQ Delayed Message Plugin 插件的方式</strong>。毕竟，这是 RabbitMQ 官方认可的插件，使用起来肯定是没错的。</p> <h1 id="_9-消息模式"><a href="#_9-消息模式" class="header-anchor">#</a> 9. 消息模式</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-message-model<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>在消息队列中，有两种经典的消息模式：「点对点」和「发布订阅」。具体的概念，就先不解释，胖友可以看看<a href="http://www.iocoder.cn/Fight/There-are-two-modes-of-message-queuing-point-to-point-and-publish-subscription/?self" target="_blank" rel="noopener noreferrer">《消息队列两种模式：点对点与发布订阅》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文章。</p> <p>如果胖友有使用过 RocketMQ 或者 Kafka 消息队列，可能比较习惯的叫法是：</p> <blockquote><p><strong>集群消费（Clustering）</strong>：对应「点对点」 集群消费模式下，相同 Consumer Group 的每个 Consumer 实例平均分摊消息。</p> <p><strong>广播消费（Broadcasting）</strong>：对应「发布订阅」 广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。</p></blockquote> <p>😈 下文我们统一采用集群消费和广播消费叫法。</p> <p>下面，我们分别在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1 集群消费」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.2 广播消费」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的示例代码。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-message-model<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_9-1-集群消费"><a href="#_9-1-集群消费" class="header-anchor">#</a> 9.1 集群消费</h2> <p>在 RabbitMQ 中，如果多个 Consumer 订阅相同的 Queue ，那么每一条消息有且仅会被一个 Consumer 所消费。这个特性，就为我们实现集群消费提供了基础。</p> <p>在本示例中，我们会把一个 Queue 作为一个 Consumer Group ，同时创建消费该 Queue 的 Consumer 。这样，在我们启动多个 JVM 进程时，就会有多个 Consumer 消费该 Queue ，从而实现集群消费的效果。</p> <p>下面，让我们开始集群消费的示例。</p> <h3 id="_9-1-1-引入依赖"><a href="#_9-1-1-引入依赖" class="header-anchor">#</a> 9.1.1 引入依赖</h3> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h3 id="_9-1-2-应用配置文件"><a href="#_9-1-2-应用配置文件" class="header-anchor">#</a> 9.1.2 应用配置文件</h3> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h3 id="_9-1-3-clusteringmessage"><a href="#_9-1-3-clusteringmessage" class="header-anchor">#</a> 9.1.3 ClusteringMessage</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/ClusteringMessage.java" target="_blank" rel="noopener noreferrer">ClusteringMessage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// ClusteringMessage.java

public class ClusteringMessage implements Serializable {

    public static final String QUEUE = &quot;QUEUE_CLUSTERING&quot;;

    public static final String EXCHANGE = &quot;EXCHANGE_CLUSTERING&quot;;

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>在这里，我们并没有定义 RoutingKey 的枚举，答案我们在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.6 ClusteringConsumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>揭晓。</li></ul> <h3 id="_9-1-4-rabbitconfig"><a href="#_9-1-4-rabbitconfig" class="header-anchor">#</a> 9.1.4 RabbitConfig</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加集群消费需要的 Exchange 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Configuration
public class RabbitConfig {

    /**
     * 集群消费的示例的配置
     */
    public static class ClusteringConfiguration {

        // 创建 Topic Exchange
        @Bean
        public TopicExchange clusteringExchange() {
            return new TopicExchange(ClusteringMessage.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

    }

}
</code></pre></div><ul><li>在这里，我们创建了 Exchange 类型是 <strong>Topic</strong> 。</li></ul> <p>为什么不选择 Exchange 类型是 <strong>Direct</strong> 呢？考虑到集群消费的模式，会存在多 Consumer Group 消费的情况，显然我们要支持一条消息投递到多个 Queue 中，所以 Direct Exchange 基本就被排除了。</p> <p>为什么不选择 Exchange 类型是 <strong>Fanout</strong> 或者 <strong>Headers</strong> 呢？实际是可以的，不过询问了朋友(didi) <a href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit" target="_blank" rel="noopener noreferrer">Spring Cloud Stream RabbitMQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是怎么实现的。得知答案是<a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-stream-binder-rabbit/master/docs/src/main/asciidoc/images/rabbit-binder.png" target="_blank" rel="noopener noreferrer">默认<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是使用 Topic Exchange 的，所以艿艿示例这里也就使用 Topic Exchange 类型了。</p> <h3 id="_9-1-5-clusteringproducer"><a href="#_9-1-5-clusteringproducer" class="header-anchor">#</a> 9.1.5 ClusteringProducer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/ClusteringProducer.java" target="_blank" rel="noopener noreferrer">ClusteringProducer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// ClusteringProducer.java

@Component
public class ClusteringProducer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id) {
        // 创建 ClusteringMessage  消息
        ClusteringMessage message = new ClusteringMessage();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(ClusteringMessage.EXCHANGE, null, message);
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.2.3 Demo02Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是基本一致的，除了调用 RabbitTemplate 发送消息时，我们传递的 <code>routingKey</code> 参数为 <code>null</code> 。为什么呢？答案我们也在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.6 ClusteringConsumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>揭晓。</li></ul> <h3 id="_9-1-6-clusteringconsumer"><a href="#_9-1-6-clusteringconsumer" class="header-anchor">#</a> 9.1.6 ClusteringConsumer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/ClusteringConsumer.java" target="_blank" rel="noopener noreferrer">ClusteringConsumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，<strong>集群</strong>消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// ClusteringConsumer.java

@Component
@RabbitListener(
        bindings = @QueueBinding(
                value = @Queue(
                        name = ClusteringMessage.QUEUE + &quot;-&quot; + &quot;GROUP-01&quot;
                ),
                exchange = @Exchange(
                        name = ClusteringMessage.EXCHANGE,
                        type = ExchangeTypes.TOPIC,
                        declare = &quot;false&quot;
                ),
                key = &quot;#&quot;
        )
)
public class ClusteringConsumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(ClusteringMessage message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}
</code></pre></div><ul><li><p>相比其它 Consumer 示例来说，这里添加的 <code>@RabbitListener</code> 注解复杂很多。</p></li> <li><p>在 <code>bindings</code> 属性，我们添加了 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/QueueBinding.java" target="_blank" rel="noopener noreferrer"><code>@QueueBinding</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 注解，来定义了一个 Binding 。通过 <code>key</code> 属性，设置使用的 RoutingKey 为 <code>#</code> ，<strong>匹配所有</strong>。这就是为什么我们在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.3 ClusteringMessage」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>未定义 RoutingKey ，以及在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.5 ClusteringProducer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中使用 <code>routingKey = null</code> 的原因。</p></li> <li><p>在</p> <div class="language- extra-class"><pre class="language-text"><code>exchange
</code></pre></div><p>属性，我们添加了</p> <p><code>@Exchange</code></p> <p>注解，设置了对应</p> <div class="language- extra-class"><pre class="language-text"><code>EXCHANGE_CLUSTERING
</code></pre></div><p>这个 Exchange 。</p> <ul><li><code>type</code> 属性，设置是 TopicExchange 。</li> <li><code>declare</code> 属性，因为<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.4 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，已经配置创建这个 Exchange 了。</li></ul></li> <li><p>在 <code>value</code> 属性，我们添加了 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/annotation/Queue.java" target="_blank" rel="noopener noreferrer"><code>@Queue</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 注解，设置消费 <code>QUEUE_CLUSTERING-GROUP-01</code> 这个 Queue 的消息。</p></li></ul> <p>注意，通过添加 <code>@Exchange</code>、<code>@Queue</code>、<code>@QueueBinding</code> 注解，如果未声明 <code>declare=&quot;false&quot;</code> 时，会<strong>自动创建对应</strong>的 Exchange、Queue、Binding 。</p> <h3 id="_9-1-7-简单测试"><a href="#_9-1-7-简单测试" class="header-anchor">#</a> 9.1.7 简单测试</h3> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/ClusteringProducerTest.java" target="_blank" rel="noopener noreferrer">ClusteringProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，用于测试集群消费。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// ClusteringProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class ClusteringProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private ClusteringProducer producer;

    @Test
    public void mock() throws InterruptedException {
        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

    @Test
    public void testSyncSend() throws InterruptedException {
        // 发送 3 条消息
        for (int i = 0; i &lt; 3; i++) {
            int id = (int) (System.currentTimeMillis() / 1000);
            producer.syncSend(id);
            logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);
        }

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><p>首先，执行 <code>#mock()</code> 测试方法，先启动一个消费 <code>&quot;QUEUE_CLUSTERING-GROUP-01&quot;</code> 这个 Queue 的 Consumer 节点。</p> <p>然后，执行 <code>#testSyncSend()</code> 测试方法，再启动一个消费 <code>&quot;QUEUE_CLUSTERING-GROUP-01&quot;</code> 这个 Queue 的 Consumer 节点。同时，该测试方法，调用 <code>ClusteringProducer#syncSend(id)</code> 方法，同步发送了 3 条消息。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// #### testSyncSend 方法对应的控制台 ####

# Producer 同步发送消息成功
2019-12-15 22:13:44.372  INFO 43363 --- [           main] c.i.s.l.r.p.ClusteringProducerTest       : [testSyncSend][发送编号：[1576073624] 发送成功]
2019-12-15 22:13:44.373  INFO 43363 --- [           main] c.i.s.l.r.p.ClusteringProducerTest       : [testSyncSend][发送编号：[1576073624] 发送成功]
2019-12-15 22:13:44.374  INFO 43363 --- [           main] c.i.s.l.r.p.ClusteringProducerTest       : [testSyncSend][发送编号：[1576073624] 发送成功]

# ClusteringConsumer 消费了 1 条消息
2019-12-15 22:13:44.393  INFO 43363 --- [ntContainer#1-1] c.i.s.l.r.consumer.ClusteringConsumer    : [onMessage][线程编号:19 消息内容：ClusteringtMessage{id=1576073624}]

// ### mock 方法对应的控制台 ####

# ClusteringConsumer 消费了 2 条消息
2019-12-15 22:13:44.396  INFO 43308 --- [ntContainer#1-1] c.i.s.l.r.consumer.ClusteringConsumer    : [onMessage][线程编号:19 消息内容：ClusteringtMessage{id=1576073624}]
2019-12-15 22:13:44.398  INFO 43308 --- [ntContainer#1-1] c.i.s.l.r.consumer.ClusteringConsumer    : [onMessage][线程编号:19 消息内容：ClusteringtMessage{id=1576073624}]
</code></pre></div><ul><li>3 条消息，都仅被 <strong>两个</strong> Consumer 节点的<strong>一个</strong>进行消费。符合集群消费的预期~</li></ul> <p>因为考虑让集群消费的示例做的比较简单，所以并未提供一条消息投递到多个 Queue 中，从而实现多集群下的集群消费的效果。不过比较简单，胖友可以自行在创建一个类似<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.6 ClusteringConsumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的消费者类，设置消费另外一个 Queue 即可。例如说：</p> <div class="language- extra-class"><pre class="language-text"><code>@Component
@RabbitListener(
        bindings = @QueueBinding(
                value = @Queue(
                        name = ClusteringMessage.QUEUE + &quot;-&quot; + &quot;GROUP-02&quot; // 这里从 &quot;GROUP-01&quot; 改成了 &quot;GROUP-02&quot; 。
                ),
                exchange = @Exchange(
                        name = ClusteringMessage.EXCHANGE,
                        type = ExchangeTypes.TOPIC,
                        declare = &quot;false&quot;
                ),
                key = &quot;#&quot;
        )
)
</code></pre></div><h2 id="_9-2-广播消费"><a href="#_9-2-广播消费" class="header-anchor">#</a> 9.2 广播消费</h2> <p>在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1 集群消费」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，我们通过“在 RabbitMQ 中，如果多个 Consumer 订阅相同的 Queue ，那么每一条消息有且仅会被一个 Consumer 所消费”特性，来实现了集群消费。但是，在实现广播消费时，这个特性恰恰成为了一种阻碍。</p> <p>不过机智的我们，我们可以通过给每个 Consumer 创建一个其<strong>独有</strong> Queue ，从而保证都能接收到全量的消息。同时，RabbitMQ 支持队列的自动删除，所以我们可以在 Consumer 关闭的时候，通过该功能删除其<strong>独有</strong>的 Queue 。</p> <p>下面，让我们开始集群消费的示例。考虑到简便，我们直接继续在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目改造。</p> <h3 id="_9-2-1-broadcastmessage"><a href="#_9-2-1-broadcastmessage" class="header-anchor">#</a> 9.2.1 BroadcastMessage</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/BroadcastMessage.java" target="_blank" rel="noopener noreferrer">BroadcastMessage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// BroadcastMessage.java

public class BroadcastMessage implements Serializable {

    public static final String QUEUE = &quot;QUEUE_BROADCASTING&quot;;

    public static final String EXCHANGE = &quot;EXCHANGE_BROADCASTING&quot;;

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.3 ClusteringMessage」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Queue 和 Exchange 的名字不同。</li></ul> <h3 id="_9-2-2-rabbitconfig"><a href="#_9-2-2-rabbitconfig" class="header-anchor">#</a> 9.2.2 RabbitConfig</h3> <p>修改 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加自定义的 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/config/SimpleRabbitListenerContainerFactory.java" target="_blank" rel="noopener noreferrer">SimpleRabbitListenerContainerFactory<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Bean ，添加广播消费需要的 Exchange 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

/**
 * 广播消费的示例的配置
 */
public static class BroadcastingConfiguration {

    // 创建 Topic Exchange
    @Bean
    public TopicExchange broadcastingExchange() {
        return new TopicExchange(BroadcastMessage.EXCHANGE,
                true,  // durable: 是否持久化
                false);  // exclusive: 是否排它
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.4 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 ClusteringConfiguration 配置类是一致，只是创建了不同的 Exchange 。</li></ul> <h3 id="_9-2-3-broadcastproducer"><a href="#_9-2-3-broadcastproducer" class="header-anchor">#</a> 9.2.3 BroadcastProducer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/BroadcastProducer.java" target="_blank" rel="noopener noreferrer">BroadcastProducer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// BroadcastProducer.java

@Component
public class BroadcastProducer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id) {
        // 创建 BroadcastMessage 消息
        BroadcastMessage message = new BroadcastMessage();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(BroadcastMessage.EXCHANGE, null, message);
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.5 ClusteringProducer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是一致，只是使用了不同的 Exchange 和消息。</li></ul> <h3 id="_9-2-4-broadcastconsumer"><a href="#_9-2-4-broadcastconsumer" class="header-anchor">#</a> 9.2.4 BroadcastConsumer</h3> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/ClusteringConsumer.java" target="_blank" rel="noopener noreferrer">BroadcastConsumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，<strong>广播</strong>消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// BroadcastConsumer.java

@Component
@RabbitListener(
        bindings = @QueueBinding(
                value = @Queue(
                        name = BroadcastMessage.QUEUE + &quot;-&quot; + &quot;#{T(java.util.UUID).randomUUID()}&quot;,
                        autoDelete = &quot;true&quot;
                ),
                exchange = @Exchange(
                        name = BroadcastMessage.EXCHANGE,
                        type = ExchangeTypes.TOPIC,
                        declare = &quot;false&quot;
                )
        )
)
public class BroadcastConsumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(BroadcastMessage message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}
</code></pre></div><ul><li>总体和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9.1.6 ClusteringConsumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是一致，主要差异在两点。</li> <li>第一点，在 <code>@Queue</code> 注解的 <code>name</code> 属性，我们通过 Spring EL 表达式，在 Queue 的名字上，使用 UUID 生成其后缀。这样，我们就能保证每个项目启动的 Consumer 的 Queue 不同，以达到广播消费的目的。</li> <li>第二点，在 <code>@Queue</code> 注解的 <code>autoDelete</code> 属性，我们设置为 <code>&quot;true&quot;</code> ，这样在 Consumer 关闭时，该队列就可以被自动删除了。</li></ul> <h3 id="_9-2-5-简单测试"><a href="#_9-2-5-简单测试" class="header-anchor">#</a> 9.2.5 简单测试</h3> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-message-model/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/BroadcastProducerTest.java" target="_blank" rel="noopener noreferrer">BroadcastProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，用于测试广播消费。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// BroadcastProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class BroadcastProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private BroadcastProducer producer;

    @Test
    public void mock() throws InterruptedException {
        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

    @Test
    public void testSyncSend() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><p>首先，执行 <code>#mock()</code> 测试方法，先启动一个消费 <code>&quot;QUEUE_BROADCAST-${UUID1}&quot;</code> 这个 Queue 的 Consumer 节点。</p> <p>然后，执行 <code>#testSyncSend()</code> 测试方法，再启动一个消费 <code>&quot;QUEUE_BROADCAST-${UUID2}&quot;</code> 这个 Queue 的 Consumer 节点。同时，该测试方法，调用 <code>BroadcastProducer#syncSend(id)</code> 方法，同步发送了 3 条消息。控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// #### testSyncSend 方法对应的控制台 ####

# Producer 同步发送消息成功
2019-12-15 00:11:41.459  INFO 64479 --- [           main] c.i.s.l.r.p.BroadcastProducerTest        : [testSyncSend][发送编号：[1576080701] 发送成功]
2019-12-15 00:11:41.460  INFO 64479 --- [           main] c.i.s.l.r.p.BroadcastProducerTest        : [testSyncSend][发送编号：[1576080701] 发送成功]
2019-12-15 00:11:41.461  INFO 64479 --- [           main] c.i.s.l.r.p.BroadcastProducerTest        : [testSyncSend][发送编号：[1576080701] 发送成功]

# BroadcastConsumer 消费了 3 条消息
2019-12-15 00:11:41.478  INFO 64479 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]
2019-12-15 00:11:41.479  INFO 64479 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]
2019-12-15 00:11:41.480  INFO 64479 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]

// ### mock 方法对应的控制台 ####

# BroadcastConsumer 也消费了 3 条消
2019-12-15 00:11:41.460  INFO 63795 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]
2019-12-15 00:11:41.462  INFO 63795 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]
2019-12-15 00:11:41.462  INFO 63795 --- [ntContainer#0-1] c.i.s.l.r.consumer.BroadcastConsumer     : [onMessage][线程编号:17 消息内容：BroadcastMessage{id=1576080701}]
</code></pre></div><ul><li><strong>两个</strong> Consumer 节点，都消费了这条发送的消息。符合广播消费的预期~</li></ul> <h1 id="_10-并发消费"><a href="#_10-并发消费" class="header-anchor">#</a> 10. 并发消费</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-concurrency<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>在上述的示例中，我们配置的每一个 Spring-AMQP <code>@RabbitListener</code> ，都是<strong>串行</strong>消费的。显然，这在监听的 Queue 每秒消息量比较大的时候，会导致消费不及时，导致消息积压的问题。</p> <p>虽然说，我们可以通过启动多个 JVM 进程，实现<strong>多进程的并发消费</strong>，从而加速消费的速度。但是问题是，否能够实现<strong>多线程</strong>的并发消费呢？答案是<strong>有</strong>。</p> <p>在 <code>@RabbitListener</code> 注解中，有 <code>concurrency</code> 属性，它可以指定并发消费的线程数。例如说，如果设置 <code>concurrency=4</code> 时，Spring-AMQP 就会为<strong>该</strong> <code>@RabbitListener</code> 创建 4 个线程，进行并发消费。</p> <p>考虑到让胖友能够更好的理解 <code>concurrency</code> 属性，我们来简单说说 Spring-AMQP 在这块的实现方式。我们来举个例子：</p> <ul><li>首先，我们来创建一个 Queue 为 <code>&quot;DEMO_09&quot;</code> 。</li> <li>然后，我们创建一个 Demo9Consumer 类，并在其消费方法上，添加 <code>@RabbitListener(concurrency=2)</code> 注解。</li> <li>再然后，我们启动项目。Spring-AMQP 会根据 <code>@RabbitListener(concurrency=2)</code> 注解，创建 <strong>2</strong> 个 RabbitMQ Consumer 。注意噢，是 <strong>2</strong> 个 RabbitMQ Consumer 呢！！！后续，每个 RabbitMQ Consumer 会被<strong>单独</strong>分配到一个线程中，进行拉取消息，消费消息。</li></ul> <p>酱紫讲解一下，胖友对 Spring-AMQP 实现<strong>多线程</strong>的并发消费的机制，是否理解了。</p> <p>下面，我们开始本小节的示例。本示例就是上述举例的具体实现。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-concurrency<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_10-1-引入依赖"><a href="#_10-1-引入依赖" class="header-anchor">#</a> 10.1 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_10-2-应用配置文件"><a href="#_10-2-应用配置文件" class="header-anchor">#</a> 10.2 应用配置文件</h2> <p>在开始看具体的应用配置文件之前，我们先来了了解下 Spring-AMQP 的两个 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java#L566-L579" target="_blank" rel="noopener noreferrer">ContainerType<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 容器类型，枚举如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitProperties.java

public enum ContainerType {

	/**
	 * Container where the RabbitMQ consumer dispatches messages to an invoker thread.
	 */
	SIMPLE,

	/**
	 * Container where the listener is invoked directly on the RabbitMQ consumer
	 * thread.
	 */
	DIRECT

}
</code></pre></div><p>① 第一种类型，<code>SIMPLE</code> 对应 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/SimpleMessageListenerContainer.java" target="_blank" rel="noopener noreferrer">SimpleMessageListenerContainer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息监听器容器。它一共有两<strong>类</strong>线程：</p> <ul><li>Consumer 线程，负责从 RabbitMQ Broker 获取 Queue 中的消息，存储到<strong>内存中</strong>的 <a href="https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/BlockingQueue.java" target="_blank" rel="noopener noreferrer">BlockingQueue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 阻塞队列中。</li> <li>Listener 线程，负责从<strong>内存中</strong>的 BlockingQueue 获取消息，进行消费逻辑。</li></ul> <p>注意，每一个 Consumer 线程，对应一个 RabbitMQ Consumer ，对应一个 Listener 线程。也就是说，它们三者是<strong>一一对应</strong>的。</p> <p>② 第二种类型，<code>DIRECT</code> 对应 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/DirectMessageListenerContainer.java" target="_blank" rel="noopener noreferrer">DirectMessageListenerContainer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息监听器容器。它只有<strong>一类</strong>线程，即做 <code>SIMPLE</code> 的 Consumer 线程的工作，也做 <code>SIMPLE</code> 的 Listener 线程工作。</p> <p>注意，因为只有<strong>一类</strong>线程，所以它要么正在获取消息，要么正在消费消息，也就是<strong>串行</strong>的。</p> <p>🔥 默认情况下，Spring-AMQP 选择使用第一种类型，即 <code>SIMPLE</code> 容器类型。</p> <p>下面，让我们一起看看 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置文件。配置如下：</p> <div class="language- extra-class"><pre class="language-text"><code>spring:
  # RabbitMQ 配置项，对应 RabbitProperties 配置类
  rabbitmq:
    host: 127.0.0.1 # RabbitMQ 服务的地址
    port: 5672 # RabbitMQ 服务的端口
    username: guest # RabbitMQ 服务的账号
    password: guest # RabbitMQ 服务的密码
    listener:
      type: simple # 选择的 ListenerContainer 的类型。默认为 simple 类型
      simple:
        concurrency: 2 # 每个 @ListenerContainer 的并发消费的线程数
        max-concurrency: 10 # 每个 @ListenerContainer 允许的并发消费的线程数
#      direct:
#        consumers-per-queue: 2 # 对于每一个 @RabbitListener ，一个 Queue ，对应创建几个 Consumer 。
</code></pre></div><ul><li><p>相比</p> <p>「3.1.2 应用配置文件」</p> <p>来说，额外三个参数：</p> <ul><li><code>spring.rabbitmq.listener.type</code></li> <li><code>spring.rabbitmq.listener.simple.concurrency</code></li> <li><code>spring.rabbitmq.listener.simple.max-concurrency</code></li></ul></li></ul> <p>要<strong>注意</strong>，是 <code>spring.rabbitmq.listener.simple.max-concurrency</code> 配置，是<strong>限制</strong>每个 <code>@RabbitListener</code> 的<strong>允许</strong>配置的 <code>concurrency</code> 最大大小。如果超过，则会抛出 IllegalArgumentException 异常。在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「10.6 Demo09Consumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，我们会看到 <code>@RabbitListener</code> 注解，有一个 <code>concurrency</code> 属性，可以自定义每个 <code>@RabbitListener</code> 的并发消费的线程数。</p> <h2 id="_10-3-demo09message"><a href="#_10-3-demo09message" class="header-anchor">#</a> 10.3 Demo09Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo09Message.java" target="_blank" rel="noopener noreferrer">Demo09Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_10-4-rabbitconfig"><a href="#_10-4-rabbitconfig" class="header-anchor">#</a> 10.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，配置相关的 Exchange、Queue、Binding 。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.5 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_10-5-demo09producer"><a href="#_10-5-demo09producer" class="header-anchor">#</a> 10.5 Demo09Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo09Producer.java" target="_blank" rel="noopener noreferrer">Demo09Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、RoutingKey 名字不同。</p> <h2 id="_10-6-demo09consumer"><a href="#_10-6-demo09consumer" class="header-anchor">#</a> 10.6 Demo09Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo09Consumer.java" target="_blank" rel="noopener noreferrer">Demo09Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo06Consumer.java

@Component
@RabbitListener(queues = Demo09Message.QUEUE,
    concurrency = &quot;2&quot;)
public class Demo09Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo09Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    }

}
</code></pre></div><ul><li>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.7 Demo01Consumer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只差在消费不同的队列。</li> <li>另外，可以通过 <code>@RabbitListener</code> 注解，设置并发数。优先级最高，可覆盖配置文件中的 <code>spring.rabbitmq.listener.simple.concurrency</code> 配置项。</li></ul> <p>不过个人建议，还是每个 <code>@RabbitListener</code> 各自配置，毕竟每个 Queue 的消息数量，都是不同的。当然，也可以结合使用 😈 。</p> <h2 id="_10-7-简单测试"><a href="#_10-7-简单测试" class="header-anchor">#</a> 10.7 简单测试</h2> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-concurrency/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo09ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo09ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写一个单元测试方法，发送 10 条消息，观察并发消费情况。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo09ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo09ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo09Producer producer;

    @Test
    public void testSyncSend() throws InterruptedException {
        for (int i = 0; i &lt; 10; i++) {
            int id = (int) (System.currentTimeMillis() / 1000);
            producer.syncSend(id);
//            logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);
        }

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><p>执行单元测试方法，控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># 线程编号为 17
2019-12-15 10:48:20.013  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.015  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.016  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.017  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.017  INFO 2937 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:17 消息内容：Demo09Message{id=1576118899}]

# 线程编号 18
2019-12-15 10:48:20.013  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.015  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.016  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.016  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]
2019-12-15 10:48:20.017  INFO 2937 --- [ntContainer#0-2] c.i.s.l.r.consumer.Demo09Consumer        : [onMessage][线程编号:18 消息内容：Demo09Message{id=1576118899}]
</code></pre></div><ul><li>我们可以看到，两个线程在消费 <code>&quot;QUEUE_DEMO_09&quot;</code> 下的消息。</li></ul> <p>此时，如果我们使用 <a href="https://www.rabbitmq.com/management.html" target="_blank" rel="noopener noreferrer">RabbitMQ Management<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来查看 <code>&quot;QUEUE_DEMO_09&quot;</code> 的消费者列表：</p> <p><img src="https://raw.githubusercontent.com/lichengcan/images/main/01.png" alt=""></p> <h1 id="_11-顺序消息"><a href="#_11-顺序消息" class="header-anchor">#</a> 11. 顺序消息</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-orderly<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>我们先来一起了解下顺序消息的<strong>顺序消息</strong>的定义：</p> <ul><li>普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。</li> <li>完全严格顺序 ：在【普通顺序消息】的基础上，Consumer 严格顺序消费。</li></ul> <p>那么，让我们来思考下，如果我们希望在 RabbitMQ 上，实现顺序消息需要做两个事情。</p> <p>① <strong>事情一</strong>，我们需要保证 RabbitMQ Producer 发送相关联的消息发送到相同的 Queue 中。例如说，我们要发送用户信息发生变更的 Message ，那么如果我们希望使用顺序消息的情况下，可以将<strong>用户编号</strong>相同的消息发送到相同的 Queue 中。</p> <p>② <strong>事情二</strong>，我们在有<strong>且仅启动一个</strong> Consumer 消费该队列，保证 Consumer 严格顺序消费。</p> <p>不过如果这样做，会存在两个问题，我们逐个来看看。</p> <p>① <strong>问题一</strong>，正如我们在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「10. 并发消费」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中提到，如果我们将消息仅仅投递到一个 Queue 中，并且采用单个 Consumer <strong>串行</strong>消费，在监听的 Queue 每秒消息量比较大的时候，会导致消费不及时，导致消息积压的问题。</p> <p>此时，我们有两种方案来解决：</p> <ul><li>方案一，在 Producer 端，将 Queue 拆成多个<strong>子</strong> Queue 。假设原先 Queue 是 <code>QUEUE_USER</code> ，那么我们就分拆成 <code>QUEUE_USER_00</code> 至 <code>QUEUE_USER_..${N-1}</code> 这样 N 个队列，然后基于消息的用户编号取余，路由到对应的<strong>子</strong> Queue 中。</li> <li>方案二，在 Consumer 端，将 Queue 拉取到的消息，将相关联的消息发送到<strong>相同的线程</strong>中来消费。例如说，还是 Queue 是 <code>QUEUE_USER</code> 的例子，我们创建 N 个线程池大小为 1 的 <a href="https://github.com/JetBrains/jdk8u_jdk/blob/master/src/share/classes/java/util/concurrent/ExecutorService.java" target="_blank" rel="noopener noreferrer">ExecutorService<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 数组，然后基于消息的用户编号取余，提交到对应的 ExecutorService 中的单个线程来执行。</li></ul> <p>两个方案，并不冲突，可以结合使用。</p> <p>② <strong>问题二</strong>，如果我们启动相同 Consumer 的<strong>多个进程</strong>，会导致相同 Queue 的消息被分配到多个 Consumer 进行消费，破坏 Consumer 严格顺序消费。</p> <p>此时，我们有两种方案来解决：</p> <ul><li>方案一，引入 ZooKeeper 来协调，动态设置多个进程中的<strong>相同的</strong> Consumer 的开关，保证有且仅有一个 Consumer 开启对<strong>同一个</strong> Queue 的消费。</li> <li>方案二，仅适用于【问题一】的【方案一】。还是引入 ZooKeeper 来协调，动态设置多个进程中的<strong>相同的</strong> Consumer 消费的 Queue 的分配，保证有且仅有一个 Consumer 开启对<strong>同一个</strong> Queue 的消费。</li></ul> <p>下面，我们开始本小节的示例。本示例就是上述举例的具体实现。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-orderly<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <ul><li>对于问题一，我们采用方案一。因为在 Spring-AMQP 中，自己定义线程来消费消息，无法和现有的 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-jms/src/main/java/org/springframework/jms/listener/MessageListenerContainer.java" target="_blank" rel="noopener noreferrer">MessageListenerContainer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的实现所结合，除非自定义一个 MessageListenerContainer 实现类。</li> <li>对于问题二，因为实现起来比较复杂，暂时先不提供。</li></ul> <h2 id="_11-1-引入依赖"><a href="#_11-1-引入依赖" class="header-anchor">#</a> 11.1 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_11-2-应用配置文件"><a href="#_11-2-应用配置文件" class="header-anchor">#</a> 11.2 应用配置文件</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_11-3-demo10message"><a href="#_11-3-demo10message" class="header-anchor">#</a> 11.3 Demo10Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo10Message.java" target="_blank" rel="noopener noreferrer">Demo10Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo10Message.java

public class Demo10Message implements Serializable {

    private static final String QUEUE_BASE = &quot;QUEUE_DEMO_10-&quot;;
    public static final String QUEUE_0 = QUEUE_BASE + &quot;0&quot;;
    public static final String QUEUE_1 = QUEUE_BASE + &quot;1&quot;;
    public static final String QUEUE_2 = QUEUE_BASE + &quot;2&quot;;
    public static final String QUEUE_3 = QUEUE_BASE + &quot;3&quot;;

    public static final int QUEUE_COUNT = 4;

    public static final String EXCHANGE = &quot;EXCHANGE_DEMO_10&quot;;

    /**
     * 编号
     */
    private Integer id;

    // ... 省略 set/get/toString 方法

}
</code></pre></div><ul><li>定义了 <code>QUEUE_DEMO_10-</code> 的四个<strong>子</strong> Queue 。</li> <li>定义了统一的 Exchange 。</li> <li>暂未定义 RoutingKey 的名字，我们会使用“队列编号”作为 RoutingKey ，然后路由消息到每个子 Queue 中。</li></ul> <h2 id="_11-4-rabbitconfig"><a href="#_11-4-rabbitconfig" class="header-anchor">#</a> 11.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，添加 Direct Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java


@Configuration
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo10Queue0() {
            return new Queue(Demo10Message.QUEUE_0);
        }
        @Bean
        public Queue demo10Queue1() {
            return new Queue(Demo10Message.QUEUE_1);
        }
        @Bean
        public Queue demo10Queue2() {
            return new Queue(Demo10Message.QUEUE_2);
        }
        @Bean
        public Queue demo10Queue3() {
            return new Queue(Demo10Message.QUEUE_3);
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo10Exchange() {
            return new DirectExchange(Demo10Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        @Bean
        public Binding demo10Binding0() {
            return BindingBuilder.bind(demo10Queue0()).to(demo10Exchange()).with(&quot;0&quot;);
        }
        @Bean
        public Binding demo10Binding1() {
            return BindingBuilder.bind(demo10Queue1()).to(demo10Exchange()).with(&quot;1&quot;);
        }
        @Bean
        public Binding demo10Binding2() {
            return BindingBuilder.bind(demo10Queue2()).to(demo10Exchange()).with(&quot;2&quot;);
        }
        @Bean
        public Binding demo10Binding3() {
            return BindingBuilder.bind(demo10Queue3()).to(demo10Exchange()).with(&quot;3&quot;);
        }

    }

}
</code></pre></div><ul><li>首先，创建了四个<strong>子</strong> Queue 。</li> <li>然后，创建了一个 Exchange 。</li> <li>最后，创建了四个 Bingding ，对应每一个<strong>子</strong> Queue ，RoutingKey 为队列编号。</li></ul> <h2 id="_11-5-demo10producer"><a href="#_11-5-demo10producer" class="header-anchor">#</a> 11.5 Demo10Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo01Producer.java" target="_blank" rel="noopener noreferrer">Demo01Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息到<strong>子</strong> Queue 中。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo10Producer.java

@Component
public class Demo10Producer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void syncSend(Integer id) {
        // 创建 Demo10Message 消息
        Demo10Message message = new Demo10Message();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(Demo10Message.EXCHANGE, this.getRoutingKey(id), message);
    }

    private String getRoutingKey(Integer id) {
        return String.valueOf(id % Demo10Message.QUEUE_COUNT);
    }

}
</code></pre></div><ul><li>发送消息时，我们对 <code>Demo10Message.id % 队列编号</code> 进行取余，获得<strong>队列编号</strong>作为 RoutingKey ，从而路由消息到对应的<strong>子</strong> Queue 中。</li></ul> <h2 id="_11-6-demo10consumer"><a href="#_11-6-demo10consumer" class="header-anchor">#</a> 11.6 Demo10Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo10Consumer.java" target="_blank" rel="noopener noreferrer">Demo10Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，<strong>严格</strong>消费<strong>顺序</strong>消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo10Consumer.java

@Component
@RabbitListener(queues = Demo10Message.QUEUE_0)
@RabbitListener(queues = Demo10Message.QUEUE_1)
@RabbitListener(queues = Demo10Message.QUEUE_2)
@RabbitListener(queues = Demo10Message.QUEUE_3)
public class Demo10Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler(isDefault = true)
    public void onMessage(Message&lt;Demo10Message&gt; message) {
        logger.info(&quot;[onMessage][线程编号:{} Queue:{} 消息编号：{}]&quot;, Thread.currentThread().getId(), getQueue(message),
                message.getPayload().getId());
    }

    private static String getQueue(Message&lt;Demo10Message&gt; message) {
        return message.getHeaders().get(&quot;amqp_consumerQueue&quot;, String.class);
    }

}
</code></pre></div><ul><li>为了实现每个<strong>子</strong> Queue 能够被每个 Consumer <strong>串行</strong>消费，从而实现基于<strong>子</strong> Queue 的<strong>并行</strong>的<strong>严格</strong>消费<strong>顺序</strong>消息，我们只好在类上添了四个 <code>@RabbitListener</code> 注解，每个对应一个<strong>子</strong> Queue 。</li> <li>如果胖友使用一个 <code>@RabbitListener</code> 注解，并添加四个<strong>子</strong> Queue ，然后设置 <code>concurrency = 4</code> 时，实际是并发四个线程，消费四个<strong>子</strong> Queue 的消息，无法保证<strong>严格</strong>消费<strong>顺序</strong>消息。</li></ul> <h2 id="_11-7-简单测试"><a href="#_11-7-简单测试" class="header-anchor">#</a> 11.7 简单测试</h2> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-orderly/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo10ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo10ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写一个单元测试方法，发送 8 条消息，观察顺序消费情况。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo10ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo10ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo10Producer producer;

    @Test
    public void testSyncSend() throws InterruptedException {
        for (int i = 0; i &lt; 2; i++) {
            for (int id = 0; id &lt; 4; id++) {
                producer.syncSend(id);
//            logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);
            }
        }

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><ul><li>发送 2 轮消息，每一轮消息的编号都是 0 至 3 。</li></ul> <p>执行单元测试方法，控制台输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code># 线程编号为 21
2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#2-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:21 Queue:QUEUE_DEMO_10-2 消息编号：2]
2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#2-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:21 Queue:QUEUE_DEMO_10-2 消息编号：2]

# 线程编号为 17
2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:17 Queue:QUEUE_DEMO_10-0 消息编号：0]
2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:17 Queue:QUEUE_DEMO_10-0 消息编号：0]

# 线程编号为 23
2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#3-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:23 Queue:QUEUE_DEMO_10-3 消息编号：3]
2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#3-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:23 Queue:QUEUE_DEMO_10-3 消息编号：3]

# 线程编号为 19
2019-12-15 20:04:59.262  INFO 99104 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:19 Queue:QUEUE_DEMO_10-1 消息编号：1]
2019-12-15 20:04:59.265  INFO 99104 --- [ntContainer#1-1] c.i.s.l.r.consumer.Demo10Consumer        : [onMessage][线程编号:19 Queue:QUEUE_DEMO_10-1 消息编号：1]
</code></pre></div><ul><li>相同编号的消息，被投递到相同的<strong>子</strong> Queue ，被相同的线程所消费。符合预期~</li></ul> <h1 id="_12-事务消息"><a href="#_12-事务消息" class="header-anchor">#</a> 12. 事务消息</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-transaction<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p></blockquote> <p>RabbitMQ 内置提供事务消息的支持。对事务消息的概念不了解的胖友，可以看看 <a href="http://www.iocoder.cn/RabbitMQ/message-confirmation-mechanism-transaction-Confirm/?self" target="_blank" rel="noopener noreferrer">《RabbitMQ 之消息确认机制（事务 + Confirm）》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文章的<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「事务机制」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>小节。</p> <p>不过 RabbitMQ 提供的并不是<strong>完整的</strong>的事务消息的支持，缺少了<strong>回查机制</strong>。目前，常用的分布式消息队列，只有 RocketMQ 提供了完整的事务消息的支持，具体的可以看看<a href="http://www.iocoder.cn/Spring-Boot/RocketMQ/?self" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 消息队列 RocketMQ 入门》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「9. 事务消息」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>小节，😈 暂时不拓展开来讲。</p> <p>下面，我们开始本小节的示例。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-transaction<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_12-1-引入依赖"><a href="#_12-1-引入依赖" class="header-anchor">#</a> 12.1 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_12-2-应用配置文件"><a href="#_12-2-应用配置文件" class="header-anchor">#</a> 12.2 应用配置文件</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_12-3-demo11message"><a href="#_12-3-demo11message" class="header-anchor">#</a> 12.3 Demo11Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo11Message.java" target="_blank" rel="noopener noreferrer">Demo11Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_12-4-rabbitconfig"><a href="#_12-4-rabbitconfig" class="header-anchor">#</a> 12.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，额外配置事务相关的。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Configuration
@EnableTransactionManagement
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo11Queue() {
            return new Queue(Demo11Message.QUEUE, // Queue 名字
                    true, // durable: 是否持久化
                    false, // exclusive: 是否排它
                    false); // autoDelete: 是否自动删除
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo11Exchange() {
            return new DirectExchange(Demo11Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        // Exchange：Demo11Message.EXCHANGE
        // Routing key：Demo11Message.ROUTING_KEY
        // Queue：Demo11Message.QUEUE
        @Bean
        public Binding demo11Binding() {
            return BindingBuilder.bind(demo11Queue()).to(demo11Exchange()).with(Demo11Message.ROUTING_KEY);
        }

    }

    @Bean
    public RabbitTransactionManager rabbitTransactionManager(ConnectionFactory connectionFactory, RabbitTemplate rabbitTemplate) {
        // &lt;Y&gt; 设置 RabbitTemplate 支持事务
        rabbitTemplate.setChannelTransacted(true);

        // 创建 RabbitTransactionManager 对象
        return new RabbitTransactionManager(connectionFactory);
    }

}
</code></pre></div><ul><li>DirectExchangeDemoConfiguration 配置类，用于定义 Queue、Exchange、Binding 的配置。</li> <li>在类上，添加 <code>@EnableTransactionManagement</code> 注解，开启<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html" target="_blank" rel="noopener noreferrer">Spring Transaction<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的支持。</li> <li>在 <code>#rabbitTransactionManager()</code> 方法，创建 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/transaction/RabbitTransactionManager.java" target="_blank" rel="noopener noreferrer">RabbitTransactionManager<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 事务管理器 Bean 。</li> <li>在 <code>&lt;Y&gt;</code> 处，标记创建的 RabbitMQ Channel 是事务性的，从而可以使用 RabbitMQ 的事务消息。</li></ul> <p>因为 Spring-AMQP 通过 RabbitTransactionManager 来实现对 Spring Transaction 的集成，所以在实际开发中，我们只需要配合使用 <code>@Transactional</code> 注解，来声明事务即可。</p> <h2 id="_12-5-demo11producer"><a href="#_12-5-demo11producer" class="header-anchor">#</a> 12.5 Demo11Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo11Producer.java" target="_blank" rel="noopener noreferrer">Demo11Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo11Producer.java

@Component
public class Demo11Producer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Transactional
    public void syncSend(Integer id) throws InterruptedException {
        // 创建 Demo11Message 消息
        Demo11Message message = new Demo11Message();
        message.setId(id);
        // 同步发送消息
        rabbitTemplate.convertAndSend(Demo11Message.EXCHANGE, Demo11Message.ROUTING_KEY, message);
        logger.info(&quot;[syncSend][发送编号：[{}] 发送成功]&quot;, id);

        // &lt;X&gt; 等待
        Thread.sleep(10 * 1000L);
    }

}
</code></pre></div><ul><li><p>在发送消息方法上，我们添加了 <code>@Transactional</code> 注解，声明事务。因为我们创建了 RabbitTransactionManager 事务管理器，所以这里会创建 RabbitMQ 事务。</p></li> <li><p>在<X>处，我们故意等待</X></p> <div class="language- extra-class"><pre class="language-text"><code></code></pre></div></li></ul> <p>Thread#sleep(long millis)</p> <div class="language- extra-class"><pre class="language-text"><code>
10 秒，判断 RabbitMQ 事务是否生效。

- 如果同步发送消息成功后，Consumer 立即消费到该消息，说明未生效。
- 如果 Consumer 是 10 秒之后，才消费到该消息，说明已生效。

## 12.6 Demo11Consumer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer) 包下，创建 [Demo11Consumer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo11Consumer.java) 类，消费消息。

和[「3.1.7 Demo01Consumer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)基本一致，差别在于消费的队列是 `&quot;QUEUE_DEMO_11&quot;` 。

## 12.7 简单测试

创建 [Demo11ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-transaction/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo11ProducerTest.java) 测试类，编写单元测试方法，测试 Producer 发送**事务**消息的效果。代码如下：



</code></pre></div><p>// Demo11ProducerTest.java</p> <p>@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo11ProducerTest {</p> <div class="language- extra-class"><pre><code>@Autowired
private Demo11Producer producer;

@Test
public void testSyncSend() throws InterruptedException {
    int id = (int) (System.currentTimeMillis() / 1000);
    producer.syncSend(id);

    // 阻塞等待，保证消费
    new CountDownLatch(1).await();
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


执行单元测试方法，控制台输出如下：



</code></pre></div><p>// Producer 成功同步发送了 1 条消息。此时，事务并未提交
2019-12-12 22:03:05.525  INFO 17729 --- [           main] c.i.s.l.r.producer.Demo11Producer        : [syncSend][发送编号：[1576159385] 发送成功]</p> <p>// 10 秒后，Producer 提交事务。
// 此时，Consumer 消费到该消息。
2019-12-12 22:03:15.548  INFO 17729 --- [ntContainer#4-1] c.i.s.l.r.consumer.Demo11Consumer        : [onMessage][线程编号:25 消息内容：Demo11Message{id=1576159385}]</p> <div class="language- extra-class"><pre class="language-text"><code>


- Consumer 在事务消息提交后，消费到该消息。符合预期~

# 13. 消费者的消息确认

&gt; 示例代码对应仓库：[lab-04-rabbitmq-demo-ack](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack) 。

在 RabbitMQ 中，Consumer 有两种消息确认的方式：

- 方式一，自动确认。
- 方式二，手动确认。

对于**自动确认**的方式，RabbitMQ Broker 只要将消息写入到 TCP Socket 中成功，就认为该消息投递成功，而无需 Consumer **手动确认**。

对于**手动确认**的方式，RabbitMQ Broker 将消息发送给 Consumer 之后，由 Consumer **手动确认**之后，才任务消息投递成功。

实际场景下，因为自动确认存在可能**丢失消息**的情况，所以在对**可靠性**有要求的场景下，我们基本采用手动确认。当然，如果允许消息有一定的丢失，对**性能**有更高的产经下，我们可以考虑采用自动确认。

😈 更多关于消费者的消息确认的内容，胖友可以阅读如下的文章：

- [《Consumer Acknowledgements and Publisher Confirms》](https://www.rabbitmq.com/confirms.html) 的消费者部分的内容，对应中文翻译为 [《消费者应答（ACK）和发布者确认（Confirm）》](https://blog.bossma.cn/rabbitmq/consumer-ack-and-publisher-confirm/) 。
- [《RabbitMQ 之消息确认机制（事务 + Confirm）》](http://www.iocoder.cn/RabbitMQ/message-confirmation-mechanism-transaction-Confirm/?self) 文章的[「消息确认（Consumer端）」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)小节。

在 Spring-AMQP 中，在 [AcknowledgeMode](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/AcknowledgeMode.java) 中，定义了三种消息确认的方式：



</code></pre></div><p>// AcknowledgeMode.java</p> <p>/**</p> <ul><li>No acks - {@code autoAck=true} in {@code Channel.basicConsume()}.
*/
NONE, // 对应 Consumer 的自动确认</li></ul> <p>/**</p> <ul><li>Manual acks - user must ack/nack via a channel aware listener.
*/
MANUAL, // 对应 Consumer 的手动确认，由开发者在消费逻辑中，手动进行确认。</li></ul> <p>/**</p> <ul><li>Auto - the container will issue the ack/nack based on whether</li> <li>the listener returns normally, or throws an exception.</li> <li><p><em>Do not confuse with RabbitMQ {@code autoAck} which is
</em></p></li> <li>represented by {@link #NONE} here.
*/
AUTO; // 对应 Consumer 的手动确认，在消费消息完成（包括正常返回、和抛出异常）后，由 Spring-AMQP 框架来“自动”进行确认。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>


- 实际上，就是将**手动确认**进一步细分，提供了由 Spring-AMQP 提供 Consumer 级别的自动确认。

**在上述的示例中，我们都采用了 Spring-AMQP 默认的 `AUTO` 模式**。下面，我们来搭建一个 `MANUAL` 模式，手动确认的示例。考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-ack](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack) 项目。

## 13.1 引入依赖

和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/pom.xml) 文件。

## 13.2 应用配置文件

在 [`resources`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/resources) 目录下，创建 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/resources/application.yaml) 配置文件。配置如下：



</code></pre></div><p>spring:</p> <h1 id="rabbitmq-配置项-对应-rabbitproperties-配置类"><a href="#rabbitmq-配置项-对应-rabbitproperties-配置类" class="header-anchor">#</a> RabbitMQ 配置项，对应 RabbitProperties 配置类</h1> <p>rabbitmq:
host: 127.0.0.1 # RabbitMQ 服务的地址
port: 5672 # RabbitMQ 服务的端口
username: guest # RabbitMQ 服务的账号
password: guest # RabbitMQ 服务的密码
listener:
simple:
acknowledge-mode: manual # 配置 Consumer 手动提交</p> <div class="language- extra-class"><pre class="language-text"><code>


- 相比[「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)来说，我们通过**新增** `spring.rabbitmq.listener.simple.acknowledge-mode=true` 配置项，来配置 Consumer 手动提交。

## 13.3 Demo12Message

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message) 包下，创建 [Demo12Message](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo12Message.java) 消息类，提供给当前示例使用。

和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。

## 13.4 RabbitConfig

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，配置相关的 Exchange、Queue、Binding 。

和[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。

## 13.5 Demo12Producer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo12Producer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/Demo12Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。

和[「3.1.6 Demo01Producer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、RoutingKey 名字不同。

## 13.6 Demo12Consumer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer) 包下，创建 [Demo09Consumer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo12Consumer.java) 类，消费消息。代码如下：



</code></pre></div><p>// Demo12Consumer.java</p> <p>@Component
@RabbitListener(queues = Demo12Message.QUEUE)
public class Demo12Consumer {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

@RabbitHandler
public void onMessage(Demo12Message message, Channel channel,
                      @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) throws IOException {
    logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    // 提交消费进度
    if (message.getId() % 2 == 1) {
        // ack 确认消息
        // 第二个参数 multiple ，用于批量确认消息，为了减少网络流量，手动确认可以被批处。
        // 1. 当 multiple 为 true 时，则可以一次性确认 deliveryTag 小于等于传入值的所有消息
        // 2. 当 multiple 为 false 时，则只确认当前 deliveryTag 对应的消息
        channel.basicAck(deliveryTag, false);
    }
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 在消费方法上，我们增加类型为 [Channel](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java) 的方法参数，和 `deliveryTag` 。通过调用其 `Channel#basicAck(deliveryTag, multiple)` 方法，可以进行消息的确认。这里，艿艿添加了比较详细的注释说明，胖友可以自己瞅瞅噢。
- 在 `@RabbitListener` 注解的 `ackMode` 属性，我们可以设置自定义的 AcknowledgeMode 模式。
- 在消费逻辑中，我们故意只提交消费的消息的 `Demo12Message.id` 为**奇数**的消息。😈 这样，我们只需要发送一条 `id=1` ，一条 `id=2` 的消息，如果第二条的消费进度没有被提交，就可以说明手动提交消费进度成功。

## 13.7 简单测试

创建 [Demo12ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-ack/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo12ProducerTest.java) 测试类，编写单元测试方法，测试手动提交消费进度。代码如下：



</code></pre></div><p>// Demo12ProducerTest.java</p> <p>@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo12ProducerTest {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

@Autowired
private Demo12Producer producer;

@Test
public void testSyncSend() throws InterruptedException {
    for (int id = 1; id &lt;= 2; id++) {
        producer.syncSend(id);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);
    }

    // 阻塞等待，保证消费
    new CountDownLatch(1).await();
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


执行 `#testSyncSend()` 单元测试，输出日志如下：



</code></pre></div><p>// Producer 同步发送 2 条消息成功
2019-12-13 00:19:33.403  INFO 45869 --- [           main] c.i.s.l.r.producer.Demo12ProducerTest    : [testSyncSend][发送编号：[1] 发送成功]
2019-12-13 00:19:33.406  INFO 45869 --- [           main] c.i.s.l.r.producer.Demo12ProducerTest    : [testSyncSend][发送编号：[2] 发送成功]</p> <p>// Demo08Consumer 消费 2 条消息成功
2019-12-13 00:19:33.420  INFO 45869 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo12Consumer        : [onMessage][线程编号:17 消息内容：Demo12Message{id=1}]
2019-12-13 00:19:33.421  INFO 45869 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo12Consumer        : [onMessage][线程编号:17 消息内容：Demo12Message{id=2}]</p> <div class="language- extra-class"><pre class="language-text"><code>


此时，如果我们使用 [RabbitMQ Management](https://static.iocoder.cn/7c5541295505e7a3be4ac7ab2882feeb) 来查看 `&quot;DEMO_12&quot;` 的该消费者：


![](https://raw.githubusercontent.com/lichengcan/images/main/02.png)

- 有 1 条消息的未确认，符合预期~

# 14. 生产者的发送确认

在 RabbitMQ 中，**默认**情况下，Producer 发送消息的方法，只保证将消息写入到 TCP Socket 中成功，并不保证消息发送到 RabbitMQ Broker 成功，并且持久化消息到磁盘成功。

也就是说，我们上述的示例，Producer 在发送消息都不是绝对可靠，是存在丢失消息的可能性。

不过不用担心，在 RabbitMQ 中，Producer 采用 Confirm 模式，实现发送消息的确认机制，以保证消息发送的可靠性。实现原理如下：

- 首先，Producer 通过调用 [`Channel#confirmSelect()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1278-L1283) 方法，将 Channel 设置为 Confirm 模式。
- 然后，在该 Channel 发送的消息时，需要先通过 [`Channel#getNextPublishSeqNo()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1285-L1290) 方法，给发送的消息分配一个唯一的 ID 编号(`seqNo` 从 1 开始递增)，再发送该消息给 RabbitMQ Broker 。
- 之后，RabbitMQ Broker 在接收到该消息，并被路由到相应的队列之后，会发送一个包含消息的唯一编号(`deliveryTag`)的确认给 Producer 。

通过 `seqNo` 编号，将 Producer 发送消息的“请求”，和 RabbitMQ Broker 确认消息的“响应”串联在一起。

通过这样的方式，Producer 就可以知道消息是否成功发送到 RabbitMQ Broker 之中，保证消息发送的可靠性。不过要注意，整个执行的过程实际是**异步**，需要我们调用 [`Channel#waitForConfirms()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1293-L1329) 方法，**同步**阻塞等待 RabbitMQ Broker 确认消息的“响应”。

也因此，Producer 采用 Confirm 模式时，有三种编程方式：

- 【同步】普通 Confirm 模式：Producer 每发送一条消息后，调用 `Channel#waitForConfirms()` 方法，等待服务器端 Confirm 。

- 【同步】批量 Confirm 模式：Producer 每发送一批消息后，调用`Channel#waitForConfirms()` 方法，等待服务器端 Confirm 。

  &gt; 本质上，和「普通 Confirm 模式」是一样的。

- 【异步】异步 Confirm 模式：Producer 提供一个回调方法，RabbitMQ Broker 在 Confirm 了一条或者多条消息后，Producer 会回调这个方法。

😈 更多关于 Producer 的 Confirm 模式的内容，胖友可以阅读如下的文章：

- [《Consumer Acknowledgements and Publisher Confirms》](https://www.rabbitmq.com/confirms.html) 的生产者部分的内容，对应中文翻译为 [《消费者应答（ACK）和发布者确认（Confirm）》](https://blog.bossma.cn/rabbitmq/consumer-ack-and-publisher-confirm/) 。
- [《RabbitMQ 之消息确认机制（事务 + Confirm）》](http://www.iocoder.cn/RabbitMQ/message-confirmation-mechanism-transaction-Confirm/?self) 文章的[「Confirm 模式」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)小节。

在 Spring-AMQP 中，在 [ConfirmType](https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/connection/CachingConnectionFactory.java#L145-L167) 中，定义了三种消息确认的方式：



</code></pre></div><p>// CachingConnectionFactory#ConfirmType.java</p> <p>public enum ConfirmType {</p> <div class="language- extra-class"><pre><code>/**
 * Use {@code RabbitTemplate#waitForConfirms()} (or {@code waitForConfirmsOrDie()}
 * within scoped operations.
 */
SIMPLE, // 使用同步的 Confirm 模式

/**
 * Use with {@code CorrelationData} to correlate confirmations with sent
 * messsages.
 */
CORRELATED, // 使用异步的 Confirm 模式

/**
 * Publisher confirms are disabled (default).
 */
NONE // 不使用 Confirm 模式
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


**在上述的示例中，我们都采用了 Spring-AMQP 默认的 `NONE` 模式**。下面，我们来搭建两个示例：

- 在[「14.1 同步 Confirm 模式」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 中，我们会使用 `SIMPLE` 类型，实现同步的 Confirm 模式。
- 在[「14.2 异步 Confirm 模式」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 中，我们会使用 `CORRELATED` 类型，使用异步的 Confirm 模式。

## 14.1 同步 Confirm 模式

&gt; 示例代码对应仓库：[lab-04-rabbitmq-demo-confirm](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm) 。

在本小节中，我们会使用 `ConfirmType.SIMPLE` 类型，实现同步的 Confirm 模式。

要注意，这里的**同步**，指的是我们通过调用 [`Channel#waitForConfirms()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1293-L1329) 方法，**同步**阻塞等待 RabbitMQ Broker 确认消息的“响应”。

考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-confirm](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm) 项目。

### 14.1.1 引入依赖

和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/pom.xml) 文件。

### 14.1.2 应用配置文件

在 [`resources`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/resources) 目录下，创建 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/resources/application.yaml) 配置文件。配置如下：



</code></pre></div><p>spring:</p> <h1 id="rabbitmq-配置项-对应-rabbitproperties-配置类-2"><a href="#rabbitmq-配置项-对应-rabbitproperties-配置类-2" class="header-anchor">#</a> RabbitMQ 配置项，对应 RabbitProperties 配置类</h1> <p>rabbitmq:
host: 127.0.0.1 # RabbitMQ 服务的地址
port: 5672 # RabbitMQ 服务的端口
username: guest # RabbitMQ 服务的账号
password: guest # RabbitMQ 服务的密码
publisher-confirm-type: simple # 设置 Confirm 类型为 SIMPLE 。</p> <div class="language- extra-class"><pre class="language-text"><code>


- 相比[「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)来说，我们通过**新增** `spring.rabbitmq.publisher-confirm-type=simple` 配置项，设置 Confirm 类型为 `ConfirmType.SIMPLE` 。

在该类型下，Spring-AMQP 在创建完 RabbitMQ Channel 之后，会**自动**调用 [`Channel#confirmSelect()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1278-L1283) 方法，将 Channel 设置为 Confirm 模式。

### 14.1.3 Demo13Message

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message) 包下，创建 [Demo13Message](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo13Message.java) 消息类，提供给当前示例使用。

和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。

### 14.1.4 RabbitConfig

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，配置相关的 Exchange、Queue、Binding 。

和[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。

### 14.1.4 Demo13Producer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo13Producer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。



</code></pre></div><p>// Demo13Producer.java</p> <p>@Component
public class Demo13Producer {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

@Autowired
private RabbitTemplate rabbitTemplate;

public void syncSend(Integer id) {
    // 创建 Demo13Message 消息
    Demo13Message message = new Demo13Message();
    message.setId(id);
    // 同步发送消息
    rabbitTemplate.invoke(new RabbitOperations.OperationsCallback&lt;Object&gt;() {

        @Override
        public Object doInRabbit(RabbitOperations operations) {
            // 同步发送消息
            operations.convertAndSend(Demo13Message.EXCHANGE, Demo13Message.ROUTING_KEY, message);
            logger.info(&quot;[doInRabbit][发送消息完成]&quot;);
            // 等待确认
            operations.waitForConfirms(0); // timeout 参数，如果传递 0 ，表示无限等待
            logger.info(&quot;[doInRabbit][等待 Confirm 完成]&quot;);
            return null;
        }

    }, new ConfirmCallback() {

        @Override
        public void handle(long deliveryTag, boolean multiple) throws IOException {
            logger.info(&quot;[handle][Confirm 成功]&quot;);
        }

    }, new ConfirmCallback() {

        @Override
        public void handle(long deliveryTag, boolean multiple) throws IOException {
            logger.info(&quot;[handle][Confirm 失败]&quot;);
        }

    });

}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 在 RabbitTemplate 提供的 API 方法中，如果 Producer 要使用同步的 Confirm 模式，需要调用 `#invoke(action, acks, nacks)` 方法。代码如下：

</code></pre></div><p>// RabbitOperations.java
// RabbitTemplate 实现了 RabbitOperations 接口</p> <p>/**</p> <ul><li>Invoke operations on the same channel.</li> <li>If callbacks are needed, both callbacks must be supplied.</li> <li>@param action the callback.</li> <li>@param acks a confirm callback for acks.</li> <li>@param nacks a confirm callback for nacks.</li> <li>@param <T> the return type.</T></li> <li>@return the result of the action method.</li> <li>@since 2.1
*/
@Nullable
<T> T invoke(OperationsCallback<T> action, @Nullable com.rabbitmq.client.ConfirmCallback acks,
@Nullable com.rabbitmq.client.ConfirmCallback nacks);</T></T></li></ul> <div class="language- extra-class"><pre class="language-text"><code>


- 因为 Confirm 模式需要基于**相同** Channel ，所以我们需要使用该方法。
- 在方法参数 `action` 中，我们可以自定义操作。
- 在方法参数 `acks` 中，定义接收到 RabbitMQ Broker 的成功“响应”时的成回调。
- 在方法参数 `nacks` 中，定义接收到 RabbitMQ Broker 的失败“响应”时的成回调。

&gt; - 当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息。
&gt; - 如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。

- 具体的发送方法的代码，胖友根据艿艿的注释，进行理解下。

### 14.1.5 Demo13Consumer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer) 包下，创建 [Demo13Consumer](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo13Consumer.java) 类，消费消息。

和[「3.1.7 Demo01Consumer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)基本一致，差别在于消费的队列是 `&quot;QUEUE_DEMO_13&quot;` 。

### 14.1.6 简单测试

创建 [Demo13ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13ProducerTest.java) 测试类，编写单元测试方法，调用 Demo13Producer 发送消息的方法。代码如下：



</code></pre></div><p>// Demo13ProducerTest.java</p> <p>@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo13ProducerTest {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

@Autowired
private Demo13Producer producer;

@Test
public void testSyncSend() throws InterruptedException {
    int id = (int) (System.currentTimeMillis() / 1000);
    producer.syncSend(id);
    logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

    // 阻塞等待，保证消费
    new CountDownLatch(1).await();
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


执行 `#testSyncSend()` 单元测试，输出日志如下：



</code></pre></div><p>// 主线程，Producer 发送 1 条消息完成。
2019-12-13 12:49:13.680  INFO 13247 --- [           main] c.i.s.l.r.producer.Demo13Producer        : [doInRabbit][发送消息完成]</p> <p>// AMQConnection 线程，Producer 确认收到 RabbitMQ Broker 对该消息的成功“响应” 。
2019-12-13 12:49:13.689  INFO 13247 --- [ 127.0.0.1:5672] c.i.s.l.r.producer.Demo13Producer        : [handle][Confirm 成功]</p> <p>// 主线程，Producer 等待该消息的 Confirm 完成。
2019-12-13 12:49:13.689  INFO 13247 --- [           main] c.i.s.l.r.producer.Demo13Producer        : [doInRabbit][等待 Confirm 完成]</p> <p>// 单元测试，打印下日志，可以忽略
2019-12-13 12:49:13.694  INFO 13247 --- [           main] c.i.s.l.r.producer.Demo13ProducerTest    :
[testSyncSend][发送编号：[1576212553] 发送成功]</p> <p>// 消费者的线程，Consumer 消费到该消息
2019-12-13 12:49:13.699  INFO 13247 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo13Consumer        : [onMessage][线程编号:17 消息内容：Demo13Message{id=1576212553}]</p> <div class="language- extra-class"><pre class="language-text"><code>


- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。

## 14.2 异步 Confirm 模式

&gt; 示例代码对应仓库：[lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 。

在本小节中，我们会使用 `ConfirmType.SIMPLE` 类型，实现异步的 Confirm 模式。

考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 项目。

### 14.2.1 引入依赖

和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/pom.xml) 文件。

### 14.2.2 应用配置文件

在 [`resources`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/resources) 目录下，创建 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/resources/application.yaml) 配置文件。配置如下：



</code></pre></div><p>spring:</p> <h1 id="rabbitmq-配置项-对应-rabbitproperties-配置类-3"><a href="#rabbitmq-配置项-对应-rabbitproperties-配置类-3" class="header-anchor">#</a> RabbitMQ 配置项，对应 RabbitProperties 配置类</h1> <p>rabbitmq:
host: 127.0.0.1 # RabbitMQ 服务的地址
port: 5672 # RabbitMQ 服务的端口
username: guest # RabbitMQ 服务的账号
password: guest # RabbitMQ 服务的密码
publisher-confirm-type: correlated # 设置 Confirm 类型为 CORRELATED 。</p> <div class="language- extra-class"><pre class="language-text"><code>


- 相比[「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)来说，我们通过**新增** `spring.rabbitmq.publisher-confirm-type=correlated` 配置项，设置 Confirm 类型为 `ConfirmType.CORRELATED` 。

在该类型下，Spring-AMQP 在创建完 RabbitMQ Channel 之后，也会**自动**调用 [`Channel#confirmSelect()`](https://github.com/rabbitmq/rabbitmq-java-client/blob/master/src/main/java/com/rabbitmq/client/Channel.java#L1278-L1283) 方法，将 Channel 设置为 Confirm 模式。

### 14.2.3 Demo13Message

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/) 包下，创建 [Demo13Message](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo13Message.java) 消息类，提供给当前示例使用。

和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。

### 14.2.4 RabbitConfig

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，配置相关的 Exchange、Queue、Binding 。

和[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。

### 14.2.5 RabbitProducerConfirmCallback

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.core`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/) 包下，创建 [RabbitProducerConfirmCallback](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitProducerConfirmCallback.java) 类，实现 [RabbitTemplate.ConfirmCallback](https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java#L2712-L2727) 接口，提供 Producer 收到 RabbitMQ 确认消息的“响应”的回调。代码如下：



</code></pre></div><p>// RabbitProducerConfirmCallback.java</p> <p>@Component
public class RabbitProducerConfirmCallback implements RabbitTemplate.ConfirmCallback {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

public RabbitProducerConfirmCallback(RabbitTemplate rabbitTemplate) {
    rabbitTemplate.setConfirmCallback(this);
}

@Override
public void confirm(CorrelationData correlationData, boolean ack, String cause) {
    if (ack) {
        logger.info(&quot;[confirm][Confirm 成功 correlationData: {}]&quot;, correlationData);
    } else {
        logger.error(&quot;[confirm][Confirm 失败 correlationData: {} cause: {}]&quot;, correlationData, cause);
    }
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 在构造方法中，把自己设置到 RabbitTemplate 中，作为 Confirm 的回调。
- 在 `#confirm(...)` 方法中，根据是否 `ack` 成功，打印不同的日志。

### 14.2.6 Demo13Producer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo13Producer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。



</code></pre></div><p>// Demo13Producer.java</p> <p>@Component
public class Demo13Producer {</p> <div class="language- extra-class"><pre><code>@Autowired
private RabbitTemplate rabbitTemplate;

public void syncSend(Integer id) {
    // 创建 Demo13Message 消息
    Demo13Message message = new Demo13Message();
    message.setId(id);
    // 同步发送消息
    rabbitTemplate.convertAndSend(Demo13Message.EXCHANGE, Demo13Message.ROUTING_KEY, message);
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 不需要像[「14.1.4 Demo13Producer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一样，而是直接像我们其它示例一样，直接使用 RabbitTemplate 的 `#convertAndSend(...)` 等等方法即可。

### 14.2.7 Demo13Consumer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/) 包下，创建 [Demo13Consumer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo13Consumer.java) 类，消费消息。

和[「3.1.7 Demo01Consumer」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)基本一致，差别在于消费的队列是 `&quot;QUEUE_DEMO_13&quot;` 。

### 14.2.8 简单测试

创建 [Demo13ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 测试类，编写单元测试方法，调用 Demo13Producer 发送消息的方法。代码如下：



</code></pre></div><p>// Demo13ProducerTest.java</p> <p>@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo13ProducerTest {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

@Autowired
private Demo13Producer producer;

@Test
public void testSyncSend() throws InterruptedException {
    int id = (int) (System.currentTimeMillis() / 1000);
    producer.syncSend(id);
    logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

    // 阻塞等待，保证消费
    new CountDownLatch(1).await();
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


执行 `#testSyncSend()` 单元测试，输出日志如下：



</code></pre></div><p>// 单元测试，打印下日志，可以忽略
2019-12-13 17:17:45.849  INFO 69003 --- [           main] c.i.s.l.r.producer.Demo13ProducerTest    :
[testSyncSend][发送编号：[1576228665] 发送成功]</p> <p>// RabbitConnectionFactory 线程，Producer 确认收到 RabbitMQ Broker 对该消息的成功“响应” 。
// 因为我们在 Demo13Producer 发送消息的时候，并未传入 CorrelationData 参数，所以为 null 。
2019-12-13 17:17:45.859  INFO 69003 --- [nectionFactory1] .i.s.l.r.c.RabbitProducerConfirmCallback : [confirm][Confirm 成功 correlationData: null]</p> <p>// 消费者的线程，Consumer 消费到该消息
2019-12-13 17:17:45.873  INFO 69003 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo13Consumer        : [onMessage][线程编号:17 消息内容：Demo13Message{id=1576228665}]</p> <div class="language- extra-class"><pre class="language-text"><code>


- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。

## 14.3 ReturnCallback

&gt; 示例代码对应仓库：[lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 。

当 Producer 成功发送消息到 RabbitMQ Broker 时，但是在通过 Exchange 进行**匹配不到** Queue 时，Broker 会将该消息回退给 Producer 。

下面，我们来创建一个使用示例，继续在 [lab-04-rabbitmq-demo-confirm-async](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async) 项目改造。

### 14.3.1 RabbitProducerReturnCallback

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.core`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/) 包下，创建 [RabbitProducerReturnCallback](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitProducerReturnCallback.java) 类，实现 [RabbitTemplate.ReturnCallback](https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/core/RabbitTemplate.java#L2712-L2727) 接口，提供 Producer 收到 RabbitMQ Broker 回退消息的的回调。代码如下：



</code></pre></div><p>// RabbitProducerReturnCallback.java</p> <p>@Component
public class RabbitProducerReturnCallback implements RabbitTemplate.ReturnCallback {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

public RabbitProducerReturnCallback(RabbitTemplate rabbitTemplate) {
    rabbitTemplate.setReturnCallback(this);
}

@Override
public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
    logger.error(&quot;[returnedMessage][message: [{}] replyCode: [{}] replyText: [{}] exchange: [{}] routingKey: [{}]]&quot;,
            message, replyCode, replyText, exchange, routingKey);
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 在构造方法中，把自己设置到 RabbitTemplate 中，作为消息 Return 的回调。
- 在 `#returnedMessage(...)` 方法中，打印错误日志。当然，具体怎么处理，胖友可以根据自己的需要哈。

### 14.3.2 Demo13Producer

修改 [Demo13Producer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13Producer.java) 类，增加一个发送无法匹配到 Queue 的消息的方法。代码如下：



</code></pre></div><p>// Demo13Producer.java</p> <p>public void syncSendReturn(Integer id) {
// 创建 Demo13Message 消息
Demo13Message message = new Demo13Message();
message.setId(id);
// 同步发送消息
rabbitTemplate.convertAndSend(Demo13Message.EXCHANGE, &quot;error&quot;, message);
}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 发送消息的 RoutingKey ，我们故意设置为 `error` ，达到消息无法匹配到 Queue 的效果。

### 14.3.3 简单测试

修改 [Demo13ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-confirm-async/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo13ProducerTest.java) 测试类，增加调用 Demo13Producer 新增的方法。代码如下：



</code></pre></div><p>// Demo13ProducerTest.java</p> <p>@Test
public void testSyncSendReturn() throws InterruptedException {
int id = (int) (System.currentTimeMillis() / 1000);
producer.syncSendReturn(id);
logger.info(&quot;[testSyncSendReturn][发送编号：[{}] 发送成功]&quot;, id);</p> <div class="language- extra-class"><pre><code>// 阻塞等待，保证消费
new CountDownLatch(1).await();
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


执行 `#testSyncSendReturn()` 单元测试，输出日志如下：



</code></pre></div><p>// 单元测试，打印下日志，可以忽略
2019-12-13 17:40:57.130  INFO 74326 --- [           main] c.i.s.l.r.producer.Demo13ProducerTest    : [testSyncSendReturn][发送编号：[1576230057] 发送成功]</p> <p>// RabbitConnectionFactory 线程，Producer 确认收到 RabbitMQ Broker 对该消息的退回 。
2019-12-13 17:41:02.817 ERROR 74326 --- [nectionFactory1] c.i.s.l.r.c.RabbitProducerReturnCallback : [returnedMessage][message: [(Body:'[B@4689be61(byte[187])' MessageProperties [headers={}, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, deliveryTag=0])] replyCode: [312] replyText: [NO_ROUTE] exchange: [EXCHANGE_DEMO_13] routingKey: []]</p> <p>// RabbitConnectionFactory 线程，Producer 确认收到 RabbitMQ Broker 对该消息的成功“响应” 。
// 注意，即使存在 RabbitMQ Broker 回退消息的情况，依然会收到对该消息的成功“响应”
2019-12-13 17:41:02.819  INFO 74326 --- [nectionFactory1] .i.s.l.r.c.RabbitProducerConfirmCallback : [confirm][Confirm 成功 correlationData: null]</p> <div class="language- extra-class"><pre class="language-text"><code>


- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。

# 15. RPC 远程调用

&gt; 示例代码对应仓库：[lab-04-rabbitmq-demo-rpc](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc) 。

在 RabbitMQ 中，我们可以通过 [Direct Reply-to](https://www.rabbitmq.com/direct-reply-to.html) 特性，实现 RPC 远程调用的功能。具体的实现原理，胖友自己看[《RabbitMQ 之 RPC 实现》](http://www.iocoder.cn/RabbitMQ/RPC-implementation/?self)文章，这里艿艿就不赘述了。

下面，我们来搭建一个 RPC 的示例。考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-rpc](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc) 项目。

## 15.1 引入依赖

和 [「3.1.1 引入依赖」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/pom.xml) 文件。

## 15.2 应用配置文件

和 [「3.1.2 应用配置文件」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#) 一致，见 [`application.yaml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo14ProducerTest.java) 文件。

## 15.3 Demo14Message

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.message`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message) 包下，创建 [Demo14Message](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo14Message.java) 消息类，提供给当前示例使用。

和[「3.1.4 Demo01Message」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)一致，只是 Exchange、Queue、RoutingKey 名字不同。

## 15.4 RabbitConfig

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.config`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config) 包下，创建 [RabbitConfig](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java) 配置类，添加 Direct Exchange 示例相关的 Exchange、Queue、Binding 的配置。代码如下：



</code></pre></div><p>// RabbitConfig.java</p> <p>@Configuration
public class RabbitConfig {</p> <div class="language- extra-class"><pre><code>/**
 * Direct Exchange 示例的配置类
 */
public static class DirectExchangeDemoConfiguration {

    // 创建 Queue
    @Bean
    public Queue demo01Queue() {
        return new Queue(Demo14Message.QUEUE, // Queue 名字
                false, // durable: 是否持久化
                false, // exclusive: 是否排它
                false); // autoDelete: 是否自动删除
    }

    // 创建 Direct Exchange
    @Bean
    public DirectExchange demo01Exchange() {
        return new DirectExchange(Demo14Message.EXCHANGE,
                false,  // durable: 是否持久化
                false);  // autoDelete: 是否自动删除
    }

    // 创建 Binding
    // Exchange：Demo01Message.EXCHANGE
    // Routing key：Demo01Message.ROUTING_KEY
    // Queue：Demo01Message.QUEUE
    @Bean
    public Binding demo01Binding() {
        return BindingBuilder.bind(demo01Queue()).to(demo01Exchange()).with(Demo14Message.ROUTING_KEY);
    }

}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 不同于[「3.1.5 RabbitConfig」](https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#)的配置，我们设置队列里的消息无需持久化，毕竟 RPC 是个瞬态操作。

## 15.5 Demo14Producer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.producer`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer) 包下，创建 [Demo14Producer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo14Producer.java) 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现 RPC 操作。代码如下：



</code></pre></div><p>// Demo14Producer.java</p> <p>@Component
public class Demo14Producer {</p> <div class="language- extra-class"><pre><code>@Autowired
private RabbitTemplate rabbitTemplate;

public String syncSend(Integer id) {
    // 创建 Demo01Message 消息
    Demo14Message message = new Demo14Message();
    message.setId(id);
    // &lt;1&gt; 创建 CorrelationData 对象
    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
    // &lt;2&gt; 同步发送消息，并接收结果
    return (String) rabbitTemplate.convertSendAndReceive(Demo14Message.EXCHANGE, Demo14Message.ROUTING_KEY, message,
            correlationData);
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- `&lt;1&gt;` 处，创建 CorrelationData 对象，使用 UUID 作为唯一标识。
- `&lt;2&gt;` 处，调用 `RabbitTemplate#convertSendAndReceive(exchange, routingKey, message, correlationData)` 方法，Producer 发送消息，并等待结果。该结果，是 Consumer 消费消息，返回的结果。

## 15.6 Demo14Consumer

在 [`cn.iocoder.springboot.lab04.rabbitmqdemo.consumer`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/) 包下，创建 [Demo14Consumer](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo14Consumer.java) 类，消费消息。代码如下：



</code></pre></div><p>// Demo14Consumer.java</p> <p>@Component
@RabbitListener(queues = Demo14Message.QUEUE)
public class Demo14Consumer {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

@RabbitHandler
public String onMessage(Demo14Message message) {
    logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
    // 返回结果
    return &quot;nicai&quot;;
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


- 消费完成后，额外返回了 `&quot;nicai&quot;` 字符串。

## 15.7 简单测试

创建 [Demo14ProducerTest](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-rpc/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo14ProducerTest.java) 测试类，编写单元测试方法，调用 Demo14Producer 的 RPC 的方法。代码如下：



</code></pre></div><p>// Demo14ProducerTest.java</p> <p>@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo14ProducerTest {</p> <div class="language- extra-class"><pre><code>private Logger logger = LoggerFactory.getLogger(getClass());

@Autowired
private Demo14Producer producer;

@Test
public void testSyncSend() throws InterruptedException {
    int id = (int) (System.currentTimeMillis() / 1000);
    String result = producer.syncSend(id);
    logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功 消费结果：[{}]]&quot;, id, result);

    // 阻塞等待，保证消费
    new CountDownLatch(1).await();
}
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>


执行 `#testSyncSend()` 单元测试，输出日志如下：



</code></pre></div><h1 id="demo14consumer-成功消费发送的消息"><a href="#demo14consumer-成功消费发送的消息" class="header-anchor">#</a> Demo14Consumer 成功消费发送的消息</h1> <p>2019-12-13 19:13:36.627  INFO 93696 --- [ntContainer#4-1] c.i.s.l.r.consumer.Demo14Consumer        : [onMessage][线程编号:25 消息内容：Demo14Message{id=1576235616}]</p> <h1 id="producer-打印发送消息的消费结果"><a href="#producer-打印发送消息的消费结果" class="header-anchor">#</a> Producer 打印发送消息的消费结果</h1> <p>2019-12-13 19:13:36.630  INFO 93696 --- [           main] c.i.s.l.r.producer.Demo14ProducerTest    : [testSyncSend][发送编号：[1576235616] 发送成功 消费结果：[nicai]]</p> <div class="language- extra-class"><pre class="language-text"><code>


- 符合预期~整个过程，好好理解艿艿在日志上，添加的过程注释噢。

😈 通过 RabbitMQ 来实现 RPC 的功能，看起来是比较酷炫的。不过艿艿暂时没有想到实际的使用场景，有了解的胖友，麻烦告知下艿艿噢，谢谢。

# 16. MessageConverter

&gt; 示例代码对应仓库：[lab-04-rabbitmq-demo-json](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json) 。

在 Spring-AMQP 中，通过 [MessageConverter](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/support/converter/MessageConverter.java) 来作为消息转换器：

- 在 Producer 中，将 Java POJO 转换成 AMQP [Message](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/Message.java) 。
- 在 Consumer 中，将 AMQP [Message](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/Message.java) 转换成 Java POJO 。

默认情况下，RabbitTemplate 采用 [SimpleMessageConverter](https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/converter/SimpleMessageConverter.java) 。而 SimpleMessageConverter 内部，采用 Java **自带**序列化方式，实现对 Java POJO 对象的序列化和反序列化，所以官方目前不是很推荐。主要缺点如下：

- 无法跨语言
- 序列化后的字节数组太大
- 序列化性能太低

因此一般情况下，我们建议采用 [Jackson2JsonMessageConverter](https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/support/converter/Jackson2JsonMessageConverter.java) ，使用 **JSON** 实现对 Java POJO 对象的序列化和反序列化。

下面，我们来搭建一个 Jackson2JsonMessageConverter 的使用示例。考虑到不污染上述的示例，我们新建一个 [lab-04-rabbitmq-demo-json](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json) 项目。

## 16.1 引入依赖

在 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/pom.xml) 文件中，引入相关依赖。



</code></pre></div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
<p><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><parent><groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.2.1.RELEASE</version> <relativePath></relativePath></parent> <modelVersion>4.0.0</modelVersion></project></p> <div class="language- extra-class"><pre><code>&lt;artifactId&gt;lab-04-rabbitmq-demo-json&lt;/artifactId&gt;

&lt;dependencies&gt;
    &lt;!-- 实现对 RabbitMQ 的自动化配置 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!-- Jackson 依赖  --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.9.10.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- 方便等会写单元测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre></div>
```
<ul><li>相比<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来说，额外引入 <code>jackson-databind</code> 依赖。</li></ul> <h2 id="_16-2-应用配置文件"><a href="#_16-2-应用配置文件" class="header-anchor">#</a> 16.2 应用配置文件</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/resources/https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_16-3-demo15message"><a href="#_16-3-demo15message" class="header-anchor">#</a> 16.3 Demo15Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo15Message.java" target="_blank" rel="noopener noreferrer">Demo15Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_16-4-rabbitconfig"><a href="#_16-4-rabbitconfig" class="header-anchor">#</a> 16.4 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，额外添加创建 Jackson2JsonMessageConverter Bean 。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitConfig.java

@Configuration
public class RabbitConfig {

    /**
     * Direct Exchange 示例的配置类
     */
    public static class DirectExchangeDemoConfiguration {

        // 创建 Queue
        @Bean
        public Queue demo15Queue() {
            return new Queue(Demo15Message.QUEUE, // Queue 名字
                    true, // durable: 是否持久化
                    false, // exclusive: 是否排它
                    false); // autoDelete: 是否自动删除
        }

        // 创建 Direct Exchange
        @Bean
        public DirectExchange demo15Exchange() {
            return new DirectExchange(Demo15Message.EXCHANGE,
                    true,  // durable: 是否持久化
                    false);  // exclusive: 是否排它
        }

        // 创建 Binding
        // Exchange：Demo15Message.EXCHANGE
        // Routing key：Demo15Message.ROUTING_KEY
        // Queue：Demo15Message.QUEUE
        @Bean
        public Binding demo15Binding() {
            return BindingBuilder.bind(demo15Queue()).to(demo15Exchange()).with(Demo15Message.ROUTING_KEY);
        }

    }

    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }

}
</code></pre></div><ul><li>在 <code>#messageConverter()</code> 方法，创建 Jackson2JsonMessageConverter Bean 对象。后续，<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitAutoConfiguration.java" target="_blank" rel="noopener noreferrer">RabbitAutoConfiguration.RabbitTemplateConfiguration<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 在创建 RabbitTemplate Bean 时，会自动注入它。</li></ul> <h2 id="_16-5-demo15producer"><a href="#_16-5-demo15producer" class="header-anchor">#</a> 16.5 Demo15Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo15Producer.java" target="_blank" rel="noopener noreferrer">Demo15Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、RoutingKey 名字不同。</p> <p>对于胖友来说，可能最关心的是，消息 Message 是怎么序列化的。</p> <ul><li>在序列化时，我们使用了 Jackson2JsonMessageConverter 序列化 Message 消息对象，它会在 RabbitMQ 消息 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/MessageProperties.java" target="_blank" rel="noopener noreferrer">MessageProperties<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的 <code>__TypeId__</code> 上，值为 Message 消息对应的<strong>类全名</strong>。</li> <li>在反序列化时，我们使用了 Jackson2JsonMessageConverter 序列化出 Message 消息对象，它会根据 RabbitMQ 消息 <a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-amqp/src/main/java/org/springframework/amqp/core/MessageProperties.java" target="_blank" rel="noopener noreferrer">MessageProperties<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的 <code>__TypeId__</code> 的值，反序列化消息内容成该 Message 对象。</li></ul> <h2 id="_16-6-demo15consumer"><a href="#_16-6-demo15consumer" class="header-anchor">#</a> 16.6 Demo15Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo15Consumer.java" target="_blank" rel="noopener noreferrer">Demo15Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo15Consumer.java

@Component
@RabbitListener(queues = Demo15Message.QUEUE)
public class Demo15Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler(isDefault = true)
    public void onMessage(Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(),
                new String(message.getBody()));
    }

}
</code></pre></div><ul><li>因为我们希望通过查看具体消息内容，判断是不是真的使用 JSON 格式，所以采用 AMQP Message 接收消息。</li></ul> <h2 id="_16-7-简单测试"><a href="#_16-7-简单测试" class="header-anchor">#</a> 16.7 简单测试</h2> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-json/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo15ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo15ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写单元测试方法，调用 Demo15Producer 发送消息的方法。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo15ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo15ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo15Producer producer;

    @Test
    public void testSyncSend() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><p>执行 <code>#testSyncSend()</code> 单元测试，输出日志如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 同步发送 1 条消息成功
2019-12-13 20:38:37.311  INFO 4285 --- [           main] c.i.s.l.r.producer.Demo15ProducerTest    : [testSyncSend][发送编号：[1576240717] 发送成功]

// Demo15Consumer 消费 1 条消息成功
// 从消息内容中，我们可以看到 JSON 格式，说明配置生效，嘿嘿。
2019-12-13 20:38:37.335  INFO 4285 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo15Consumer        : [onMessage][线程编号:17 消息内容：{&quot;id&quot;:1576240717}]
</code></pre></div><ul><li>符合预期~</li></ul> <h1 id="_17-消费异常处理器"><a href="#_17-消费异常处理器" class="header-anchor">#</a> 17. 消费异常处理器</h1> <blockquote><p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-error-handler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。</p></blockquote> <p>在<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「7. 消费重试」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，我们一起看了下，在 Consumer 消费异常时，Spring-AMQP 提供的<strong>消费重试</strong>机制。除此之外，在 Spring-AMQP 中可以自定义消费异常时的处理器。目前有两个接口，可以实现对 Consumer 消费异常的处理：</p> <ul><li><a href="https://github.com/spring-projects/spring-amqp/blob/master/spring-rabbit/src/main/java/org/springframework/amqp/rabbit/listener/api/RabbitListenerErrorHandler.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.amqp.rabbit.listener.api.RabbitListenerErrorHandler</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 接口</li> <li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ErrorHandler.java" target="_blank" rel="noopener noreferrer"><code>org.springframework.util.ErrorHandler</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 接口</li></ul> <p>下面，我们来搭建一个 RabbitListenerErrorHandler 和 ErrorHandler 的使用示例。考虑到不污染上述的示例，我们新建一个 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler" target="_blank" rel="noopener noreferrer">lab-04-rabbitmq-demo-error-handler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 项目。</p> <h2 id="_17-1-rabbitlistenererrorhandlerimpl"><a href="#_17-1-rabbitlistenererrorhandlerimpl" class="header-anchor">#</a> 17.1 RabbitListenerErrorHandlerImpl</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.core</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitListenerErrorHandlerImpl.java" target="_blank" rel="noopener noreferrer">RabbitListenerErrorHandlerImpl<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，实现 RabbitListenerErrorHandler 接口。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitListenerErrorHandler.java

@Component(&quot;rabbitListenerErrorHandler&quot;)
public class RabbitListenerErrorHandlerImpl implements RabbitListenerErrorHandler {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public Object handleError(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt; message,
                              ListenerExecutionFailedException exception) {
        // 打印异常日志
        logger.error(&quot;[handleError][amqpMessage:[{}] message:[{}]]&quot;, amqpMessage, message, exception);

        // 直接继续抛出异常
        throw exception;
    }

}
</code></pre></div><ul><li>在类上，添加 <code>@Component</code> 注解，并设置其 Bean 名为 <code>&quot;rabbitListenerErrorHandler&quot;</code> 。稍后，我们会使用到该 Bean 名字。</li> <li>在 <code>#handleError(...)</code> 方法中，我们先打印异常日志，并继续抛出 ListenerExecutionFailedException 异常。<strong>要注意</strong>，如果此时我们不继续抛出异常，而是 <code>return</code> 结果，意味着 Consumer 消息成功。如果我们结合<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「7. 消费重试」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一起使用的时候，一定要继续抛出该异常，否则消费重试机制将失效。</li></ul> <h2 id="_17-2-rabbitloggingerrorhandler"><a href="#_17-2-rabbitloggingerrorhandler" class="header-anchor">#</a> 17.2 RabbitLoggingErrorHandler</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.core</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/core/RabbitLoggingErrorHandler.java" target="_blank" rel="noopener noreferrer">RabbitLoggingErrorHandler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，实现 ErrorHandler 接口。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// RabbitLoggingErrorHandler.java

@Component
public class RabbitLoggingErrorHandler implements ErrorHandler {

    private Logger logger = LoggerFactory.getLogger(getClass());

    public RabbitLoggingErrorHandler(SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) {
        rabbitListenerContainerFactory.setErrorHandler(this);
    }

    @Override
    public void handleError(Throwable t) {
        logger.error(&quot;[handleError][发生异常]]&quot;, t);
    }

}
</code></pre></div><ul><li>在构造方法中，把自己设置到 SimpleRabbitListenerContainerFactory 中，作为其 ErrorHandler 异常处理器。</li> <li>在 <code>#handleError(...)</code> 方法中，打印错误日志。当然，具体怎么处理，胖友可以根据自己的需要哈。</li></ul> <p>在执行<strong>顺序</strong>上，RabbitListenerErrorHandler <strong>先</strong>于 ErrorHandler 执行。不过这个需要建立在一个前提上，RabbitListenerErrorHandler 需要继续抛出异常。</p> <p>另外，RabbitListenerErrorHandler 需要每个 <code>@RabbitListener</code> 注解上，需要每个手动设置下 <code>errorHandler</code> 属性。而 ErrorHandler 是相对全局的，所有 SimpleRabbitListenerContainerFactory 创建的 SimpleMessageListenerContainer 都会生效。</p> <p>具体选择 ErrorHandler 还是 RabbitLoggingErrorHandler ，艿艿暂时没有答案。不过个人感觉，如果不需要对 Consumer 消费的结果（包括成功和异常）做进一步处理，还是考虑 ErrorHandler 即可。在 ErrorHandler 中，我们可以通过判断 Throwable 异常是不是 ListenerExecutionFailedException 异常，从而拿到 Message 相关的信息。</p> <h2 id="_17-3-引入依赖"><a href="#_17-3-引入依赖" class="header-anchor">#</a> 17.3 引入依赖</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.1 引入依赖」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/pom.xml" target="_blank" rel="noopener noreferrer"><code>pom.xml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_17-4-应用配置文件"><a href="#_17-4-应用配置文件" class="header-anchor">#</a> 17.4 应用配置文件</h2> <p>和 <a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.2 应用配置文件」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 一致，见 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/resources/application.yaml" target="_blank" rel="noopener noreferrer"><code>application.yaml</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件。</p> <h2 id="_17-5-demo16message"><a href="#_17-5-demo16message" class="header-anchor">#</a> 17.5 Demo16Message</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.message</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/message/Demo16Message.java" target="_blank" rel="noopener noreferrer">Demo16Message<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息类，提供给当前示例使用。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.4 Demo01Message」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_17-6-rabbitconfig"><a href="#_17-6-rabbitconfig" class="header-anchor">#</a> 17.6 RabbitConfig</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.config</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/config/RabbitConfig.java" target="_blank" rel="noopener noreferrer">RabbitConfig<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 配置类，配置相关的 Exchange、Queue、Binding 。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.5 RabbitConfig」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、Queue、RoutingKey 名字不同。</p> <h2 id="_17-7-demo16producer"><a href="#_17-7-demo16producer" class="header-anchor">#</a> 17.7 Demo16Producer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.producer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo16Producer.java" target="_blank" rel="noopener noreferrer">Demo16Producer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，它会使用 Spring-AMQP 封装提供的 RabbitTemplate ，实现发送消息。</p> <p>和<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「3.1.6 Demo01Producer」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一致，只是 Exchange、RoutingKey 名字不同。</p> <h2 id="_17-8-demo16consumer"><a href="#_17-8-demo16consumer" class="header-anchor">#</a> 17.8 Demo16Consumer</h2> <p>在 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/" target="_blank" rel="noopener noreferrer"><code>cn.iocoder.springboot.lab04.rabbitmqdemo.consumer</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 包下，创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/main/java/cn/iocoder/springboot/lab04/rabbitmqdemo/consumer/Demo16Consumer.java" target="_blank" rel="noopener noreferrer">Demo16Consumer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类，消费消息。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo16Consumer.java

@Component
@RabbitListener(queues = Demo16Message.QUEUE,
    errorHandler = &quot;rabbitListenerErrorHandler&quot;)
public class Demo16Consumer {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @RabbitHandler
    public void onMessage(Demo16Message message) {
        logger.info(&quot;[onMessage][线程编号:{} 消息内容：{}]&quot;, Thread.currentThread().getId(), message);
        // 模拟消费异常
        throw new RuntimeException(&quot;你猜&quot;);
    }

}
</code></pre></div><ul><li>在 <code>@RabbitListener</code> 注解上，我们通过设置 <code>errorHandler</code> 属性为<a href="https://www.iocoder.cn/Spring-Boot/RabbitMQ/?github#" target="_blank" rel="noopener noreferrer">「17.1 RabbitListenerErrorHandlerImpl」<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的名字。</li> <li>在 <code>#onMessage(...)</code> 方法中，我们通过抛出 RuntimeException 异常，模拟消费异常。</li></ul> <h2 id="_17-9-简单测试"><a href="#_17-9-简单测试" class="header-anchor">#</a> 17.9 简单测试</h2> <p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-04-rabbitmq/lab-04-rabbitmq-demo-error-handler/src/test/java/cn/iocoder/springboot/lab04/rabbitmqdemo/producer/Demo16ProducerTest.java" target="_blank" rel="noopener noreferrer">Demo16ProducerTest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 测试类，编写单元测试方法，调用 Demo16Producer 发送消息的方法。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Demo16ProducerTest.java

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class Demo16ProducerTest {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private Demo16Producer producer;

    @Test
    public void testSyncSend() throws InterruptedException {
        int id = (int) (System.currentTimeMillis() / 1000);
        producer.syncSend(id);
        logger.info(&quot;[testSyncSend][发送编号：[{}] 发送成功]&quot;, id);

        // 阻塞等待，保证消费
        new CountDownLatch(1).await();
    }

}
</code></pre></div><p>执行 <code>#testSyncSend()</code> 单元测试，输出日志如下：</p> <div class="language- extra-class"><pre class="language-text"><code>// Producer 同步发送 1 条消息成功
2019-12-13 22:35:54.459  INFO 22515 --- [           main] c.i.s.l.r.producer.Demo16ProducerTest    : [testSyncSend][发送编号：[1576247754] 发送成功]

// Demo08Consumer 消费 1 条消息成功
2019-12-13 22:35:57.254  INFO 22515 --- [ntContainer#0-1] c.i.s.l.r.consumer.Demo16Consumer        : [onMessage][线程编号:18 消息内容：Demo16Message{id=1576247754}]

// RabbitListenerErrorHandler 先处理异常
2019-12-13 22:35:57.263 ERROR 22515 --- [ntContainer#0-1] i.s.l.r.c.RabbitListenerErrorHandlerImpl : [handleError][amqpMessage:[(Body:'[B@401abc48(byte[187])' MessageProperties [headers={}, contentType=application/x-java-serialized-object, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, redelivered=false, receivedExchange=EXCHANGE_DEMO_16, receivedRoutingKey=ROUTING_KEY_16, deliveryTag=1, consumerTag=amq.ctag-tUY94gzefw73JvHtgqwMnQ, consumerQueue=QUEUE_DEMO_16])] message:[GenericMessage [payload=Demo16Message{id=1576247754}, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=ROUTING_KEY_16, amqp_receivedExchange=EXCHANGE_DEMO_16, amqp_deliveryTag=1, amqp_consumerQueue=QUEUE_DEMO_16, amqp_channel=Cached Rabbit Channel: AMQChannel(amqp://guest@127.0.0.1:5672/,1), conn: Proxy@10bd9df0 Shared Rabbit Connection: SimpleConnection@68217d41 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 56809], amqp_redelivered=false, id=34327625-9ef4-0433-3514-a6633bfad100, amqp_consumerTag=amq.ctag-tUY94gzefw73JvHtgqwMnQ, amqp_lastInBatch=false, contentType=application/x-java-serialized-object, timestamp=1576247757255}]]]

org.springframework.amqp.rabbit.support.ListenerExecutionFailedException: Listener method 'public void cn.iocoder.springboot.lab04.rabbitmqdemo.consumer.Demo16Consumer.onMessage(cn.iocoder.springboot.lab04.rabbitmqdemo.message.Demo16Message)' threw exception
// ... 省略异常堆栈

// ErrorHandler 再处理器异常
2019-12-13 22:36:00.175 ERROR 22515 --- [ntContainer#0-1] c.i.s.l.r.c.RabbitLoggingErrorHandler    : [handleError][发生异常]]

org.springframework.amqp.rabbit.support.ListenerExecutionFailedException: Listener method 'public void cn.iocoder.springboot.lab04.rabbitmqdemo.consumer.Demo16Consumer.onMessage(cn.iocoder.springboot.lab04.rabbitmqdemo.message.Demo16Message)' threw exception
// ... 省略异常堆栈
</code></pre></div><ul><li>符合预期~</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/数据库/Mybatis/Mybatis.html" class="prev">
          Mybatis
        </a></span> <span class="next"><a href="/技术框架/rabbitmq/rabbitmq-springboot.html">
          Spring Boot 整合 RabbitMQ
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-direct-exchange" class="sidebar-link reco-side-_3-1-direct-exchange" data-v-b57cc07c>3.1 Direct Exchange</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-1-引入依赖" class="sidebar-link reco-side-_3-1-1-引入依赖" data-v-b57cc07c>3.1.1 引入依赖</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-2-应用配置文件" class="sidebar-link reco-side-_3-1-2-应用配置文件" data-v-b57cc07c>3.1.2 应用配置文件</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-3-application" class="sidebar-link reco-side-_3-1-3-application" data-v-b57cc07c>3.1.3 Application</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-4-demo01message" class="sidebar-link reco-side-_3-1-4-demo01message" data-v-b57cc07c>3.1.4 Demo01Message</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-5-rabbitconfig" class="sidebar-link reco-side-_3-1-5-rabbitconfig" data-v-b57cc07c>3.1.5 RabbitConfig</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-6-demo01producer" class="sidebar-link reco-side-_3-1-6-demo01producer" data-v-b57cc07c>3.1.6 Demo01Producer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-7-demo01consumer" class="sidebar-link reco-side-_3-1-7-demo01consumer" data-v-b57cc07c>3.1.7 Demo01Consumer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-1-8-简单测试" class="sidebar-link reco-side-_3-1-8-简单测试" data-v-b57cc07c>3.1.8 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-2-topic-exchange" class="sidebar-link reco-side-_3-2-topic-exchange" data-v-b57cc07c>3.2 Topic Exchange</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-2-1-demo02message" class="sidebar-link reco-side-_3-2-1-demo02message" data-v-b57cc07c>3.2.1 Demo02Message</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-2-2-rabbitconfig" class="sidebar-link reco-side-_3-2-2-rabbitconfig" data-v-b57cc07c>3.2.2 RabbitConfig</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-2-3-demo02producer" class="sidebar-link reco-side-_3-2-3-demo02producer" data-v-b57cc07c>3.2.3 Demo02Producer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-2-4-demo02consumer" class="sidebar-link reco-side-_3-2-4-demo02consumer" data-v-b57cc07c>3.2.4 Demo02Consumer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-2-5-简单测试" class="sidebar-link reco-side-_3-2-5-简单测试" data-v-b57cc07c>3.2.5 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-3-fanout-exchange" class="sidebar-link reco-side-_3-3-fanout-exchange" data-v-b57cc07c>3.3 Fanout Exchange</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-3-1-demo03message" class="sidebar-link reco-side-_3-3-1-demo03message" data-v-b57cc07c>3.3.1 Demo03Message</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-3-2-rabbitconfig" class="sidebar-link reco-side-_3-3-2-rabbitconfig" data-v-b57cc07c>3.3.2 RabbitConfig</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-3-3-demo03producer" class="sidebar-link reco-side-_3-3-3-demo03producer" data-v-b57cc07c>3.3.3 Demo03Producer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-3-4-demo03consumer" class="sidebar-link reco-side-_3-3-4-demo03consumer" data-v-b57cc07c>3.3.4 Demo03Consumer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-3-5-简单测试" class="sidebar-link reco-side-_3-3-5-简单测试" data-v-b57cc07c>3.3.5 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-4-headers-exchange" class="sidebar-link reco-side-_3-4-headers-exchange" data-v-b57cc07c>3.4 Headers Exchange</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-4-1-demo04message" class="sidebar-link reco-side-_3-4-1-demo04message" data-v-b57cc07c>3.4.1 Demo04Message</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-4-2-rabbitconfig" class="sidebar-link reco-side-_3-4-2-rabbitconfig" data-v-b57cc07c>3.4.2 RabbitConfig</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-4-3-demo04producer" class="sidebar-link reco-side-_3-4-3-demo04producer" data-v-b57cc07c>3.4.3 Demo04Producer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-4-4-demo04consumer" class="sidebar-link reco-side-_3-4-4-demo04consumer" data-v-b57cc07c>3.4.4 Demo04Consumer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_3-4-5-简单测试" class="sidebar-link reco-side-_3-4-5-简单测试" data-v-b57cc07c>3.4.5 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_4-1-引入依赖" class="sidebar-link reco-side-_4-1-引入依赖" data-v-b57cc07c>4.1 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_4-2-应用配置文件" class="sidebar-link reco-side-_4-2-应用配置文件" data-v-b57cc07c>4.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_4-3-demo05message" class="sidebar-link reco-side-_4-3-demo05message" data-v-b57cc07c>4.3 Demo05Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_4-4-rabbitconfig" class="sidebar-link reco-side-_4-4-rabbitconfig" data-v-b57cc07c>4.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_4-5-demo05producer" class="sidebar-link reco-side-_4-5-demo05producer" data-v-b57cc07c>4.5 Demo05Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_4-6-demo05consumer" class="sidebar-link reco-side-_4-6-demo05consumer" data-v-b57cc07c>4.6 Demo05Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_4-7-简单测试" class="sidebar-link reco-side-_4-7-简单测试" data-v-b57cc07c>4.7 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_5-1-rabbitconfig" class="sidebar-link reco-side-_5-1-rabbitconfig" data-v-b57cc07c>5.1 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_5-2-demo05consumer" class="sidebar-link reco-side-_5-2-demo05consumer" data-v-b57cc07c>5.2 Demo05Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_5-3-简单测试" class="sidebar-link reco-side-_5-3-简单测试" data-v-b57cc07c>5.3 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_6-1-引入依赖" class="sidebar-link reco-side-_6-1-引入依赖" data-v-b57cc07c>6.1 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_6-2-应用配置文件" class="sidebar-link reco-side-_6-2-应用配置文件" data-v-b57cc07c>6.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_6-3-demo06message" class="sidebar-link reco-side-_6-3-demo06message" data-v-b57cc07c>6.3 Demo06Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_6-4-rabbitconfig" class="sidebar-link reco-side-_6-4-rabbitconfig" data-v-b57cc07c>6.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_6-5-demo06producer" class="sidebar-link reco-side-_6-5-demo06producer" data-v-b57cc07c>6.5 Demo06Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_6-6-demo06consumer" class="sidebar-link reco-side-_6-6-demo06consumer" data-v-b57cc07c>6.6 Demo06Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_6-7-简单测试" class="sidebar-link reco-side-_6-7-简单测试" data-v-b57cc07c>6.7 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#有个小坑" class="sidebar-link reco-side-有个小坑" data-v-b57cc07c>有个小坑</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-1-引入依赖" class="sidebar-link reco-side-_7-1-引入依赖" data-v-b57cc07c>7.1 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-2-应用配置文件" class="sidebar-link reco-side-_7-2-应用配置文件" data-v-b57cc07c>7.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-3-demo07message" class="sidebar-link reco-side-_7-3-demo07message" data-v-b57cc07c>7.3 Demo07Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-4-rabbitconfig" class="sidebar-link reco-side-_7-4-rabbitconfig" data-v-b57cc07c>7.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-5-demo07producer" class="sidebar-link reco-side-_7-5-demo07producer" data-v-b57cc07c>7.5 Demo07Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-6-demo07consumer" class="sidebar-link reco-side-_7-6-demo07consumer" data-v-b57cc07c>7.6 Demo07Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-7-demo07deadconsumer" class="sidebar-link reco-side-_7-7-demo07deadconsumer" data-v-b57cc07c>7.7 Demo07DeadConsumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-8-简单测试" class="sidebar-link reco-side-_7-8-简单测试" data-v-b57cc07c>7.8 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_7-9-发送重试" class="sidebar-link reco-side-_7-9-发送重试" data-v-b57cc07c>7.9 发送重试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-1-引入依赖" class="sidebar-link reco-side-_8-1-引入依赖" data-v-b57cc07c>8.1 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-2-应用配置文件" class="sidebar-link reco-side-_8-2-应用配置文件" data-v-b57cc07c>8.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-3-demo08message" class="sidebar-link reco-side-_8-3-demo08message" data-v-b57cc07c>8.3 Demo08Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-4-rabbitconfig" class="sidebar-link reco-side-_8-4-rabbitconfig" data-v-b57cc07c>8.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-5-demo08producer" class="sidebar-link reco-side-_8-5-demo08producer" data-v-b57cc07c>8.5 Demo08Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-6-demo08consumer" class="sidebar-link reco-side-_8-6-demo08consumer" data-v-b57cc07c>8.6 Demo08Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-7-简单测试" class="sidebar-link reco-side-_8-7-简单测试" data-v-b57cc07c>8.7 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_8-8-rabbitmq-delayed-message-plugin" class="sidebar-link reco-side-_8-8-rabbitmq-delayed-message-plugin" data-v-b57cc07c>8.8 RabbitMQ Delayed Message Plugin</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-集群消费" class="sidebar-link reco-side-_9-1-集群消费" data-v-b57cc07c>9.1 集群消费</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-1-引入依赖" class="sidebar-link reco-side-_9-1-1-引入依赖" data-v-b57cc07c>9.1.1 引入依赖</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-2-应用配置文件" class="sidebar-link reco-side-_9-1-2-应用配置文件" data-v-b57cc07c>9.1.2 应用配置文件</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-3-clusteringmessage" class="sidebar-link reco-side-_9-1-3-clusteringmessage" data-v-b57cc07c>9.1.3 ClusteringMessage</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-4-rabbitconfig" class="sidebar-link reco-side-_9-1-4-rabbitconfig" data-v-b57cc07c>9.1.4 RabbitConfig</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-5-clusteringproducer" class="sidebar-link reco-side-_9-1-5-clusteringproducer" data-v-b57cc07c>9.1.5 ClusteringProducer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-6-clusteringconsumer" class="sidebar-link reco-side-_9-1-6-clusteringconsumer" data-v-b57cc07c>9.1.6 ClusteringConsumer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-1-7-简单测试" class="sidebar-link reco-side-_9-1-7-简单测试" data-v-b57cc07c>9.1.7 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-2-广播消费" class="sidebar-link reco-side-_9-2-广播消费" data-v-b57cc07c>9.2 广播消费</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-2-1-broadcastmessage" class="sidebar-link reco-side-_9-2-1-broadcastmessage" data-v-b57cc07c>9.2.1 BroadcastMessage</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-2-2-rabbitconfig" class="sidebar-link reco-side-_9-2-2-rabbitconfig" data-v-b57cc07c>9.2.2 RabbitConfig</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-2-3-broadcastproducer" class="sidebar-link reco-side-_9-2-3-broadcastproducer" data-v-b57cc07c>9.2.3 BroadcastProducer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-2-4-broadcastconsumer" class="sidebar-link reco-side-_9-2-4-broadcastconsumer" data-v-b57cc07c>9.2.4 BroadcastConsumer</a></li><li class="level-3" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_9-2-5-简单测试" class="sidebar-link reco-side-_9-2-5-简单测试" data-v-b57cc07c>9.2.5 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_10-1-引入依赖" class="sidebar-link reco-side-_10-1-引入依赖" data-v-b57cc07c>10.1 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_10-2-应用配置文件" class="sidebar-link reco-side-_10-2-应用配置文件" data-v-b57cc07c>10.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_10-3-demo09message" class="sidebar-link reco-side-_10-3-demo09message" data-v-b57cc07c>10.3 Demo09Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_10-4-rabbitconfig" class="sidebar-link reco-side-_10-4-rabbitconfig" data-v-b57cc07c>10.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_10-5-demo09producer" class="sidebar-link reco-side-_10-5-demo09producer" data-v-b57cc07c>10.5 Demo09Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_10-6-demo09consumer" class="sidebar-link reco-side-_10-6-demo09consumer" data-v-b57cc07c>10.6 Demo09Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_10-7-简单测试" class="sidebar-link reco-side-_10-7-简单测试" data-v-b57cc07c>10.7 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_11-1-引入依赖" class="sidebar-link reco-side-_11-1-引入依赖" data-v-b57cc07c>11.1 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_11-2-应用配置文件" class="sidebar-link reco-side-_11-2-应用配置文件" data-v-b57cc07c>11.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_11-3-demo10message" class="sidebar-link reco-side-_11-3-demo10message" data-v-b57cc07c>11.3 Demo10Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_11-4-rabbitconfig" class="sidebar-link reco-side-_11-4-rabbitconfig" data-v-b57cc07c>11.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_11-5-demo10producer" class="sidebar-link reco-side-_11-5-demo10producer" data-v-b57cc07c>11.5 Demo10Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_11-6-demo10consumer" class="sidebar-link reco-side-_11-6-demo10consumer" data-v-b57cc07c>11.6 Demo10Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_11-7-简单测试" class="sidebar-link reco-side-_11-7-简单测试" data-v-b57cc07c>11.7 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_12-1-引入依赖" class="sidebar-link reco-side-_12-1-引入依赖" data-v-b57cc07c>12.1 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_12-2-应用配置文件" class="sidebar-link reco-side-_12-2-应用配置文件" data-v-b57cc07c>12.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_12-3-demo11message" class="sidebar-link reco-side-_12-3-demo11message" data-v-b57cc07c>12.3 Demo11Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_12-4-rabbitconfig" class="sidebar-link reco-side-_12-4-rabbitconfig" data-v-b57cc07c>12.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_12-5-demo11producer" class="sidebar-link reco-side-_12-5-demo11producer" data-v-b57cc07c>12.5 Demo11Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_16-2-应用配置文件" class="sidebar-link reco-side-_16-2-应用配置文件" data-v-b57cc07c>16.2 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_16-3-demo15message" class="sidebar-link reco-side-_16-3-demo15message" data-v-b57cc07c>16.3 Demo15Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_16-4-rabbitconfig" class="sidebar-link reco-side-_16-4-rabbitconfig" data-v-b57cc07c>16.4 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_16-5-demo15producer" class="sidebar-link reco-side-_16-5-demo15producer" data-v-b57cc07c>16.5 Demo15Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_16-6-demo15consumer" class="sidebar-link reco-side-_16-6-demo15consumer" data-v-b57cc07c>16.6 Demo15Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_16-7-简单测试" class="sidebar-link reco-side-_16-7-简单测试" data-v-b57cc07c>16.7 简单测试</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-1-rabbitlistenererrorhandlerimpl" class="sidebar-link reco-side-_17-1-rabbitlistenererrorhandlerimpl" data-v-b57cc07c>17.1 RabbitListenerErrorHandlerImpl</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-2-rabbitloggingerrorhandler" class="sidebar-link reco-side-_17-2-rabbitloggingerrorhandler" data-v-b57cc07c>17.2 RabbitLoggingErrorHandler</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-3-引入依赖" class="sidebar-link reco-side-_17-3-引入依赖" data-v-b57cc07c>17.3 引入依赖</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-4-应用配置文件" class="sidebar-link reco-side-_17-4-应用配置文件" data-v-b57cc07c>17.4 应用配置文件</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-5-demo16message" class="sidebar-link reco-side-_17-5-demo16message" data-v-b57cc07c>17.5 Demo16Message</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-6-rabbitconfig" class="sidebar-link reco-side-_17-6-rabbitconfig" data-v-b57cc07c>17.6 RabbitConfig</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-7-demo16producer" class="sidebar-link reco-side-_17-7-demo16producer" data-v-b57cc07c>17.7 Demo16Producer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-8-demo16consumer" class="sidebar-link reco-side-_17-8-demo16consumer" data-v-b57cc07c>17.8 Demo16Consumer</a></li><li class="level-2" data-v-b57cc07c><a href="/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/rabbitmq/rabbitmq.html#_17-9-简单测试" class="sidebar-link reco-side-_17-9-简单测试" data-v-b57cc07c>17.9 简单测试</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.9ff2d364.js" defer></script><script src="/assets/js/3.531b82cf.js" defer></script><script src="/assets/js/1.66bfa7cb.js" defer></script><script src="/assets/js/132.eeae6af5.js" defer></script>
  </body>
</html>
